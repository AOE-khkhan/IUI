the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
the longest preﬁx match can be implemented by using different data structures. one possibility is to use a trie. the ﬁgure below shows a trie that encodes six routes having different outgoing interfaces.
note: special ipv4 addresses most unicast ipv4 addresses can appear as source and destination addresses in packets on the global internet. however, it is worth noting that some blocks of ipv4 addresses have a special usage, as described in rfc 5735. these include :
the easiest way to understand the operation of arp is to consider the simple network shown above and assume that host 10.0.1.22/24 needs to send an ipv4 packet to host 10.0.1.8. as this ip address belongs to the same subnet, the packet must be sent directly to its destination via the datalink layer service. to use this service, the sending host must ﬁnd the datalink layer address that is attached to host 10.0.1.8. each ipv4 host maintains an arp cache containing the list of all mappings between ipv4 addresses and datalink layer addresses that it knows. when an ipv4 hosts boots, its arp cache is empty. 10.0.1.22 thus ﬁrst consults its arp cache. as the cache does not contain the requested mapping, host 10.0.1.22 sends a broadcast arp query frame on the lan. the frame contains the datalink layer address of the sending host (a) and the requested ipv4 address (10.0.1.8). this broadcast frame is received by all devices on the lan and only the host that owns the requested ipv4 address replies by returning a unicast arp reply frame with the requested mapping. upon reception of this reply, the sending host updates its arp cache and sends the ipv4 packet by using the datalink layer service. to deal with devices that move or whose addresses are reconﬁgured, most arp implementations remove the cache entries that have not been used for a few minutes. some implementations re-validate arp cache entries from time to time by sending arp queries 13.
note: security issues with the address resolution protocol arp is an old and widely used protocol that was unfortunately designed when security issues were not a concern. arp is almost insecure by design. hosts using arp can be subject to several types of attack. first, a malicious host could create a denial of service attack on a lan by sending random replies to the received arp queries. this would pollute the arp cache of the other hosts on the same lan. on a ﬁxed network, such attacks can be detected by the system administrator who can physically remove the malicious hosts from the lan. on a wireless network, removing a malicious host is much more difﬁcult. a second type of attack are the man-in-the-middle attacks. this name is used for network attacks where the attacker is able to read and possibly modify all the messages sent by the attacked devices. such an attack is possible in a lan. assume, in the ﬁgure above, that host 10.0.1.9 is malicious and would like to receive and modify all the packets sent by host 10.0.1.22 to host 10.0.1.8. this can be achieved easily if host 10.0.1.9 manages, by sending fake arp replies, to convince host 10.0.1.22 (resp. 10.0.1.8) that its own datalink layer address must be used to reach 10.0.1.8 (resp. 10.0.1.22).
arp is used by all devices that are connected to a lan and implement ipv4. both routers and endhosts implement arp. when a host needs to send an ipv4 packet to a destination outside of its local subnet, it must ﬁrst send the packet to one of the routers that reside on this subnet. consider for example the network shown in the ﬁgure below. each host is conﬁgured with an ipv4 address in the 10.0.1.0/24 subnet and uses 10.0.1.1 as its default router. to send a packet to address 1.2.3.4, host 10.0.1.8 will ﬁrst need to know the datalink layer of the default router. it will thus send an arp request for 10.0.1.1. upon reception of the arp reply, host 10.0.1.8 updates its arp table and sends its packet in a frame to its default router. the router will then forward the packet towards its ﬁnal destination.
in the early days of the internet, ip addresses were manually conﬁgured on both hosts and routers and almost never changed. however, this manual conﬁguration can be complex 14 and often causes errors that are sometimes difﬁcult to debug. recent tcp/ip implementations are able to detect some of these misconﬁgurations. for example, if two hosts are attached to the same subnet with the same ipv4 address they will be unable to communicate. to detect this problem hosts send an arp request for their conﬁgured address each time their addressed is changed rfc 5227. if they receive an answer to this arp request, they trigger an alarm or inform the system administrator.
13 see chapter 28 of [benvenuti2005] for a description of the implementation of arp in the linux kernel. 14 for example, consider all the options that can be speciﬁed for the ifconﬁg utility<http://en.wikipedia.org/wiki/ifconﬁg> on unix hosts.
microseconds slot time. if the delay is longer, collisions between short frames may not be correctly detected. this constraint limits the geographical spread of 10baset networks containing hubs.
in the late 1980s, 10 mbps became too slow for some applications and network manufacturers developed several lan technologies that offered higher bandwidth, such as the 100 mbps fddi lan that used optical ﬁbers. as the development of 10base5, 10base2 and 10baset had shown that ethernet could be adapted to different physical layers, several manufacturers started to work on 100 mbps ethernet and convinced ieee to standardise this new technology that was initially called fast ethernet. fast ethernet was designed under two constraints. first, fast ethernet had to support twisted pairs. although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. second, fast ethernet had to be perfectly compatible with the existing 10 mbps ethernets to allow fast ethernet technology to be used initially as a backbone technology to interconnect 10 mbps ethernet networks. this forced fast ethernet to use exactly the same frame format as 10 mbps ethernet. this implied that the minimum fast ethernet frame size remained at 512 bits. to preserve csma/cd with this minimum frame size and 100 mbps instead of 10 mbps, the duration of the slot time was decreased to 5.12 microseconds. the evolution of ethernet did not stop. in 1998, the ieee published a ﬁrst standard to provide gigabit ethernet over optical ﬁbers. several other types of physical layers were added afterwards. the 10 gigabit ethernet standard appeared in 2002. work is ongoing to develop standards for 40 gigabit and 100 gigabit ethernet and some are thinking about terabit ethernet. the table below lists the main ethernet standards. a more detailed list may be found at http://en.wikipedia.org/wiki/ethernet_physical_layer
comments thick coaxial cable, 500m thin coaxial cable, 185m two pairs of category 3+ utp 10 mb/s over optical ﬁber category 5 utp or stp, 100 m maximum two multimode optical ﬁber, 2 km maximum
standard 10base5 10base2 10baset 10base-f 100base-tx 100base-fx 1000base-cx two pairs shielded twisted pair, 25m maximum 1000base-sx two multimode or single mode optical ﬁbers with lasers 10 gbps 40-100 gbps
increasing the physical layer bandwidth as in fast ethernet was only one of the solutions to improve the performance of ethernet lans. a second solution was to replace the hubs with more intelligent devices. as ethernet hubs operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach
[unicast, multicast and broadcast. while the ethernet service is unreliable in theory, a good ethernet network should, in practice, provide a service that :]
the ﬁrst property is a consequence of the utilisation of csma/cd. the second property is a consequence of the physical organisation of the ethernet network as a shared bus. these two properties are important and all evolutions of the ethernet technology have preserved them.
several physical layers have been deﬁned for ethernet networks. the ﬁrst physical layer, usually called 10base5, provided 10 mbps over a thick coaxial cable. the characteristics of the cable and the transceivers that were used then enabled the utilisation of 500 meter long segments. a 10base5 network can also include repeaters between segments. the second physical layer was 10base2. this physical layer used a thin coaxial cable that was easier to install than the 10base5 cable, but could not be longer than 185 meters. a 10basef physical layer was also deﬁned to transport ethernet over point-to-point optical links. the major change to the physical layer was the support of twisted pairs in the 10baset speciﬁcation. twisted pair cables are traditionally used to support the telephone service in ofﬁce buildings. most ofﬁce buildings today are equipped with structured cabling. several twisted pair cables are installed between any room and a central telecom closet per building or per ﬂoor in large buildings. these telecom closets act as concentration points for the telephone service but also for lans. the introduction of the twisted pairs led to two major changes to ethernet. the ﬁrst change concerns the physical topology of the network. 10base2 and 10base5 networks are shared buses, the coaxial cable typically passes through each room that contains a connected computer. a 10baset network is a star-shaped network. all the devices connected to the network are attached to a twisted pair cable that ends in the telecom closet. from a maintenance perspective, this is a major improvement. the cable is a weak point in 10base2 and 10base5 networks. any physical damage on the cable broke the entire network and when such a failure occurred, the network administrator had to manually check the entire cable to detect where it was damaged. with 10baset, when one twisted pair is damaged, only the device connected to this twisted pair is affected and this does not affect the other devices. the second major change introduced by 10baset was that is was impossible to build a 10baset network by simply connecting all the twisted pairs together. all the twisted pairs must be connected to a relay that operates in the physical layer. this relay is called an ethernet hub. a hub is thus a physical layer relay that receives an electrical signal on one of its interfaces, regenerates the signal and transmits it over all its other interfaces. some hubs are also able to convert the electrical signal from one physical layer to another (e.g. 10baset to 10base2 conversion).
computers can directly be attached to ethernet hubs. ethernet hubs themselves can be attached to other ethernet hubs to build a larger network. however, some important guidelines must be followed when building a complex network with hubs. first, the network topology must be a tree. as hubs are relays in the physical layer, adding a link between hub2 and hub3 in the network below would create an electrical shortcut that would completely disrupt the network. this implies that there cannot be any redundancy in a hub-based network. a failure of a hub or of a link between two hubs would partition the network into two isolated networks. second, as hubs are relays in the physical layer, collisions can happen and must be handled by csma/cd as in a 10base5 network. this implies that the maximum delay between any pair of devices in the network cannot be longer than the 51.2
[unicast, multicast and broadcast. while the ethernet service is unreliable in theory, a good ethernet network should, in practice, provide a service that :]
the ﬁrst property is a consequence of the utilisation of csma/cd. the second property is a consequence of the physical organisation of the ethernet network as a shared bus. these two properties are important and all evolutions of the ethernet technology have preserved them.
several physical layers have been deﬁned for ethernet networks. the ﬁrst physical layer, usually called 10base5, provided 10 mbps over a thick coaxial cable. the characteristics of the cable and the transceivers that were used then enabled the utilisation of 500 meter long segments. a 10base5 network can also include repeaters between segments. the second physical layer was 10base2. this physical layer used a thin coaxial cable that was easier to install than the 10base5 cable, but could not be longer than 185 meters. a 10basef physical layer was also deﬁned to transport ethernet over point-to-point optical links. the major change to the physical layer was the support of twisted pairs in the 10baset speciﬁcation. twisted pair cables are traditionally used to support the telephone service in ofﬁce buildings. most ofﬁce buildings today are equipped with structured cabling. several twisted pair cables are installed between any room and a central telecom closet per building or per ﬂoor in large buildings. these telecom closets act as concentration points for the telephone service but also for lans. the introduction of the twisted pairs led to two major changes to ethernet. the ﬁrst change concerns the physical topology of the network. 10base2 and 10base5 networks are shared buses, the coaxial cable typically passes through each room that contains a connected computer. a 10baset network is a star-shaped network. all the devices connected to the network are attached to a twisted pair cable that ends in the telecom closet. from a maintenance perspective, this is a major improvement. the cable is a weak point in 10base2 and 10base5 networks. any physical damage on the cable broke the entire network and when such a failure occurred, the network administrator had to manually check the entire cable to detect where it was damaged. with 10baset, when one twisted pair is damaged, only the device connected to this twisted pair is affected and this does not affect the other devices. the second major change introduced by 10baset was that is was impossible to build a 10baset network by simply connecting all the twisted pairs together. all the twisted pairs must be connected to a relay that operates in the physical layer. this relay is called an ethernet hub. a hub is thus a physical layer relay that receives an electrical signal on one of its interfaces, regenerates the signal and transmits it over all its other interfaces. some hubs are also able to convert the electrical signal from one physical layer to another (e.g. 10baset to 10base2 conversion).
computers can directly be attached to ethernet hubs. ethernet hubs themselves can be attached to other ethernet hubs to build a larger network. however, some important guidelines must be followed when building a complex network with hubs. first, the network topology must be a tree. as hubs are relays in the physical layer, adding a link between hub2 and hub3 in the network below would create an electrical shortcut that would completely disrupt the network. this implies that there cannot be any redundancy in a hub-based network. a failure of a hub or of a link between two hubs would partition the network into two isolated networks. second, as hubs are relays in the physical layer, collisions can happen and must be handled by csma/cd as in a 10base5 network. this implies that the maximum delay between any pair of devices in the network cannot be longer than the 51.2
[unicast, multicast and broadcast. while the ethernet service is unreliable in theory, a good ethernet network should, in practice, provide a service that :]
the ﬁrst property is a consequence of the utilisation of csma/cd. the second property is a consequence of the physical organisation of the ethernet network as a shared bus. these two properties are important and all evolutions of the ethernet technology have preserved them.
several physical layers have been deﬁned for ethernet networks. the ﬁrst physical layer, usually called 10base5, provided 10 mbps over a thick coaxial cable. the characteristics of the cable and the transceivers that were used then enabled the utilisation of 500 meter long segments. a 10base5 network can also include repeaters between segments. the second physical layer was 10base2. this physical layer used a thin coaxial cable that was easier to install than the 10base5 cable, but could not be longer than 185 meters. a 10basef physical layer was also deﬁned to transport ethernet over point-to-point optical links. the major change to the physical layer was the support of twisted pairs in the 10baset speciﬁcation. twisted pair cables are traditionally used to support the telephone service in ofﬁce buildings. most ofﬁce buildings today are equipped with structured cabling. several twisted pair cables are installed between any room and a central telecom closet per building or per ﬂoor in large buildings. these telecom closets act as concentration points for the telephone service but also for lans. the introduction of the twisted pairs led to two major changes to ethernet. the ﬁrst change concerns the physical topology of the network. 10base2 and 10base5 networks are shared buses, the coaxial cable typically passes through each room that contains a connected computer. a 10baset network is a star-shaped network. all the devices connected to the network are attached to a twisted pair cable that ends in the telecom closet. from a maintenance perspective, this is a major improvement. the cable is a weak point in 10base2 and 10base5 networks. any physical damage on the cable broke the entire network and when such a failure occurred, the network administrator had to manually check the entire cable to detect where it was damaged. with 10baset, when one twisted pair is damaged, only the device connected to this twisted pair is affected and this does not affect the other devices. the second major change introduced by 10baset was that is was impossible to build a 10baset network by simply connecting all the twisted pairs together. all the twisted pairs must be connected to a relay that operates in the physical layer. this relay is called an ethernet hub. a hub is thus a physical layer relay that receives an electrical signal on one of its interfaces, regenerates the signal and transmits it over all its other interfaces. some hubs are also able to convert the electrical signal from one physical layer to another (e.g. 10baset to 10base2 conversion).
computers can directly be attached to ethernet hubs. ethernet hubs themselves can be attached to other ethernet hubs to build a larger network. however, some important guidelines must be followed when building a complex network with hubs. first, the network topology must be a tree. as hubs are relays in the physical layer, adding a link between hub2 and hub3 in the network below would create an electrical shortcut that would completely disrupt the network. this implies that there cannot be any redundancy in a hub-based network. a failure of a hub or of a link between two hubs would partition the network into two isolated networks. second, as hubs are relays in the physical layer, collisions can happen and must be handled by csma/cd as in a 10base5 network. this implies that the maximum delay between any pair of devices in the network cannot be longer than the 51.2
the longest preﬁx match can be implemented by using different data structures. one possibility is to use a trie. the ﬁgure below shows a trie that encodes six routes having different outgoing interfaces.
note: special ipv4 addresses most unicast ipv4 addresses can appear as source and destination addresses in packets on the global internet. however, it is worth noting that some blocks of ipv4 addresses have a special usage, as described in rfc 5735. these include :
the easiest way to understand the operation of arp is to consider the simple network shown above and assume that host 10.0.1.22/24 needs to send an ipv4 packet to host 10.0.1.8. as this ip address belongs to the same subnet, the packet must be sent directly to its destination via the datalink layer service. to use this service, the sending host must ﬁnd the datalink layer address that is attached to host 10.0.1.8. each ipv4 host maintains an arp cache containing the list of all mappings between ipv4 addresses and datalink layer addresses that it knows. when an ipv4 hosts boots, its arp cache is empty. 10.0.1.22 thus ﬁrst consults its arp cache. as the cache does not contain the requested mapping, host 10.0.1.22 sends a broadcast arp query frame on the lan. the frame contains the datalink layer address of the sending host (a) and the requested ipv4 address (10.0.1.8). this broadcast frame is received by all devices on the lan and only the host that owns the requested ipv4 address replies by returning a unicast arp reply frame with the requested mapping. upon reception of this reply, the sending host updates its arp cache and sends the ipv4 packet by using the datalink layer service. to deal with devices that move or whose addresses are reconﬁgured, most arp implementations remove the cache entries that have not been used for a few minutes. some implementations re-validate arp cache entries from time to time by sending arp queries 13.
note: security issues with the address resolution protocol arp is an old and widely used protocol that was unfortunately designed when security issues were not a concern. arp is almost insecure by design. hosts using arp can be subject to several types of attack. first, a malicious host could create a denial of service attack on a lan by sending random replies to the received arp queries. this would pollute the arp cache of the other hosts on the same lan. on a ﬁxed network, such attacks can be detected by the system administrator who can physically remove the malicious hosts from the lan. on a wireless network, removing a malicious host is much more difﬁcult. a second type of attack are the man-in-the-middle attacks. this name is used for network attacks where the attacker is able to read and possibly modify all the messages sent by the attacked devices. such an attack is possible in a lan. assume, in the ﬁgure above, that host 10.0.1.9 is malicious and would like to receive and modify all the packets sent by host 10.0.1.22 to host 10.0.1.8. this can be achieved easily if host 10.0.1.9 manages, by sending fake arp replies, to convince host 10.0.1.22 (resp. 10.0.1.8) that its own datalink layer address must be used to reach 10.0.1.8 (resp. 10.0.1.22).
arp is used by all devices that are connected to a lan and implement ipv4. both routers and endhosts implement arp. when a host needs to send an ipv4 packet to a destination outside of its local subnet, it must ﬁrst send the packet to one of the routers that reside on this subnet. consider for example the network shown in the ﬁgure below. each host is conﬁgured with an ipv4 address in the 10.0.1.0/24 subnet and uses 10.0.1.1 as its default router. to send a packet to address 1.2.3.4, host 10.0.1.8 will ﬁrst need to know the datalink layer of the default router. it will thus send an arp request for 10.0.1.1. upon reception of the arp reply, host 10.0.1.8 updates its arp table and sends its packet in a frame to its default router. the router will then forward the packet towards its ﬁnal destination.
in the early days of the internet, ip addresses were manually conﬁgured on both hosts and routers and almost never changed. however, this manual conﬁguration can be complex 14 and often causes errors that are sometimes difﬁcult to debug. recent tcp/ip implementations are able to detect some of these misconﬁgurations. for example, if two hosts are attached to the same subnet with the same ipv4 address they will be unable to communicate. to detect this problem hosts send an arp request for their conﬁgured address each time their addressed is changed rfc 5227. if they receive an answer to this arp request, they trigger an alarm or inform the system administrator.
13 see chapter 28 of [benvenuti2005] for a description of the implementation of arp in the linux kernel. 14 for example, consider all the options that can be speciﬁed for the ifconﬁg utility<http://en.wikipedia.org/wiki/ifconﬁg> on unix hosts.
when developing its family of standards, the ieee 802.11 working group took a similar approach as the ieee 802.3 working group that developed various types of physical layers for ethernet networks. 802.11 networks use the csma/ca medium access control technique described earlier and they all assume the same architecture and use the same frame format. the architecture of wifi networks is slightly different from the local area networks that we have discussed until now. there are, in practice, two main types of wifi networks : independent or adhoc networks and infrastructure networks 11. an independent or adhoc network is composed of a set of devices that communicate with each other. these devices play the same role and the adhoc network is usually not connected to the global internet. adhoc networks are used when for example a few laptops need to exchange information or to connect a computer with a wifi printer.
most wifi networks are infrastructure networks. an infrastructure network contains one or more access points that are attached to a ﬁxed local area network (usually an ethernet network) that is connected to other networks such as the internet. the ﬁgure below shows such a network with two access points and four wifi devices. each wifi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the lan. an 802.11 access point is a relay that operates in the datalink layer like switches. the ﬁgure below represents the layers of the reference model that are involved when a wifi host communicates with a host attached to an ethernet network through an access point. 802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in ethernet lans. we review the key parts of the 802.11 frames. additional details may be found in [802.11] and [gast2002] . an 802.11 frame contains a ﬁxed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits crc. although the payload can contain up to 2324 bytes,
the ﬁrst problem faced by a token ring network is that as the token represents the authorization to transmit, it must continuously travel on the ring when no data frame is being transmitted. let us assume that a token has been produced and sent on the ring by one station. in token ring networks, the token is a 24 bits frame whose structure is shown below.
the token is composed of three ﬁelds. first, the starting delimiter is the marker that indicates the beginning of a frame. the ﬁrst token ring networks used manchester coding and the starting delimiter contained both symbols representing 0 and symbols that do not represent bits. the last ﬁeld is the ending delimiter which marks the end of the token. the access control ﬁeld is present in all frames, and contains several ﬂags. the most important is the token bit that is set in token frames and reset in other frames. let us consider the ﬁve station network depicted in ﬁgure a token ring network above and assume that station s1 sends a token. if we neglect the propagation delay on the inter-station links, as each station introduces a one bit delay, the ﬁrst bit of the frame would return to s1 while it sends the ﬁfth bit of the token. if station s1 is powered off at that time, only the ﬁrst ﬁve bits of the token will travel on the ring. to avoid this problem, there is a special station called the monitor on each token ring. to ensure that the token can travel forever on the ring, this monitor inserts a delay that is equal to at least 24 bit transmission times. if station s3 was the monitor in ﬁgure a token ring network, s1 would have been able to transmit the entire token before receiving the ﬁrst bit of the token from its upstream neighbour. now that we have explained how the token can be forwarded on the ring, let us analyse how a station can capture a token to transmit a data frame. for this, we need some information about the format of the data frames. an 802.5 data frame begins with the starting delimiter followed by the access control ﬁeld whose token bit is reset, a frame control ﬁeld that allows for the deﬁnition of several types of frames, destination and source address, a payload, a crc, the ending delimiter and a frame status ﬁeld. the format of the token ring data frames is illustrated below.
to capture a token, a station must operate in listen mode. in this mode, the station receives bits from its upstream neighbour. if the bits correspond to a data frame, they must be forwarded to the downstream neighbour. if they correspond to a token, the station can capture it and transmit its data frame. both the data frame and the token are encoded as a bit string beginning with the starting delimiter followed by the access control ﬁeld. when the station receives the ﬁrst bit of a starting delimiter, it cannot know whether this is a data frame or a token and
the ﬁrst problem faced by a token ring network is that as the token represents the authorization to transmit, it must continuously travel on the ring when no data frame is being transmitted. let us assume that a token has been produced and sent on the ring by one station. in token ring networks, the token is a 24 bits frame whose structure is shown below.
the token is composed of three ﬁelds. first, the starting delimiter is the marker that indicates the beginning of a frame. the ﬁrst token ring networks used manchester coding and the starting delimiter contained both symbols representing 0 and symbols that do not represent bits. the last ﬁeld is the ending delimiter which marks the end of the token. the access control ﬁeld is present in all frames, and contains several ﬂags. the most important is the token bit that is set in token frames and reset in other frames. let us consider the ﬁve station network depicted in ﬁgure a token ring network above and assume that station s1 sends a token. if we neglect the propagation delay on the inter-station links, as each station introduces a one bit delay, the ﬁrst bit of the frame would return to s1 while it sends the ﬁfth bit of the token. if station s1 is powered off at that time, only the ﬁrst ﬁve bits of the token will travel on the ring. to avoid this problem, there is a special station called the monitor on each token ring. to ensure that the token can travel forever on the ring, this monitor inserts a delay that is equal to at least 24 bit transmission times. if station s3 was the monitor in ﬁgure a token ring network, s1 would have been able to transmit the entire token before receiving the ﬁrst bit of the token from its upstream neighbour. now that we have explained how the token can be forwarded on the ring, let us analyse how a station can capture a token to transmit a data frame. for this, we need some information about the format of the data frames. an 802.5 data frame begins with the starting delimiter followed by the access control ﬁeld whose token bit is reset, a frame control ﬁeld that allows for the deﬁnition of several types of frames, destination and source address, a payload, a crc, the ending delimiter and a frame status ﬁeld. the format of the token ring data frames is illustrated below.
to capture a token, a station must operate in listen mode. in this mode, the station receives bits from its upstream neighbour. if the bits correspond to a data frame, they must be forwarded to the downstream neighbour. if they correspond to a token, the station can capture it and transmit its data frame. both the data frame and the token are encoded as a bit string beginning with the starting delimiter followed by the access control ﬁeld. when the station receives the ﬁrst bit of a starting delimiter, it cannot know whether this is a data frame or a token and
of the stream are delivered correctly in the same order at the other endpoint. however, the service provider does not attempt to preserve the boundaries of the sdus. there is no relation enforced by the service provider between the number of data.request and the number of data.indication primitives. the stream-mode is illustrated in the ﬁgure below. in practice, a consequence of the utilisation of the stream-mode is that if the users want to exchange structured sdus, they will need to provide the mechanisms that allow the receiving user to separate successive sdus in the byte stream that it receives. as we will see in the next chapter, application layer protocols often use speciﬁc delimiters such as the end of line character to delineate sdus in a bytestream.
the third phase of a connection is when it needs to be released. as a connection involves three parties (two users and one service provider), any of them can request the termination of the connection. usually, connections are terminated upon request of one user once the data transfer is ﬁnished. however, sometimes the service provider may be forced to terminate a connection. this can be due to lack of resources inside the service provider or because one of the users is not reachable anymore through the network. in this case, the service provider will issue disconnect.indication primitives to both users. these primitives will contain, as parameter, some information about the reason for the termination of the connection. unfortunately, as illustrated in the ﬁgure below, when a
sourceproviderdestinationtimeconnect.requestconnect.indicationconnect.confirmconnect.responsedata.request("a")data.request("bcd")data.request("ef")data.indication("a")data.indication("bcd")data.indication("ef")sourceproviderdestinationtimeconnect.requestconnect.indicationconnect.confirmconnect.responsedata.request("ab")data.request("cd")data.request("ef")data.indication("a")data.indication("b")data.indication("c")data.indication("def")saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
does not have a matching connection attempt and replies by sending a reject. unfortunately, this segment never reaches the remote entity. instead, the remote entity receives a retransmission of an older ca segment that contains the same sequence number as the ﬁrst cr segment. this ca segment cannot be accepted by the remote entity as a conﬁrmation of the transport connection as its acknowledgement number cannot have the same value as the sequence number of the ﬁrst ca segment.
when we discussed the connection-oriented service, we mentioned that there are two types of connection releases : abrupt release and graceful release. the ﬁrst solution to release a transport connection is to deﬁne a new control segment (e.g. the dr segment) and consider the connection to be released once this segment has been sent or received. this is illustrated in the ﬁgure below.
as the entity that sends the dr segment cannot know whether the other entity has already sent all its data on the connection, sdus can be lost during such an abrupt connection release. the second method to release a transport connection is to release independently the two directions of data transfer. once a user of the transport service has sent all its sdus, it performs a disconnect.req for its direction of data transfer. the transport entity sends a control segment to request the release of the connection after the delivery of all previous sdus to the remote user. this is usually done by placing in the dr the next sequence number and by delivering the disconnect.ind only after all previous data.ind. the remote entity conﬁrms the reception of the dr segment and the release of the corresponding direction of data transfer by returning an acknowledgement. this is illustrated in the ﬁgure below.
a congestion control scheme can be modelled as an algorithm that adapts the transmission rate (ri(t)) of host i based on the feedback received from the network. different types of feedbacks are possible. the simplest scheme is a binary feedback [cj1989] [jacobson1988] where the hosts simply learn whether the network is congested or not. some congestion control schemes allow the network to regularly send an allocated transmission rate in mbps to each host [bf1995]. let us focus on the binary feedback scheme which is the most widely used today. intuitively, the congestion control scheme should decrease the transmission rate of a host when congestion has been detected in the network, in order to avoid congestion collapse. furthermore, the hosts should increase their transmission rate when the network is not congested. otherwise, the hosts would not be able to efﬁciently utilise the network. the rate allocated to each host ﬂuctuates with time, depending on the feedback received from the network. the ﬁgure below illustrates the evolution of the transmission rates allocated to two hosts in our simple network. initially, two hosts have a low allocation, but this is not efﬁcient. the allocations increase until the network becomes congested. at this point, the hosts decrease their transmission rate to avoid congestion collapse. if the congestion control scheme works well, after some time the allocations should become both fair and efﬁcient.
various types of rate adaption algorithms are possible. dah ming chiu and raj jain have analysed, in [cj1989], different types of algorithms that can be used by a source to adapt its transmission rate to the feedback received from the network. intuitively, such a rate adaptation algorithm increases the transmission rate when the network is not congested (ensure that the network is efﬁciently used) and decrease the transmission rate when the network is congested (to avoid congestion collapse). the simplest form of feedback that the network can send to a source is a binary feedback (the network is congested or not congested). in this case, a linear rate adaptation algorithm can be expressed as :
with a linear adaption algorithm, αc, αn , βc and βn are constants. the analysis of [cj1989] shows that to be fair and efﬁcient, such a binary rate adaption mechanism must rely on additive increase and multiplicative decrease. when the network is not congested, the hosts should slowly increase their transmission rate (βn = 1 and αn > 0). when the network is congested, the hosts must multiplicatively decrease their transmission rate (βc < 1 and αc = 0). such an aimd rate adaptation algorithm can be implemented by the pseudo-code below
note: which binary feedback ? two types of binary feedback are possible in computer networks. a ﬁrst solution is to rely on implicit feedback. this is the solution chosen for tcp. tcp’s congestion control scheme [jacobson1988] does not require any cooperation from the router. it only assumes that they use buffers and that they discard packets when there is congestion.
the last transmission mode is the anycast transmission mode. in this transmission mode, a set of receivers is identiﬁed. when a source sends information towards this set of receivers, the network ensures that the information is delivered to one receiver that belongs to this set. usually, the receiver closest to the source is the one that receives the information sent by this particular source. the anycast transmission mode is useful to ensure redundancy, as when one of the receivers fails, the network will ensure that information will be delivered to another receiver belonging to the same group. however, in practice supporting the anycast transmission mode can be difﬁcult.
in the example above, the three hosts marked with * are part of the same anycast group. when host s sends information to this anycast group, the network ensures that it will reach one of the members of the anycast group. the dashed lines show a possible delivery via nodes 1, 2 and 4. a subsequent anycast transmission from host s to the same anycast group could reach the host attached to intermediate node 3 as shown by the plain line. an anycast transmission reaches a member of the anycast group that is chosen by the network in function of the current network conditions.
an important aspect to understand before studying computer networks is the difference between a service and a protocol. in order to understand the difference between the two, it is useful to start with real world examples. the traditional post provides a service where a postman delivers letters to recipients. the post deﬁnes precisely which types of letters (size, weight, etc) can be delivered by using the standard mail service. furthermore, the format of the envelope is speciﬁed (position of the sender and recipient addresses, position of the stamp). someone who wants to send a letter must either place the letter at a post ofﬁce or inside one of the dedicated mailboxes. the letter will then be collected and delivered to its ﬁnal recipient. note that for the regular service the post usually does not guarantee the delivery of each particular letter, some letters may be lost, and some letters are delivered to the wrong mailbox. if a letter is important, then the sender can use the registered service to ensure that the letter will be delivered to its recipient. some post services also provide an acknowledged service or an express mail service that is faster than the regular service. in computer networks, the notion of service is more formally deﬁned in [x200] . it can be better understood by considering a computer network, whatever its size or complexity, as a black box that provides a service to users , as shown in the ﬁgure below. these users could be human users or processes running on a computer system. many users can be attached to the same service provider. through this provider, each user must be able to exchange messages with any other user. to be able to deliver these messages, the service provider must be able to unambiguously identify each user. in computer networks, each user is identiﬁed by a unique address, we will discuss later how these addresses are built and used. at this point, and when considering unicast transmission, the main characteristic of these addresses is that they are unique. two different users attached to the network cannot use the same address.
of the network. from a performance perspective, it would be more interesting to have devices that operate in the datalink layer and can analyse the destination address of each frame and forward the frames selectively on the link that leads to the destination. such devices are usually called ethernet switches 10. an ethernet switch is a relay that operates in the datalink layer as is illustrated in the ﬁgure below.
an ethernet switch understands the format of the ethernet frames and can selectively forward frames over each interface. for this, each ethernet switch maintains a mac address table. this table contains, for each mac address known by the switch, the identiﬁer of the switch’s port over which a frame sent towards this address must be forwarded to reach its destination. this is illustrated below with the mac address table of the bottom switch. when the switch receives a frame destined to address b, it forwards the frame on its south port. if it receives a frame destined to address d, it forwards it only on its north port.
one of the selling points of ethernet networks is that, thanks to the utilisation of 48 bits mac addresses, an ethernet lan is plug and play at the datalink layer. when two hosts are attached to the same ethernet segment or hub, they can immediately exchange ethernet frames without requiring any conﬁguration. it is important to retain this plug and play capability for ethernet switches as well. this implies that ethernet switches must be able to build their mac address table automatically without requiring any manual conﬁguration. this automatic conﬁguration is performed by the the mac address learning algorithm that runs on each ethernet switch. this algorithm extracts the source address of the received frames and remembers the port over which a frame from
10 the ﬁrst ethernet relays that operated in the datalink layers were called bridges. in practice, the main difference between switches and bridges is that bridges were usually implemented in software while switches are hardware-based devices. throughout this text, we always use switch when referring to a relay in the datalink layer, but you might still see the word bridge.
as mentioned in the ﬁrst section of this chapter, there are three main types of datalink layers : point-to-point links, lans supporting broadcast and multicast and nbma networks. there are two important issues to be addressed when using ipv4 in these types of networks. the ﬁrst issue is how an ipv4 device obtains its ipv4 address. the second issue is how ipv4 packets are exchanged over the datalink layer service. on a point-to-point link, the ipv4 addresses of the communicating devices can be conﬁgured manually or by using a simple protocol. ipv4 addresses are often conﬁgured manually on point-to-point links between routers. when point-to-point links are used to attach hosts to the network, automatic conﬁguration is often preferred in order to avoid problems with incorrect ipv4 addresses. for example, the ppp, speciﬁed in rfc 1661, includes an ip network control protocol that can be used by the router in the ﬁgure below to send the ipv4 address that the attached host must conﬁgure for its interface. the transmission of ipv4 packets on a point-to-point link will be discussed in chapter chap:lan.
using ipv4 in a lan introduces an additional problem. on a lan, each device is identiﬁed by its unique datalink layer address. the datalink layer service can be used by any host attached to the lan to send a frame to any other host attached to the same lan. for this, the sending host must know the datalink layer address of the destination host. for example, the ﬁgure below shows four hosts attached to the same lan conﬁgured with ipv4 addresses in the 10.0.1.0/24 subnet and datalink layer addresses represented as a single character 12. in this network, if host 10.0.1.22/24 wants to send an ipv4 packet to the host having address 10.0.1.8, it must know that the datalink layer address of this host is c.
in a simple network such as the one shown above, it could be possible to manually conﬁgure the mapping between the ipv4 addresses of the hosts and the corresponding datalink layer addresses. however, in a larger lan this is impossible. to ease the utilisation of lans, ipv4 hosts must be able to automatically obtain the datalink layer address corresponding to any ipv4 address on the same lan. this is the objective of the address resolution protocol (arp) deﬁned in rfc 826. arp is a datalink layer protocol that is used by ipv4. it relies on the ability of the datalink layer service to easily deliver a broadcast frame to all devices attached to the same lan.
when developing its family of standards, the ieee 802.11 working group took a similar approach as the ieee 802.3 working group that developed various types of physical layers for ethernet networks. 802.11 networks use the csma/ca medium access control technique described earlier and they all assume the same architecture and use the same frame format. the architecture of wifi networks is slightly different from the local area networks that we have discussed until now. there are, in practice, two main types of wifi networks : independent or adhoc networks and infrastructure networks 11. an independent or adhoc network is composed of a set of devices that communicate with each other. these devices play the same role and the adhoc network is usually not connected to the global internet. adhoc networks are used when for example a few laptops need to exchange information or to connect a computer with a wifi printer.
most wifi networks are infrastructure networks. an infrastructure network contains one or more access points that are attached to a ﬁxed local area network (usually an ethernet network) that is connected to other networks such as the internet. the ﬁgure below shows such a network with two access points and four wifi devices. each wifi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the lan. an 802.11 access point is a relay that operates in the datalink layer like switches. the ﬁgure below represents the layers of the reference model that are involved when a wifi host communicates with a host attached to an ethernet network through an access point. 802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in ethernet lans. we review the key parts of the 802.11 frames. additional details may be found in [802.11] and [gast2002] . an 802.11 frame contains a ﬁxed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits crc. although the payload can contain up to 2324 bytes,
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
occur. in optical networks, a variant of fdm called wavelength division multiplexing (wdm) can be used. an optical ﬁber can transport light at different wavelengths without interference. with wdm, a different wavelength is allocated to each of the devices that share the same optical ﬁber. time division multiplexing (tdm) is a static bandwidth allocation method that was initially deﬁned for the telephone network. in the ﬁxed telephone network, a voice conversation is usually transmitted as a 64 kbps signal. thus, a telephone conservation generates 8 kbytes per second or one byte every 125 microsecond. telephone conversations often need to be multiplexed together on a single line. for example, in europe, thirty 64 kbps voice signals are multiplexed over a single 2 mbps (e1) line. this is done by using time division multiplexing (tdm). tdm divides the transmission opportunities into slots. in the telephone network, a slot corresponds to 125 microseconds. a position inside each slot is reserved for each voice signal. the ﬁgure below illustrates tdm on a link that is used to carry four voice conversations. the vertical lines represent the slot boundaries and the letters the different voice conversations. one byte from each voice conversation is sent during each 125 microsecond slot. the byte corresponding to a given conversation is always sent at the same position in each slot.
tdm as shown above can be completely static, i.e. the same conversations always share the link, or dynamic. in the latter case, the two endpoints of the link must exchange messages specifying which conversation uses which byte inside each slot. thanks to these signalling messages, it is possible to dynamically add and remove voice conversations from a given link. tdm and fdm are widely used in telephone networks to support ﬁxed bandwidth conversations. using them in local area networks that support computers would probably be inefﬁcient. computers usually do not send information at a ﬁxed rate. instead, they often have an on-off behaviour. during the on period, the computer tries to send at the highest possible rate, e.g. to transfer a ﬁle. during the off period, which is often much longer than the on period, the computer does not transmit any packet. using a static allocation scheme for computers attached to a lan would lead to huge inefﬁciencies, as they would only be able to transmit at 1 n of the total bandwidth during their on period, despite the fact that the other computers are in their off period and thus do not need to transmit any information. the dynamic mac algorithms discussed in the remainder of this chapter aim solve this problem.
in the 1960s, computers were mainly mainframes with a few dozen terminals attached to them. these terminals were usually in the same building as the mainframe and were directly connected to it. in some cases, the terminals were installed in remote locations and connected through a modem attached to a dial-up line. the university of hawaii chose a different organisation. instead of using telephone lines to connect the distant terminals, they developed the ﬁrst packet radio technology [abramson1970]. until then, computer networks were built on top of either the telephone network or physical cables. alohanet showed that it was possible to use radio signals to interconnect computers. the ﬁrst version of alohanet, described in [abramson1970], operated as follows: first, the terminals and the mainframe exchanged ﬁxed-length frames composed of 704 bits. each frame contained 80 8-bit characters, some control bits and parity information to detect transmission errors. two channels in the 400 mhz range were reserved for the operation of alohanet. the ﬁrst channel was used by the mainframe to send frames to all terminals. the second channel was shared among all terminals to send frames to the mainframe. as all terminals share the same transmission channel, there is a risk of collision. to deal with this problem as well as transmission errors, the mainframe veriﬁed the parity bits of the received frame and sent an acknowledgement on its channel for each correctly received frame. the terminals on the other hand had to retransmit the unacknowledged frames. as for tcp, retransmitting these frames immediately upon expiration of a ﬁxed timeout is not a good approach as several terminals may retransmit their frames at the same time leading to a network collapse. a better approach, but still far from perfect, is for each terminal to wait a random amount of time after the expiration of its retransmission timeout. this avoids synchronisation among multiple retransmitting terminals.
the data segment that has not been acknowledged. unfortunately, as illustrated in the ﬁgure below, the receiver considers the retransmission as a new segment whose payload must be delivered to its user.
to solve this problem, transport protocols associate a sequence number to each data segment. this sequence number is one of the ﬁelds found in the header of data segments. we use the notation d(s,...) to indicate a data segment whose sequence number ﬁeld is set to s. the acknowledgements also contain a sequence number indicating the data segments that it is acknowledging. we use oks to indicate an acknowledgement segment that conﬁrms the reception of d(s,...). the sequence number is encoded as a bit string of ﬁxed length. the simplest transport protocol is the alternating bit protocol (abp). the alternating bit protocol uses a single bit to encode the sequence number. it can be implemented easily. the sender and the receivers only require a four states finite state machine.
d(a)abdata.req(a)data.ind(a)data.req(b)c(ok)d(b)data.ind(b)c(ok)d(b)start timertimer expireslost segmentstart timercancel timerd(a)abdata.req(a)data.ind(a)data.req(b)c(ok)d(b)data.ind(b) !!!!!!c(ok)d(b)start timertimer expireslost segmentstart timercancel timerc(ok)data.ind(b)saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
contains information about its origin and its destination, and usually passes through several intermediate devices called routers on its way from its origin to its destination.
most realisations of the network layer, including the internet, do not provide a reliable service. however, many applications need to exchange information reliably and so using the network layer service directly would be very difﬁcult for them. ensuring the reliable delivery of the data produced by applications is the task of the transport layer. transport layer entities exchange segments. a segment is a ﬁnite sequence of bytes that are transported inside one or more packets. a transport layer entity issues segments (or sometimes part of segments) as data.request to the underlying network layer entity. there are different types of transport layers. the most widely used transport layers on the internet are tcp ,that provides a reliable connection-oriented bytestream transport service, and udp ,that provides an unreliable connection-less transport service.
the upper layer of our architecture is the application layer. this layer includes all the mechanisms and data structures that are necessary for the applications. we will use application data unit (adu) to indicate the data exchanged between two entities of the application layer.
in contrast with osi, the tcp/ip community did not spend a lot of effort deﬁning a detailed reference model; in fact, the goals of the internet architecture were only documented after tcp/ip had been deployed [clark88]. rfc 1122 , which deﬁnes the requirements for internet hosts, mentions four different layers. starting from the top, these are :
• an application layer • a transport layer • an internet layer which is equivalent to the network layer of our reference model • a link layer which combines the functionalities of the physical and datalink layers of our ﬁve-layer reference
physical layerdatalinknetworkphysical layerdatalinknetworkphysical layerdatalinknetworkpacketspacketsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportsegmentsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportaduapplicationapplicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
as mentioned in the ﬁrst section of this chapter, there are three main types of datalink layers : point-to-point links, lans supporting broadcast and multicast and nbma networks. there are two important issues to be addressed when using ipv4 in these types of networks. the ﬁrst issue is how an ipv4 device obtains its ipv4 address. the second issue is how ipv4 packets are exchanged over the datalink layer service. on a point-to-point link, the ipv4 addresses of the communicating devices can be conﬁgured manually or by using a simple protocol. ipv4 addresses are often conﬁgured manually on point-to-point links between routers. when point-to-point links are used to attach hosts to the network, automatic conﬁguration is often preferred in order to avoid problems with incorrect ipv4 addresses. for example, the ppp, speciﬁed in rfc 1661, includes an ip network control protocol that can be used by the router in the ﬁgure below to send the ipv4 address that the attached host must conﬁgure for its interface. the transmission of ipv4 packets on a point-to-point link will be discussed in chapter chap:lan.
using ipv4 in a lan introduces an additional problem. on a lan, each device is identiﬁed by its unique datalink layer address. the datalink layer service can be used by any host attached to the lan to send a frame to any other host attached to the same lan. for this, the sending host must know the datalink layer address of the destination host. for example, the ﬁgure below shows four hosts attached to the same lan conﬁgured with ipv4 addresses in the 10.0.1.0/24 subnet and datalink layer addresses represented as a single character 12. in this network, if host 10.0.1.22/24 wants to send an ipv4 packet to the host having address 10.0.1.8, it must know that the datalink layer address of this host is c.
in a simple network such as the one shown above, it could be possible to manually conﬁgure the mapping between the ipv4 addresses of the hosts and the corresponding datalink layer addresses. however, in a larger lan this is impossible. to ease the utilisation of lans, ipv4 hosts must be able to automatically obtain the datalink layer address corresponding to any ipv4 address on the same lan. this is the objective of the address resolution protocol (arp) deﬁned in rfc 826. arp is a datalink layer protocol that is used by ipv4. it relies on the ability of the datalink layer service to easily deliver a broadcast frame to all devices attached to the same lan.
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
as mentioned in the ﬁrst section of this chapter, there are three main types of datalink layers : point-to-point links, lans supporting broadcast and multicast and nbma networks. there are two important issues to be addressed when using ipv4 in these types of networks. the ﬁrst issue is how an ipv4 device obtains its ipv4 address. the second issue is how ipv4 packets are exchanged over the datalink layer service. on a point-to-point link, the ipv4 addresses of the communicating devices can be conﬁgured manually or by using a simple protocol. ipv4 addresses are often conﬁgured manually on point-to-point links between routers. when point-to-point links are used to attach hosts to the network, automatic conﬁguration is often preferred in order to avoid problems with incorrect ipv4 addresses. for example, the ppp, speciﬁed in rfc 1661, includes an ip network control protocol that can be used by the router in the ﬁgure below to send the ipv4 address that the attached host must conﬁgure for its interface. the transmission of ipv4 packets on a point-to-point link will be discussed in chapter chap:lan.
using ipv4 in a lan introduces an additional problem. on a lan, each device is identiﬁed by its unique datalink layer address. the datalink layer service can be used by any host attached to the lan to send a frame to any other host attached to the same lan. for this, the sending host must know the datalink layer address of the destination host. for example, the ﬁgure below shows four hosts attached to the same lan conﬁgured with ipv4 addresses in the 10.0.1.0/24 subnet and datalink layer addresses represented as a single character 12. in this network, if host 10.0.1.22/24 wants to send an ipv4 packet to the host having address 10.0.1.8, it must know that the datalink layer address of this host is c.
in a simple network such as the one shown above, it could be possible to manually conﬁgure the mapping between the ipv4 addresses of the hosts and the corresponding datalink layer addresses. however, in a larger lan this is impossible. to ease the utilisation of lans, ipv4 hosts must be able to automatically obtain the datalink layer address corresponding to any ipv4 address on the same lan. this is the objective of the address resolution protocol (arp) deﬁned in rfc 826. arp is a datalink layer protocol that is used by ipv4. it relies on the ability of the datalink layer service to easily deliver a broadcast frame to all devices attached to the same lan.
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
when developing its family of standards, the ieee 802.11 working group took a similar approach as the ieee 802.3 working group that developed various types of physical layers for ethernet networks. 802.11 networks use the csma/ca medium access control technique described earlier and they all assume the same architecture and use the same frame format. the architecture of wifi networks is slightly different from the local area networks that we have discussed until now. there are, in practice, two main types of wifi networks : independent or adhoc networks and infrastructure networks 11. an independent or adhoc network is composed of a set of devices that communicate with each other. these devices play the same role and the adhoc network is usually not connected to the global internet. adhoc networks are used when for example a few laptops need to exchange information or to connect a computer with a wifi printer.
most wifi networks are infrastructure networks. an infrastructure network contains one or more access points that are attached to a ﬁxed local area network (usually an ethernet network) that is connected to other networks such as the internet. the ﬁgure below shows such a network with two access points and four wifi devices. each wifi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the lan. an 802.11 access point is a relay that operates in the datalink layer like switches. the ﬁgure below represents the layers of the reference model that are involved when a wifi host communicates with a host attached to an ethernet network through an access point. 802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in ethernet lans. we review the key parts of the 802.11 frames. additional details may be found in [802.11] and [gast2002] . an 802.11 frame contains a ﬁxed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits crc. although the payload can contain up to 2324 bytes,
ﬁeld of the rts frame indicates the duration of the entire reservation (i.e. the time required to transmit the cts, the data frame, the acknowledgements and the required sifs delays). the cts frame has the same format as the acknowledgement frame.
note: the 802.11 service despite the utilization of acknowledgements, the 802.11 layer only provides an unreliable connectionless service like ethernet networks that do not use acknowledgements. the 802.11 acknowledgements are used to minimize the probability of frame duplication. they do not guarantee that all frames will be correctly received by their recipients. like ethernet, 802.11 networks provide a high probability of successful delivery of the frames, not a guarantee. furthermore, it should be noted that 802.11 networks do not use acknowledgements for multicast and broadcast frames. this implies that in practice such frames are more likely to suffer from transmission errors than unicast frames.
in addition to the data and control frames that we have brieﬂy described above, 802.11 networks use several types of management frames. these management frames are used for various purposes. we brieﬂy describe some of these frames below. a detailed discussion may be found in [802.11] and [gast2002]. a ﬁrst type of management frames are the beacon frames. these frames are broadcasted regularly by access points. each beacon frame contains information about the capabilities of the access point (e.g. the supported 802.11 transmission rates) and a service set identity (ssid). the ssid is a null-terminated ascii string that can contain up to 32 characters. an access point may support several ssids and announce them in beacon frames. an access point may also choose to remain silent and not advertise beacon frames. in this case, wifi stations may send probe request frames to force the available access points to return a probe response frame.
note: ip over 802.11 two types of encapsulation schemes were deﬁned to support ip in ethernet networks : the original encapsulation scheme, built above the ethernet dix format is deﬁned in rfc 894 and a second encapsulation rfc 1042 scheme, built above the llc/snap protocol [802.2]. in 802.11 networks, the situation is simpler and only the rfc 1042 encapsulation is used. in practice, this encapsulation adds 6 bytes to the 802.11 header. the ﬁrst four bytes correspond to the llc/snap header. they are followed by the two bytes ethernet type ﬁeld (0x800 for ip and 0x806 for arp). the ﬁgure below shows an ip packet encapsulated in an 802.11 frame.
the second important utilisation of the management frames is to allow a wifi station to be associated with an access point. when a wifi station starts, it listens to beacon frames to ﬁnd the available ssids. to be allowed to
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
from a conceptual point of view, a bgp router connected to n bgp peers, can be described as being composed of four parts as shown in the ﬁgure below.
in this ﬁgure, the router receives bgp messages on the left part of the ﬁgure, processes these messages and possibly sends bgp messages on the right part of the ﬁgure. a bgp router contains three important data structures :
• the adj-rib-in contains the bgp routes that have been received from each bgp peer. the routes in the adj-rib-in are ﬁltered by the import ﬁlter before being placed in the bgp-loc-rib. there is one import ﬁlter per bgp peer.
• the local routing information base (loc-rib) contains all the routes that are considered as acceptable by the router. the loc-rib may contain several routes, learned from different bgp peers, towards the same destination preﬁx.
• the forwarding information base (fib) is used by the dataplane to forward packets towards their destination. the fib contains, for each destination, the best route that has been selected by the bgp decision process. this decision process is an algorithm that selects, for each destination preﬁx, the best route according to the router’s ranking algorithm that is part of its policy.
• the adj-rib-out contains the bgp routes that have been advertised to each bgp peer. the adj-rib-out for a given peer is built by applying the peer‘s export ﬁlter on the routes that have been installed in the fib. there is one export ﬁlter per bgp peer. for this reason, the adj-rib-out of a peer may contain different routes than the adj-rib-out of another peer.
when a bgp session starts, the routers ﬁrst exchange open messages to negotiate the options that apply throughout the entire session. then, each router extracts from its fib the routes to be advertised to the peer. it is important to note that, for each known destination preﬁx, a bgp router can only advertise to a peer the route that it has itself installed inside its fib. the routes that are advertised to a peer must pass the peer’s export ﬁlter. the export ﬁlter is a set of rules that deﬁne which routes can be advertised over the corresponding session, possibly after having modiﬁed some of its attributes. one export ﬁlter is associated to each bgp session. for example, on a shared-cost peering, the export ﬁlter only selects the internal routes and the routes that have been learned from a customer. the pseudo-code below shows the initialisation of a bgp session.
# initialize and start bgp session # send bgp open message to remoteip on port 179 # follow bgp state machine # advertise local routes and routes learned from peers*/ for d in bgplocrib :
in the above pseudo-code, the build_bgp_update(d) procedure extracts from the bgp loc-rib the best path towards destination d (i.e. the route installed in the fib) and prepares the corresponding bgp update message.
from a conceptual point of view, a bgp router connected to n bgp peers, can be described as being composed of four parts as shown in the ﬁgure below.
in this ﬁgure, the router receives bgp messages on the left part of the ﬁgure, processes these messages and possibly sends bgp messages on the right part of the ﬁgure. a bgp router contains three important data structures :
• the adj-rib-in contains the bgp routes that have been received from each bgp peer. the routes in the adj-rib-in are ﬁltered by the import ﬁlter before being placed in the bgp-loc-rib. there is one import ﬁlter per bgp peer.
• the local routing information base (loc-rib) contains all the routes that are considered as acceptable by the router. the loc-rib may contain several routes, learned from different bgp peers, towards the same destination preﬁx.
• the forwarding information base (fib) is used by the dataplane to forward packets towards their destination. the fib contains, for each destination, the best route that has been selected by the bgp decision process. this decision process is an algorithm that selects, for each destination preﬁx, the best route according to the router’s ranking algorithm that is part of its policy.
• the adj-rib-out contains the bgp routes that have been advertised to each bgp peer. the adj-rib-out for a given peer is built by applying the peer‘s export ﬁlter on the routes that have been installed in the fib. there is one export ﬁlter per bgp peer. for this reason, the adj-rib-out of a peer may contain different routes than the adj-rib-out of another peer.
when a bgp session starts, the routers ﬁrst exchange open messages to negotiate the options that apply throughout the entire session. then, each router extracts from its fib the routes to be advertised to the peer. it is important to note that, for each known destination preﬁx, a bgp router can only advertise to a peer the route that it has itself installed inside its fib. the routes that are advertised to a peer must pass the peer’s export ﬁlter. the export ﬁlter is a set of rules that deﬁne which routes can be advertised over the corresponding session, possibly after having modiﬁed some of its attributes. one export ﬁlter is associated to each bgp session. for example, on a shared-cost peering, the export ﬁlter only selects the internal routes and the routes that have been learned from a customer. the pseudo-code below shows the initialisation of a bgp session.
# initialize and start bgp session # send bgp open message to remoteip on port 179 # follow bgp state machine # advertise local routes and routes learned from peers*/ for d in bgplocrib :
in the above pseudo-code, the build_bgp_update(d) procedure extracts from the bgp loc-rib the best path towards destination d (i.e. the route installed in the fib) and prepares the corresponding bgp update message.
simplest encapsulation scheme to understand is in ip in ip deﬁned in rfc 2003. this encapsulation scheme places an ip packet (called the inner packet), including its payload, as the payload of a larger ip packet (called the outer packet). it can be used by border routers to forward packets via routers that do not maintain a bgp routing table. for example, in the ﬁgure above, if router r2 needs to forward a packet towards destination 12.0.0.1, it can add at the front of this packet an ipv4 header whose source address is set to one of its ipv4 addresses and whose destination address is one of the ipv4 addresses of r4. the protocol ﬁeld of the ip header is set to 4 to indicate that it contains an ipv4 packet. the packet is forwarded by r5 to r4 based on the forwarding table that it built thanks to its intradomain routing table. upon reception of the packet, r4 removes the outer header and consults its (bgp) forwarding table to forward the packet towards r3.
besides the import and export ﬁlters, a key difference between bgp and the intradomain routing protocols is that each domain can deﬁne is own ranking algorithm to determine which route is chosen to forward packets when several routes have been learned towards the same preﬁx. this ranking depends on several bgp attributes that can be attached to a bgp route. the ﬁrst bgp attribute that is used to rank bgp routes is the local-preference (local-pref) attribute. this attribute is an unsigned integer that is attached to each bgp route received over an ebgp session by the associated import ﬁlter. when comparing routes towards the same destination preﬁx, a bgp router always prefers the routes with the highest local-pref. if the bgp router knows several routes with the same local-pref, it prefers among the routes having this local-pref the ones with the shortest as-path. the local-pref attribute is often used to prefer some routes over others. this attribute is always present inside bgp updates exchanged over ibgp sessions, but never present in the messages exchanged over ebgp sessions. a common utilisation of local-pref is to support backup links. consider the situation depicted in the ﬁgure below. as1 would always like to use the high bandwidth link to send and receive packets via as2 and only use the backup link upon failure of the primary one. as bgp routers always prefer the routes with the highest local-pref attribute, this policy can be implemented using the following import ﬁlter on r1
with this import ﬁlter, all the bgp routes learned from rb over the high bandwidth links are preferred over the routes learned over the backup link. if the primary link fails, the corresponding routes are removed from r1‘s rib and r1 uses the route learned from ra. r1 reuses the routes via rb as soon as they are advertised by rb once the r1-rb link comes back.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.9ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
in practice, to establish a bgp session between routers r1 and r2 in the ﬁgure above, the network administrator of as3 must ﬁrst conﬁgure on r1 the ip address of r2 on the r1-r2 link and the as number of r2. router r1 then regularly tries to establish the bgp session with r2. r2 only agrees to establish the bgp session with r1 once it has been conﬁgured with the ip address of r1 and its as number. for security reasons, a router never establishes a bgp session that has not been manually conﬁgured on the router. the bgp protocol rfc 4271 deﬁnes several types of messages that can be exchanged over a bgp session :
• open : this message is sent as soon as the tcp connection between the two routers has been established. it initialises the bgp session and allows the negotiation of some options. details about this message may be found in rfc 4271
• notification : this message is used to terminate a bgp session, usually because an error has been detected by the bgp peer. a router that sends or receives a notification message immediately shutdowns the corresponding bgp session.
• keepalive : this message is used to ensure a regular exchange of messages on the bgp session, even when no route changes. when a bgp router has not sent an update message during the last 30 seconds, it shall send a keepalive message to conﬁrm to the other peer that it is still up. if a peer does not receive any bgp message during a period of 90 seconds 32, the bgp session is considered to be down and all the routes learned over this session are withdrawn.
as explained earlier, bgp relies on incremental updates. this implies that when a bgp session starts, each router ﬁrst sends bgp update messages to advertise to the other peer all the exportable routes that it knows. once all these routes have been advertised, the bgp router only sends bgp update messages about a preﬁx if the route is new, one of its attributes has changed or the route became unreachable and must be withdrawn. the bgp update message allows bgp routers to efﬁciently exchange such information while minimising the number of bytes exchanged. each update message contains :
• a list of ip preﬁxes that are withdrawn • a list of ip preﬁxes that are (re-)advertised • the set of attributes (e.g. as-path) associated to the advertised preﬁxes
in the remainder of this chapter, and although all routing information is exchanged using bgp update messages, we assume for simplicity that a bgp message contains only information about one preﬁx and we use the words :
• withdraw message to indicate a bgp update message containing one route that is withdrawn • update message to indicate a bgp update containing a new or updated route towards one destination
32 90 seconds is the default delay recommended by rfc 4271. however, two bgp peers can negotiate a different timer during the establishment of their bgp session. using a too small interval to detect bgp session failures is not recommended. bfd [kw2009] can be used to replace bgp’s keepalive mechanism if fast detection of interdomain link failures is required.
simplest encapsulation scheme to understand is in ip in ip deﬁned in rfc 2003. this encapsulation scheme places an ip packet (called the inner packet), including its payload, as the payload of a larger ip packet (called the outer packet). it can be used by border routers to forward packets via routers that do not maintain a bgp routing table. for example, in the ﬁgure above, if router r2 needs to forward a packet towards destination 12.0.0.1, it can add at the front of this packet an ipv4 header whose source address is set to one of its ipv4 addresses and whose destination address is one of the ipv4 addresses of r4. the protocol ﬁeld of the ip header is set to 4 to indicate that it contains an ipv4 packet. the packet is forwarded by r5 to r4 based on the forwarding table that it built thanks to its intradomain routing table. upon reception of the packet, r4 removes the outer header and consults its (bgp) forwarding table to forward the packet towards r3.
besides the import and export ﬁlters, a key difference between bgp and the intradomain routing protocols is that each domain can deﬁne is own ranking algorithm to determine which route is chosen to forward packets when several routes have been learned towards the same preﬁx. this ranking depends on several bgp attributes that can be attached to a bgp route. the ﬁrst bgp attribute that is used to rank bgp routes is the local-preference (local-pref) attribute. this attribute is an unsigned integer that is attached to each bgp route received over an ebgp session by the associated import ﬁlter. when comparing routes towards the same destination preﬁx, a bgp router always prefers the routes with the highest local-pref. if the bgp router knows several routes with the same local-pref, it prefers among the routes having this local-pref the ones with the shortest as-path. the local-pref attribute is often used to prefer some routes over others. this attribute is always present inside bgp updates exchanged over ibgp sessions, but never present in the messages exchanged over ebgp sessions. a common utilisation of local-pref is to support backup links. consider the situation depicted in the ﬁgure below. as1 would always like to use the high bandwidth link to send and receive packets via as2 and only use the backup link upon failure of the primary one. as bgp routers always prefer the routes with the highest local-pref attribute, this policy can be implemented using the following import ﬁlter on r1
with this import ﬁlter, all the bgp routes learned from rb over the high bandwidth links are preferred over the routes learned over the backup link. if the primary link fails, the corresponding routes are removed from r1‘s rib and r1 uses the route learned from ra. r1 reuses the routes via rb as soon as they are advertised by rb once the r1-rb link comes back.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.9ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
note: the bogon ﬁlters another example of frequently used import ﬁlters are the ﬁlters that internet service providers use to ignore bogon routes. in the isp community, a bogon route is a route that should not be advertised on the global internet. typical examples include the private ipv4 preﬁxes deﬁned in rfc 1918, the loopback preﬁxes (127.0.0.1/8 and ::1/128) or the ip preﬁxes that have not yet been allocated by iana. a well managed bgp router should ensure that it never advertises bogons on the global internet. detailed information about these bogons may be found at http://www.team-cymru.org/services/bogons/
if this is an update if the import ﬁlter accepts the bgp message, the pseudo-code distinguishes two cases. message for preﬁx p, this can be a new route for this preﬁx or a modiﬁcation of the route’s attributes. the router ﬁrst retrieves from its rib the best route towards preﬁx p. then, the new route is inserted in the rib and the bgp decision process is run to ﬁnd whether the best route towards destination p changes. a bgp message only needs to be sent to the router’s peers if the best route has changed. for each peer, the router applies the export ﬁlter to verify whether the route can be advertised. if yes, the ﬁltered bgp message is sent. otherwise, a withdraw message is sent. when the router receives a withdraw message, it also veriﬁes whether the removal of the route from its rib caused its best route towards this preﬁx to change. it should be noted that, depending on the content of the rib and the export ﬁlters, a bgp router may need to send a withdraw message to a peer after having received an update message from another peer and conversely. let us now discuss in more detail the operation of bgp in an ipv4 network. for this, let us consider the simple network composed of three routers located in three different ases and shown in the ﬁgure below.
this network contains three routers : r1, r2 and r3. each router is attached to a local ipv4 subnet that it advertises using bgp. there are two bgp sessions, one between r1 and r2 and the second between r2 and r3. a /30 subnet is used on each interdomain link (195.100.0.0/30 on r1-r2 and 195.100.0.4/30 on r2-r3). the bgp sessions run above tcp connections established between the neighbouring routers (e.g. 195.100.0.1 - 195.100.0.2 for the r1-r2 session). let us assume that the r1-r2 bgp session is the ﬁrst to be established. a bgp update message sent on such a session contains three ﬁelds :
we use the notation u(preﬁx, nexthop, attributes) to represent such a bgp update message in this section. similarly, w(preﬁx) represents a bgp withdraw for the speciﬁed preﬁx. once the r1-r2 session has been established, r1 sends u(194.100.0.0/24,195.100.0.1,as10) to r2 and r2 sends u(194.100.2.0/23,195.100.0.2,as20). at this point, r1 can reach 194.100.2.0/23 via 195.100.0.2 and r2 can reach 194.100.0.0/24 via 195.100.0.1. once the r2-r3 has been established, r3 sends u(194.100.1.0/24,195.100.0.6,as30). r2 announces on the r2r3 session all the routes inside its rib. it thus sends to r3 : u(194.100.0.0/24,195.100.0.5,as20:as10) and u(194.100.2.0/23,195.100.0.5,as20). note that when r2 advertises the route that it learned from r1, it updates the bgp nexthop and adds its as number to the as-path. r2 also sends u(194.100.1.0/24,195.100.0.2,as20:as30) to r1 on the r1-r3 session. at this point, all bgp routes have been exchanged and all routers can reach 194.100.0.0/24, 194.100.2.0/23 and 194.100.1.0/24.
r1r2r3as10194.100.0.0/24195.100.0.1195.100.0.0/30195.100.0.2195.100.0.5195.100.0.6195.100.0.4/30as20as30194.100.1.0/24194.100.2.0/23as10as20as30bgpbgpbgpbgpsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
in practice, to establish a bgp session between routers r1 and r2 in the ﬁgure above, the network administrator of as3 must ﬁrst conﬁgure on r1 the ip address of r2 on the r1-r2 link and the as number of r2. router r1 then regularly tries to establish the bgp session with r2. r2 only agrees to establish the bgp session with r1 once it has been conﬁgured with the ip address of r1 and its as number. for security reasons, a router never establishes a bgp session that has not been manually conﬁgured on the router. the bgp protocol rfc 4271 deﬁnes several types of messages that can be exchanged over a bgp session :
• open : this message is sent as soon as the tcp connection between the two routers has been established. it initialises the bgp session and allows the negotiation of some options. details about this message may be found in rfc 4271
• notification : this message is used to terminate a bgp session, usually because an error has been detected by the bgp peer. a router that sends or receives a notification message immediately shutdowns the corresponding bgp session.
• keepalive : this message is used to ensure a regular exchange of messages on the bgp session, even when no route changes. when a bgp router has not sent an update message during the last 30 seconds, it shall send a keepalive message to conﬁrm to the other peer that it is still up. if a peer does not receive any bgp message during a period of 90 seconds 32, the bgp session is considered to be down and all the routes learned over this session are withdrawn.
as explained earlier, bgp relies on incremental updates. this implies that when a bgp session starts, each router ﬁrst sends bgp update messages to advertise to the other peer all the exportable routes that it knows. once all these routes have been advertised, the bgp router only sends bgp update messages about a preﬁx if the route is new, one of its attributes has changed or the route became unreachable and must be withdrawn. the bgp update message allows bgp routers to efﬁciently exchange such information while minimising the number of bytes exchanged. each update message contains :
• a list of ip preﬁxes that are withdrawn • a list of ip preﬁxes that are (re-)advertised • the set of attributes (e.g. as-path) associated to the advertised preﬁxes
in the remainder of this chapter, and although all routing information is exchanged using bgp update messages, we assume for simplicity that a bgp message contains only information about one preﬁx and we use the words :
• withdraw message to indicate a bgp update message containing one route that is withdrawn • update message to indicate a bgp update containing a new or updated route towards one destination
32 90 seconds is the default delay recommended by rfc 4271. however, two bgp peers can negotiate a different timer during the establishment of their bgp session. using a too small interval to detect bgp session failures is not recommended. bfd [kw2009] can be used to replace bgp’s keepalive mechanism if fast detection of interdomain link failures is required.
in practice, to establish a bgp session between routers r1 and r2 in the ﬁgure above, the network administrator of as3 must ﬁrst conﬁgure on r1 the ip address of r2 on the r1-r2 link and the as number of r2. router r1 then regularly tries to establish the bgp session with r2. r2 only agrees to establish the bgp session with r1 once it has been conﬁgured with the ip address of r1 and its as number. for security reasons, a router never establishes a bgp session that has not been manually conﬁgured on the router. the bgp protocol rfc 4271 deﬁnes several types of messages that can be exchanged over a bgp session :
• open : this message is sent as soon as the tcp connection between the two routers has been established. it initialises the bgp session and allows the negotiation of some options. details about this message may be found in rfc 4271
• notification : this message is used to terminate a bgp session, usually because an error has been detected by the bgp peer. a router that sends or receives a notification message immediately shutdowns the corresponding bgp session.
• keepalive : this message is used to ensure a regular exchange of messages on the bgp session, even when no route changes. when a bgp router has not sent an update message during the last 30 seconds, it shall send a keepalive message to conﬁrm to the other peer that it is still up. if a peer does not receive any bgp message during a period of 90 seconds 32, the bgp session is considered to be down and all the routes learned over this session are withdrawn.
as explained earlier, bgp relies on incremental updates. this implies that when a bgp session starts, each router ﬁrst sends bgp update messages to advertise to the other peer all the exportable routes that it knows. once all these routes have been advertised, the bgp router only sends bgp update messages about a preﬁx if the route is new, one of its attributes has changed or the route became unreachable and must be withdrawn. the bgp update message allows bgp routers to efﬁciently exchange such information while minimising the number of bytes exchanged. each update message contains :
• a list of ip preﬁxes that are withdrawn • a list of ip preﬁxes that are (re-)advertised • the set of attributes (e.g. as-path) associated to the advertised preﬁxes
in the remainder of this chapter, and although all routing information is exchanged using bgp update messages, we assume for simplicity that a bgp message contains only information about one preﬁx and we use the words :
• withdraw message to indicate a bgp update message containing one route that is withdrawn • update message to indicate a bgp update containing a new or updated route towards one destination
32 90 seconds is the default delay recommended by rfc 4271. however, two bgp peers can negotiate a different timer during the establishment of their bgp session. using a too small interval to detect bgp session failures is not recommended. bfd [kw2009] can be used to replace bgp’s keepalive mechanism if fast detection of interdomain link failures is required.
as path. thanks to these as-paths, bgp does not suffer from the count-to-inﬁnity problems that affect distance vector routing protocols. furthermore, the as-path can be used to implement some routing policies. another difference between bgp and the intradomain routing protocols is that a bgp router does not send the entire contents of its routing table to its neighbours regularly. given the size of the global internet, routers would be overloaded by the number of bgp messages that they would need to process. bgp uses incremental updates, i.e. it only announces the routes that have changed to its neighbours. the ﬁgure below shows a simple example of the bgp routes that are exchanged between domains. in this example, preﬁx 1.0.0.0/8 is announced by as1. as1 advertises a bgp route towards this preﬁx to as2. the as-path of this route indicates that as1 is the originator of the preﬁx. when as4 receives the bgp route from as1, it re-announces it to as2 and adds its as number to the as-path. as2 has learned two routes towards preﬁx 1.0.0.0/8. it compares the two routes and prefers the route learned from as4 based on its own ranking algorithm. as2 advertises to as5 a route towards 1.0.0.0/8 with its as-path set to as2:as4:as1. thanks to the as-path, as5 knows that if it sends a packet towards 1.0.0.0/8 the packet ﬁrst passes through as2, then through as4 before reaching its destination inside as1.
bgp routers exchange routes over bgp sessions. a bgp session is established between two routers belonging to two different domains that are directly connected. as explained earlier, the physical connection between the two routers can be implemented as a private peering link or over an internet exchange point. a bgp session between two adjacent routers runs above a tcp connection (the default bgp port is 179). in contrast with intradomain routing protocols that exchange ip packets or udp segments, bgp runs above tcp because tcp ensures a reliable delivery of the bgp messages sent by each router without forcing the routers to implement acknowledgements, checksums, etc. furthermore, the two routers consider the peering link to be up as long as the bgp session and the underlying tcp connection remain up 31. the two endpoints of a bgp session are called bgp peers.
31 the bgp sessions and the underlying tcp connection are typically established by the routers when they boot based on information found in their conﬁguration. the bgp sessions are rarely released, except if the corresponding peering link fails or one of the endpoints crashes or
from a conceptual point of view, a bgp router connected to n bgp peers, can be described as being composed of four parts as shown in the ﬁgure below.
in this ﬁgure, the router receives bgp messages on the left part of the ﬁgure, processes these messages and possibly sends bgp messages on the right part of the ﬁgure. a bgp router contains three important data structures :
• the adj-rib-in contains the bgp routes that have been received from each bgp peer. the routes in the adj-rib-in are ﬁltered by the import ﬁlter before being placed in the bgp-loc-rib. there is one import ﬁlter per bgp peer.
• the local routing information base (loc-rib) contains all the routes that are considered as acceptable by the router. the loc-rib may contain several routes, learned from different bgp peers, towards the same destination preﬁx.
• the forwarding information base (fib) is used by the dataplane to forward packets towards their destination. the fib contains, for each destination, the best route that has been selected by the bgp decision process. this decision process is an algorithm that selects, for each destination preﬁx, the best route according to the router’s ranking algorithm that is part of its policy.
• the adj-rib-out contains the bgp routes that have been advertised to each bgp peer. the adj-rib-out for a given peer is built by applying the peer‘s export ﬁlter on the routes that have been installed in the fib. there is one export ﬁlter per bgp peer. for this reason, the adj-rib-out of a peer may contain different routes than the adj-rib-out of another peer.
when a bgp session starts, the routers ﬁrst exchange open messages to negotiate the options that apply throughout the entire session. then, each router extracts from its fib the routes to be advertised to the peer. it is important to note that, for each known destination preﬁx, a bgp router can only advertise to a peer the route that it has itself installed inside its fib. the routes that are advertised to a peer must pass the peer’s export ﬁlter. the export ﬁlter is a set of rules that deﬁne which routes can be advertised over the corresponding session, possibly after having modiﬁed some of its attributes. one export ﬁlter is associated to each bgp session. for example, on a shared-cost peering, the export ﬁlter only selects the internal routes and the routes that have been learned from a customer. the pseudo-code below shows the initialisation of a bgp session.
# initialize and start bgp session # send bgp open message to remoteip on port 179 # follow bgp state machine # advertise local routes and routes learned from peers*/ for d in bgplocrib :
in the above pseudo-code, the build_bgp_update(d) procedure extracts from the bgp loc-rib the best path towards destination d (i.e. the route installed in the fib) and prepares the corresponding bgp update message.
in practice, to establish a bgp session between routers r1 and r2 in the ﬁgure above, the network administrator of as3 must ﬁrst conﬁgure on r1 the ip address of r2 on the r1-r2 link and the as number of r2. router r1 then regularly tries to establish the bgp session with r2. r2 only agrees to establish the bgp session with r1 once it has been conﬁgured with the ip address of r1 and its as number. for security reasons, a router never establishes a bgp session that has not been manually conﬁgured on the router. the bgp protocol rfc 4271 deﬁnes several types of messages that can be exchanged over a bgp session :
• open : this message is sent as soon as the tcp connection between the two routers has been established. it initialises the bgp session and allows the negotiation of some options. details about this message may be found in rfc 4271
• notification : this message is used to terminate a bgp session, usually because an error has been detected by the bgp peer. a router that sends or receives a notification message immediately shutdowns the corresponding bgp session.
• keepalive : this message is used to ensure a regular exchange of messages on the bgp session, even when no route changes. when a bgp router has not sent an update message during the last 30 seconds, it shall send a keepalive message to conﬁrm to the other peer that it is still up. if a peer does not receive any bgp message during a period of 90 seconds 32, the bgp session is considered to be down and all the routes learned over this session are withdrawn.
as explained earlier, bgp relies on incremental updates. this implies that when a bgp session starts, each router ﬁrst sends bgp update messages to advertise to the other peer all the exportable routes that it knows. once all these routes have been advertised, the bgp router only sends bgp update messages about a preﬁx if the route is new, one of its attributes has changed or the route became unreachable and must be withdrawn. the bgp update message allows bgp routers to efﬁciently exchange such information while minimising the number of bytes exchanged. each update message contains :
• a list of ip preﬁxes that are withdrawn • a list of ip preﬁxes that are (re-)advertised • the set of attributes (e.g. as-path) associated to the advertised preﬁxes
in the remainder of this chapter, and although all routing information is exchanged using bgp update messages, we assume for simplicity that a bgp message contains only information about one preﬁx and we use the words :
• withdraw message to indicate a bgp update message containing one route that is withdrawn • update message to indicate a bgp update containing a new or updated route towards one destination
32 90 seconds is the default delay recommended by rfc 4271. however, two bgp peers can negotiate a different timer during the establishment of their bgp session. using a too small interval to detect bgp session failures is not recommended. bfd [kw2009] can be used to replace bgp’s keepalive mechanism if fast detection of interdomain link failures is required.
important for short frames. let us consider two hosts, a and b, that are sending a small frame to host c as illustrated in the ﬁgure below. if the frames sent by a and b are very short, the situation illustrated below may occur. hosts a and b send their frame and stop transmitting (point (1)). when the two short frames arrive at the location of host c, they collide and host c cannot decode them (point (2)). the two frames are absorbed by the ends of the wire. neither host a nor host b have detected the collision. they both consider their frame to have been received correctly by its destination.
to solve this problem, networks using csma/cd require hosts to transmit for at least 2 × τ seconds. since the network transmission speed is ﬁxed for a given network technology, this implies that a technology that uses csma/cd enforces a minimum frame size. in the most popular csma/cd technology, ethernet, 2 × τ is called the slot time 1. the last innovation introduced by csma/cd is the computation of the retransmission timeout. as for aloha, this timeout cannot be ﬁxed, otherwise hosts could become synchronised and always retransmit at the same time. setting such a timeout is always a compromise between the network access delay and the amount of collisions. a short timeout would lead to a low network access delay but with a higher risk of collisions. on the other hand, a long timeout would cause a long network access delay but a lower risk of collisions. the binary exponential back-off algorithm was introduced in csma/cd networks to solve this problem. to understand binary exponential back-off, let us consider a collision caused by exactly two hosts. once it has detected the collision, a host can either retransmit its frame immediately or defer its transmission for some time. if each colliding host ﬂips a coin to decide whether to retransmit immediately or to defer its retransmission, four cases are possible :
1. both hosts retransmit immediately and a new collision occurs 2. the ﬁrst host retransmits immediately and the second defers its retransmission 3. the second host retransmits immediately and the ﬁrst defers its retransmission 4. both hosts defer their retransmission and a new collision occurs
in the second and third cases, both hosts have ﬂipped different coins. the delay chosen by the host that defers its retransmission should be long enough to ensure that its retransmission will not collide with the immediate retransmission of the other host. however the delay should not be longer than the time necessary to avoid the collision, because if both hosts decide to defer their transmission, the network will be idle during this delay. the
1 this name should not be confused with the duration of a transmission slot in slotted aloha. in csma/cd networks, the slot time is the time during which a collision can occur at the beginning of the transmission of a frame. in slotted aloha, the duration of a slot is the transmission time of an entire ﬁxed-size frame.
• the physical layer may deliver more bits to the receiver than the bits sent by the sender • the physical layer may deliver fewer bits to the receiver than the bits sent by the sender
the datalink layer must allow endsystems to exchange frames containing packets despite all of these limitations. on point-to-point links and local area networks, the ﬁrst problem to be solved is how to encode a frame as a sequence of bits, so that the receiver can easily recover the received frame despite the limitations of the physical layer. if the physical layer were perfect, the problem would be very simple. the datalink layer would simply need to deﬁne how to encode each frame as a sequence of consecutive bits. the receiver would then easily be able to extract the frames from the received bits. unfortunately, the imperfections of the physical layer make this framing problem slightly more complex. several solutions have been proposed and are used in practice in different datalink layer technologies.
this is the framing problem. it can be deﬁned as : “how does a sender encode frames so that the receiver can efﬁciently extract them from the stream of bits that it receives from the physical layer”. a ﬁrst solution to solve the framing problem is to require the physical layer to remain idle for some time after the transmission of each frame. these idle periods can be detected by the receiver and serve as a marker to delineate frame boundaries. unfortunately, this solution is not sufﬁcient for two reasons. first, some physical layers cannot remain idle and always need to transmit bits. second, inserting an idle period between frames decreases the maximum bandwidth that can be achieved by the datalink layer. some physical layers provide an alternative to this idle period. all physical layers are able to send and receive physical symbols that represent values 0 and 1. however, for various reasons that are outside the scope of this chapter, several physical layers are able to exchange other physical symbols as well. for example, the manchester encoding used in several physical layers can send four different symbols. the manchester encoding is a differential encoding scheme in which time is divided into ﬁxed-length periods. each period is divided in two halves and two different voltage levels can be applied. to send a symbol, the sender must set one of these two voltage levels during each half period. to send a 1 (resp. 0), the sender must set a high (resp. low) voltage during the ﬁrst half of the period and a low (resp. high) voltage during the second half. this encoding ensures that there will be a transition at the middle of each period and allows the receiver to synchronise its clock to the sender’s clock. apart from the encodings for 0 and 1, the manchester encoding also supports two additional symbols : invh and invb where the same voltage level is used for the two half periods. by deﬁnition, these two symbols cannot appear inside a frame which is only composed of 0 and 1. some technologies use these special symbols as markers for the beginning or end of frames.
unfortunately, multi-symbol encodings cannot be used by all physical layers and a generic solution which can be used with any physical layer that is able to transmit and receive only 0 and 1 is required. this generic solution is called stufﬁng and two variants exist : bit stufﬁng and character stufﬁng. to enable a receiver to easily delineate the frame boundaries, these two techniques reserve special bit strings as frame boundary markers and encode the frames so that these special bit strings do not appear inside the frames. bit stufﬁng reserves the 01111110 bit string as the frame boundary marker and ensures that there will never be six consecutive 1 symbols transmitted by the physical layer inside a frame. with bit stufﬁng, a frame is sent as follows. first, the sender transmits the marker, i.e. 01111110. then, it sends all the bits of the frame and inserts
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
microseconds slot time. if the delay is longer, collisions between short frames may not be correctly detected. this constraint limits the geographical spread of 10baset networks containing hubs.
in the late 1980s, 10 mbps became too slow for some applications and network manufacturers developed several lan technologies that offered higher bandwidth, such as the 100 mbps fddi lan that used optical ﬁbers. as the development of 10base5, 10base2 and 10baset had shown that ethernet could be adapted to different physical layers, several manufacturers started to work on 100 mbps ethernet and convinced ieee to standardise this new technology that was initially called fast ethernet. fast ethernet was designed under two constraints. first, fast ethernet had to support twisted pairs. although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. second, fast ethernet had to be perfectly compatible with the existing 10 mbps ethernets to allow fast ethernet technology to be used initially as a backbone technology to interconnect 10 mbps ethernet networks. this forced fast ethernet to use exactly the same frame format as 10 mbps ethernet. this implied that the minimum fast ethernet frame size remained at 512 bits. to preserve csma/cd with this minimum frame size and 100 mbps instead of 10 mbps, the duration of the slot time was decreased to 5.12 microseconds. the evolution of ethernet did not stop. in 1998, the ieee published a ﬁrst standard to provide gigabit ethernet over optical ﬁbers. several other types of physical layers were added afterwards. the 10 gigabit ethernet standard appeared in 2002. work is ongoing to develop standards for 40 gigabit and 100 gigabit ethernet and some are thinking about terabit ethernet. the table below lists the main ethernet standards. a more detailed list may be found at http://en.wikipedia.org/wiki/ethernet_physical_layer
comments thick coaxial cable, 500m thin coaxial cable, 185m two pairs of category 3+ utp 10 mb/s over optical ﬁber category 5 utp or stp, 100 m maximum two multimode optical ﬁber, 2 km maximum
standard 10base5 10base2 10baset 10base-f 100base-tx 100base-fx 1000base-cx two pairs shielded twisted pair, 25m maximum 1000base-sx two multimode or single mode optical ﬁbers with lasers 10 gbps 40-100 gbps
increasing the physical layer bandwidth as in fast ethernet was only one of the solutions to improve the performance of ethernet lans. a second solution was to replace the hubs with more intelligent devices. as ethernet hubs operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
when developing its family of standards, the ieee 802.11 working group took a similar approach as the ieee 802.3 working group that developed various types of physical layers for ethernet networks. 802.11 networks use the csma/ca medium access control technique described earlier and they all assume the same architecture and use the same frame format. the architecture of wifi networks is slightly different from the local area networks that we have discussed until now. there are, in practice, two main types of wifi networks : independent or adhoc networks and infrastructure networks 11. an independent or adhoc network is composed of a set of devices that communicate with each other. these devices play the same role and the adhoc network is usually not connected to the global internet. adhoc networks are used when for example a few laptops need to exchange information or to connect a computer with a wifi printer.
most wifi networks are infrastructure networks. an infrastructure network contains one or more access points that are attached to a ﬁxed local area network (usually an ethernet network) that is connected to other networks such as the internet. the ﬁgure below shows such a network with two access points and four wifi devices. each wifi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the lan. an 802.11 access point is a relay that operates in the datalink layer like switches. the ﬁgure below represents the layers of the reference model that are involved when a wifi host communicates with a host attached to an ethernet network through an access point. 802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in ethernet lans. we review the key parts of the 802.11 frames. additional details may be found in [802.11] and [gast2002] . an 802.11 frame contains a ﬁxed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits crc. although the payload can contain up to 2324 bytes,
the pseudo-code below shows the operation of an alohanet terminal. we use this python syntax for all medium access control algorithms described in this chapter. the algorithm is applied to each new frame that needs to be transmitted. it attempts to transmit a frame at most max times (while loop). each transmission attempt is performed as follows: first, the frame is sent. each frame is protected by a timeout. then, the terminal waits for either a valid acknowledgement frame or the expiration of its timeout. if the terminal receives an acknowledgement, the frame has been delivered correctly and the algorithm terminates. otherwise, the terminal waits for a random time and attempts to retransmit the frame.
[abramson1970] analysed the performance of alohanet under particular assumptions and found that alohanet worked well when the channel was lightly loaded. in this case, the frames are rarely retransmitted and the channel trafﬁc, i.e. the total number of (correct and retransmitted) frames transmitted per unit of time is close to the channel utilization, i.e. the number of correctly transmitted frames per unit of time. unfortunately, the analysis 2×e = 0.186 times the channel bandwidth. at also reveals that the channel utilization reaches its maximum at higher utilization, alohanet becomes unstable and the network collapses due to collided retransmissions.
note: amateur packet radio packet radio technologies have evolved in various directions since the ﬁrst experiments performed at the university of hawaii. the amateur packet radio service developed by amateur radio operators is one of the descendants alohanet. many amateur radio operators are very interested in new technologies and they often spend countless hours developing new antennas or transceivers. when the ﬁrst personal computers appeared, several amateur radio operators designed radio modems and their own datalink layer protocols [kpd1985] [bnt1997]. this network grew and it was possible to connect to servers in several european countries by only using packet radio relays. some amateur radio operators also developed tcp/ip protocol stacks that were used over the packet radio service. some parts of the amateur packet radio network are connected to the global internet and use the 44.0.0.0/8 preﬁx.
many improvements to alohanet have been proposed since the publication of [abramson1970], and this technique, or some of its variants, are still found in wireless networks today. the slotted technique proposed in [roberts1975] is important because it shows that a simple modiﬁcation can signiﬁcantly improve channel utilization. instead of allowing all terminals to transmit at any time, [roberts1975] proposed to divide time into slots and allow terminals to transmit only at the beginning of each slot. each slot corresponds to the time required to transmit one ﬁxed size frame. in practice, these slots can be imposed by a single clock that is received by all terminals. in alohanet, it could have been located on the central mainframe. the analysis in [roberts1975] reveals that this simple modiﬁcation improves the channel utilization by a factor of two.
aloha and slotted aloha can easily be implemented, but unfortunately, they can only be used in networks that are very lightly loaded. designing a network for a very low utilisation is possible, but it clearly increases the cost of the network. to overcome the problems of aloha, many medium access control mechanisms have been proposed which improve channel utilization. carrier sense multiple access (csma) is a signiﬁcant improvement compared to aloha. csma requires all nodes to listen to the transmission channel to verify that it is free before transmitting a frame [kt1975]. when a node senses the channel to be busy, it defers its transmission until the channel becomes free again. the pseudo-code below provides a more detailed description of the operation of csma.
slot time is the optimal delay since it is the shortest delay that ensures that the ﬁrst host will be able to retransmit its frame completely without any collision. if two hosts are competing, the algorithm above will avoid a second collision 50% of the time. however, if the network is heavily loaded, several hosts may be competing at the same time. in this case, the hosts should be able to automatically adapt their retransmission delay. the binary exponential back-off performs this adaptation based on the number of collisions that have affected a frame. after the ﬁrst collision, the host ﬂips a coin and waits 0 or 1 slot time. after the second collision, it generates a random number and waits 0, 1, 2 or 3 slot times, etc. the duration of the waiting time is doubled after each collision. the complete pseudo-code for the csma/cd algorithm is shown in the ﬁgure below.
the inter-frame delay used in this pseudo-code is a short delay corresponding to the time required by a network adapter to switch from transmit to receive mode. it is also used to prevent a host from sending a continuous stream of frames without leaving any transmission opportunities for other hosts on the network. this contributes to the fairness of csma/cd. despite this delay, there are still conditions where csma/cd is not completely fair [ry1994]. consider for example a network with two hosts : a server sending long frames and a client sending acknowledgments. measurements reported in [ry1994] have shown that there are situations where the client could suffer from repeated collisions that lead it to wait for long periods of time due to the exponential back-off algorithm.
the carrier sense multiple access with collision avoidance (csma/ca) medium access control algorithm was designed for the popular wifi wireless network technology [802.11]. csma/ca also senses the transmission channel before transmitting a frame. furthermore, csma/ca tries to avoid collisions by carefully tuning the timers used by csma/ca devices. csma/ca uses acknowledgements like csma. each frame contains a sequence number and a crc. the crc is used to detect transmission errors while the sequence number is used to avoid frame duplication. when a device receives a correct frame, it returns a special acknowledgement frame to the sender. csma/ca introduces a small delay, named short inter frame spacing (sifs), between the reception of a frame and the transmission of the acknowledgement frame. this delay corresponds to the time that is required to switch the radio of a device between the reception and transmission modes. compared to csma, csma/ca deﬁnes more precisely when a device is allowed to send a frame. first, csma/ca deﬁnes two delays : difs and eifs. to send a frame, a device must ﬁrst wait until the channel has been idle for at least the distributed coordination function inter frame space (difs) if the previous frame was received correctly. however, if the previously received frame was corrupted, this indicates that there are collisions and the device must sense the channel idle for at least the extended inter frame space (eifs), with sif s < dif s < eif s. the exact values for sifs, difs and eifs depend on the underlying physical layer [802.11].
the above pseudo-code is often called persistent csma [kt1975] as the terminal will continuously listen to the channel and transmit its frame as soon as the channel becomes free. another important variant of csma is the non-persistent csma [kt1975]. the main difference between persistent and non-persistent csma described in the pseudo-code below is that a non-persistent csma node does not continuously listen to the channel to determine when it becomes free. when a non-persistent csma terminal senses the transmission channel to be busy, it waits for a random time before sensing the channel again. this improves channel utilization compared to persistent csma. with persistent csma, when two terminals sense the channel to be busy, they will both transmit (and thus cause a collision) as soon as the channel becomes free. with non-persistent csma, this synchronisation does not occur, as the terminals wait a random time after having sensed the transmission channel. however, the higher channel utilization achieved by non-persistent csma comes at the expense of a slightly higher waiting time in the terminals when the network is lightly loaded.
[kt1975] analyzes in detail the performance of several csma variants. under some assumptions about the transmission channel and the trafﬁc, the analysis compares aloha, slotted aloha, persistent and non-persistent csma. under these assumptions, aloha achieves a channel utilization of only 18.4% of the channel capacity. slotted aloha is able to use 36.6% of this capacity. persistent csma improves the utilization by reaching 52.9% of the capacity while non-persistent csma achieves 81.5% of the channel capacity.
csma improves channel utilization compared to aloha. however, the performance can still be improved, especially in wired networks. consider the situation of two terminals that are connected to the same cable. this cable could, for example, be a coaxial cable as in the early days of ethernet [metcalfe1976]. it could also be built with twisted pairs. before extending csma, it is useful to understand more intuitively, how frames are transmitted in such a network and how collisions can occur. the ﬁgure below illustrates the physical transmission of a frame on such a cable. to transmit its frame, host a must send an electrical signal on the shared medium. the ﬁrst step is thus to begin the transmission of the electrical signal. this is point (1) in the ﬁgure below. this electrical signal will travel along the cable. although electrical signals travel fast, we know that information cannot travel faster than the speed of light (i.e. 300.000 kilometers/second). on a coaxial cable, an electrical signal is slightly slower
an additional bit set to 0 after each sequence of ﬁve consecutive 1 bits. this ensures that the sent frame never contains a sequence of six consecutive bits set to 1. as a consequence, the marker pattern cannot appear inside the frame sent. the marker is also sent to mark the end of the frame. the receiver performs the opposite to decode a received frame. it ﬁrst detects the beginning of the frame thanks to the 01111110 marker. then, it processes the received bits and counts the number of consecutive bits set to 1. if a 0 follows ﬁve consecutive bits set to 1, this bit is removed since it was inserted by the sender. if a 1 follows ﬁve consecutive bits sets to 1, it indicates a marker if it is followed by a bit set to 0. the table below illustrates the application of bit stufﬁng to some frames.
for example, consider the transmission of 0110111111111111111110010. the sender will ﬁrst send the 01111110 marker followed by 011011111. after these ﬁve consecutive bits set to 1, it inserts a bit set to 0 followed by 11111. a new 0 is inserted, followed by 11111. a new 0 is inserted followed by the end of the frame 110010 and the 01111110 marker. bit stufﬁng increases the number of bits required to transmit each frame. the worst case for bit stufﬁng is of course a long sequence of bits set to 1 inside the frame. if transmission errors occur, stuffed bits or markers can be in error. in these cases, the frame affected by the error and possibly the next frame will not be correctly decoded by the receiver, but it will be able to resynchronise itself at the next valid marker. bit stufﬁng can be easily implemented in hardware. however, implementing it in software is difﬁcult given the higher overhead of bit manipulations in software. software implementations prefer to process characters than bits, software-based datalink layers usually use character stufﬁng. this technique operates on frames that contain an integer number of 8-bit characters. some characters are used as markers to delineate the frame boundaries. many character stufﬁng techniques use the dle, stx and etx characters of the ascii character set. dle stx (resp. dle etx) is used to mark the beginning (end) of a frame. when transmitting a frame, the sender adds a dle character after each transmitted dle character. this ensures that none of the markers can appear inside the transmitted frame. the receiver detects the frame boundaries and removes the second dle when it receives two consecutive dle characters. for example, to transmit frame 1 2 3 dle stx 4, a sender will ﬁrst send dle stx as a marker, followed by 1 2 3 dle. then, the sender transmits an additional dle character followed by stx 4 and the dle etx marker. original frame 1 2 3 4 1 2 3 dle stx 4 dle stx dle etx dle stx dle dle stx dle dle etx dle etx
character stufﬁng , like bit stufﬁng, increases the length of the transmitted frames. for character stufﬁng, the worst frame is a frame containing many dle characters. when transmission errors occur, the receiver may incorrectly decode one or two frames (e.g. if the errors occur in the markers). however, it will be able to resynchronise itself with the next correctly received markers.
besides framing, datalink layers also include mechanisms to detect and sometimes even recover from transmission error. to allow a receiver to detect transmission errors, a sender must add some redundant information as an error detection code to the frame sent. this error detection code is computed by the sender on the frame that it transmits. when the receiver receives a frame with an error detection code, it recomputes it and veriﬁes whether the received error detection code matches the computer error detection code. if they match, the frame is considered to be valid. many error detection schemes exist and entire books have been written on the subject. a detailed discussion of these techniques is outside the scope of this book, and we will only discuss some examples to illustrate the key principles. to understand error detection codes, let us consider two devices that exchange bit strings containing n bits. to allow the receiver to detect a transmission error, the sender converts each string of n bits into a string of n+r bits. usually, the r redundant bits are added at the beginning or the end of the transmitted bit string, but some techniques interleave redundant bits with the original bits. an error detection code can be deﬁned as a function that computes the r redundant bits corresponding to each string of n bits. the simplest error detection code is the
• the privileged port numbers (1 < port < 1024 ) • the ephemeral port numbers ( ofﬁcially 8 49152 <= port <= 65535 ) • the registered port numbers (ofﬁcially 1024 <= port < 49152)
in most unix variants, only processes having system administrator privileges can be bound to port numbers smaller than 1024. well-known servers such as dns, ntp or rpc use privileged port numbers. when a client needs to use udp, it usually does not require a speciﬁc port number. in this case, the udp implementation will allocate the ﬁrst available port number in the ephemeral range. the range of registered port numbers should be used by servers. in theory, developers of network servers should register their port number ofﬁcially through iana, but few developers do this.
• a pseudo header containing the source ip address, the destination ip address and a 32 bits bit ﬁeld containing the most signiﬁcant byte set to 0, the second set to 17 and the length of the udp segment in the lower two bytes
this pseudo-header allows the receiver to detect errors affecting the ip source or destination addresses placed in the ip layer below. this is a violation of the layering principle that dates from the time when udp and ip were elements of a single protocol. it should be noted that if the checksum algorithm computes value ‘0x0000’, then value ‘0xffff’ is transmitted. a udp segment whose checksum is set to ‘0x0000’ is a segment for which the transmitter did not compute a checksum upon transmission. some nfs servers chose to disable udp checksums for performance reasons, but this caused problems that were difﬁcult to diagnose. in practice, there are rarely good reasons to disable udp checksums. a detailed discussion of the implementation of the internet checksum may be found in rfc 1071
several types of applications rely on udp. as a rule of thumb, udp is used for applications where delay must be minimised or losses can be recovered by the application itself. a ﬁrst class of the udp-based applications are applications where the client sends a short request and expects a quick and short answer. the dns is an example of
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
subnet 130.100.0.0/16 130.101.0.0/16 university of akron, usa 130.102.0.0/16 130.103.0.0/16 130.104.0.0/16 universite catholique de louvain, belgium 130.105.0.0/16 open software foundation, usa
however, the internet was a victim of its own success and in the late 1980s, many organisations were requesting blocks of ipv4 addresses and started connecting to the internet. most of these organisations requested class b address blocks, as class a address blocks were too large and in limited supply while class c address blocks were considered to be too small. unfortunately, there were only 16,384 different class b address blocks and this address space was being consumed quickly. as a consequence, the routing tables maintained by the routers were growing quickly and some routers had difﬁculties maintaining all these routes in their limited memory 5.
faced with these two problems, the internet engineering task force decided to develop the classless interdomain routing (cidr) architecture rfc 1518. this architecture aims at allowing ip routing to scale better than the class-based architecture. cidr contains three important modiﬁcations compared to rfc 791.
1. ip address classes are deprecated. all ip equipment must use and support variable-length subnets. 2. ip address blocks are no longer allocated on a ﬁrst-come-ﬁrst-served basis. instead, cidr introduces a
the last two modiﬁcations were introduced to improve the scalability of the ip routing system. the main drawback of the ﬁrst-come-ﬁrst-served address block allocation scheme was that neighbouring address blocks were allocated to very different organisations and conversely, very different address blocks were allocated to similar organisations. with cidr, address blocks are allocated by regional ip registries (rir) in an aggregatable manner. a rir is responsible for a large block of addresses and a region. for example, ripe is the rir that is responsible for europe. a rir allocates smaller address blocks from its large block to internet service providers rfc 2050. internet service providers then allocate smaller address blocks to their customers. when an organisation requests an address block, it must prove that it already has or expects to have in the near future, a number of hosts or customers that is equivalent to the size of the requested address block. the main advantage of this hierarchical address block allocation scheme is that it allows the routers to maintain fewer routes. for example, consider the address blocks that were allocated to some of the belgian universities as shown in the table below.
another problem faced by wireless networks is often called the hidden station problem. in a wireless network, radio signals are not always propagated same way in all directions. for example, two devices separated by a wall may not be able to receive each other’s signal while they could both be receiving the signal produced by a third host. this is illustrated in the ﬁgure below, but it can happen in other environments. for example, two devices that are on different sides of a hill may not be able to receive each other’s signal while they are both able to receive the signal sent by a station at the top of the hill. furthermore, the radio propagation conditions may change with time. for example, a truck may temporarily block the communication between two nearby devices.
to avoid collisions in these situations, csma/ca allows devices to reserve the transmission channel for some time. this is done by using two control frames : request to send (rts) and clear to send (cts). both are very short frames to minimize the risk of collisions. to reserve the transmission channel, a device sends a rts frame to the intended recipient of the data frame. the rts frame contains the duration of the requested reservation. the recipient replies, after a sifs delay, with a cts frame which also contains the duration of the reservation. as the duration of the reservation has been sent in both rts and cts, all hosts that could collide with either the sender or the reception of the data frame are informed of the reservation. they can compute the total duration of the transmission and defer their access to the transmission channel until then. this is illustrated in the ﬁgure below where host a reserves the transmission channel to send a data frame to host b. host c notices the reservation and defers its transmission.
the utilization of the reservations with csma/ca is an optimisation that is useful when collisions are frequent. if there are few collisions, the time required to transmit the rts and cts frames can become signiﬁcant and in particular when short frames are exchanged. some devices only turn on rts/cts after transmission errors.
hot potato routing allows as1 to minimise the cost of forwarding packets towards as2. however, there are situations where this is not desirable. for example, assume that as1 and as2 are domains with routers on both the east and the west coast of the us. in these two domains, the high metric associated to links r6-r8 and r0-r2 correspond to the cost of forwarding a packet across the usa. if as2 is a customer that pays as1, it would prefer to receive the packets destined to 1.0.0.0/8 via the r2-r6 link instead of the r7-r3 link. this is the objective of cold potato routing. cold potato routing is implemented using the multi-exit discriminator (med) attribute. this attribute is an optional bgp attribute that may be set 37 by border routers when advertising a bgp route over an ebgp session. the med attribute is usually used to indicate over an ebgp session the cost to reach the bgp nexthop for the advertised route. the med attribute is set by the router that advertises a route over an ebgp session. in the example above, router r2 sends u(1.0.0.0/8,r2,as2,med=1) while r3 sends u(1.0.0.0/8,r3,as2,med=98). assume that the bgp session r7-3 is the ﬁrst to be established. r7 sends u(1.0.0.0/8,r3,as2,med=98) to both r8 and r6. at this point, all routers inside as1 send the packets towards 1.0.0.0/8 via r7-r3. then, the r6r2 bgp session is established and router r6 receives u(1.0.0.0/8,r2,as2,med=1). router r6 runs its decision process for destination 1.0.0.0/8 and selects the route via r2 as its chosen route to reach this preﬁx since this is the only route that it knows. r6 sends u(1.0.0.0/8,r2,as2,med=1) to routers r8 and r7. they both run their decision process and prefer the route advertised by r6, as it contains the smallest med. now, all routers inside as1 forward the packets to 1.0.0.0/8 via link r6-r2 as expected by as2. as router r7 no longer uses the bgp route learned via r3, it must stop advertising it over ibgp sessions and sends w(1.0.0.0/8) over its ibgp sessions with r6 and r8. however, router r7 still keeps the route learned from r3 inside its adj-rib-in. if the r6-r2 link fails, r6 sends w(1.0.0.0/8) over its ibgp sessions and router r7 responds by sending u(1.0.0.0/8,r3,as2,med=98) over its ibgp sessions. in practice, the ﬁfth step of the bgp decision process is slightly more complex, as the routes towards a given preﬁx can be learned from different ases. for example, assume that in ﬁgure hot and cold potato routing, 1.0.0.0/8 is also advertised by as3 (not shown in the ﬁgure) that has peering links with routers r6 and r8. if as3 advertises a route whose med attribute is set to 2 and another with a med set to 3, how should as1‘s router compare the four bgp routes towards 1.0.0.0/8 ? is a med value of 1 from as2 better than a med value of 2 from as3 ? the ﬁfth step of the bgp decision process solves this problem by only comparing the med attribute of the routes learned from the same neighbour as. additional details about the med attribute may be found in rfc 4451. it should be noted that using the med attribute may cause some problems in bgp networks as explained in [gw2002]. in practice, the med attribute is not used on ebgp sessions unless the two domains agree to enable it. the last step of the bgp decision allows the selection of a single route when a bgp router has received several routes that are considered as equal by the ﬁrst six steps of the decision process. this can happen for example in a dual-homed stub attached to two different providers. as shown in the ﬁgure below, router r1 receives two equally good bgp routes towards 1.0.0.0/8. to break the ties, each router is identiﬁed by a unique router-id which in practice is one of the ip addresses assigned to the router. on some routers, the lowest router id step in the bgp decision process is replaced by the selection of the oldest route rfc 5004. preferring the oldest route when breaking ties is used to prefer stable paths over unstable paths. however, a drawback of this approach is that the selection of the bgp routes depends on the arrival times of the corresponding messages. this makes the bgp selection process non-deterministic and can lead to problems that are difﬁcult to debug.
these four basic physical organisations of local area networks are shown graphically in the ﬁgure below. we will ﬁrst focus on one physical organisation at a time.
the common problem among all of these network organisations is how to efﬁciently share the access to the local area network. if two devices send a frame at the same time, the two electrical, optical or radio signals that correspond to these frames will appear at the same time on the transmission medium and a receiver will not be able to decode either frame. such simultaneous transmissions are called collisions. a collision may involve frames transmitted by two or more devices attached to the local area network. collisions are the main cause of errors in wired local area networks. all local area network technologies rely on a medium access control algorithm to regulate the transmissions to either minimise or avoid collisions. there are two broad families of medium access control algorithms :
1. deterministic or pessimistic mac algorithms. these algorithms assume that collisions are a very severe problem and that they must be completely avoided. these algorithms ensure that at any time, at most one device is allowed to send a frame on the lan. this is usually achieved by using a distributed protocol which elects one device that is allowed to transmit at each time. a deterministic mac algorithm ensures that no collision will happen, but there is some overhead in regulating the transmission of all the devices attached to the lan.
2. stochastic or optimistic mac algorithms. these algorithms assume that collisions are part of the normal operation of a local area network. they aim to minimise the number of collisions, but they do not try to avoid all collisions. stochastic algorithms are usually easier to implement than deterministic ones.
we ﬁrst discuss a simple deterministic mac algorithm and then we describe several important optimistic algorithms, before coming back to a distributed and deterministic mac algorithm.
a ﬁrst solution to share the available resources among all the devices attached to one local area network is to deﬁne, a priori, the distribution of the transmission resources among the different devices. if n devices need to share the transmission capacities of a lan operating at b mbps, each device could be allocated a bandwidth of b n mbps. limited resources need to be shared in other environments than local area networks. since the ﬁrst radio transmissions by marconi more than one century ago, many applications that exchange information through radio signals have been developed. each radio signal is an electromagnetic wave whose power is centered around a given frequency. the radio spectrum corresponds to frequencies ranging between roughly 3 khz and 300 ghz. frequency allocation plans negotiated among governments reserve most frequency ranges for speciﬁc applications such as broadcast radio, broadcast television, mobile communications, aeronautical radio navigation, amateur radio, satellite, etc. each frequency range is then subdivided into channels and each channel can be reserved for a given application, e.g. a radio broadcaster in a given region. frequency division multiplexing (fdm) is a static allocation scheme in which a frequency is allocated to each device attached to the shared medium. as each device uses a different transmission frequency, collisions cannot
than the speed of light and 200.000 kilometers per second is a reasonable estimation. this implies that if the cable has a length of one kilometer, the electrical signal will need 5 microseconds to travel from one end of the cable to the other. the ends of coaxial cables are equipped with termination points that ensure that the electrical signal is not reﬂected back to its source. this is illustrated at point (3) in the ﬁgure, where the electrical signal has reached the left endpoint and host b. at this point, b starts to receive the frame being transmitted by a. notice that there is a delay between the transmission of a bit on host a and its reception by host b. if there were other hosts attached to the cable, they would receive the ﬁrst bit of the frame at slightly different times. as we will see later, this timing difference is a key problem for mac algorithms. at point (4), the electrical signal has reached both ends of the cable and occupies it completely. host a continues to transmit the electrical signal until the end of the frame. as shown at point (5), when the sending host stops its transmission, the electrical signal corresponding to the end of the frame leaves the coaxial cable. the channel becomes empty again once the entire electrical signal has been removed from the cable.
now that we have looked at how a frame is actually transmitted as an electrical signal on a shared bus, it is interesting to look in more detail at what happens when two hosts transmit a frame at almost the same time. this is illustrated in the ﬁgure below, where hosts a and b start their transmission at the same time (point (1)). at this time, if host c senses the channel, it will consider it to be free. this will not last a long time and at point (2) the electrical signals from both host a and host b reach host c. the combined electrical signal (shown graphically as the superposition of the two curves in the ﬁgure) cannot be decoded by host c. host c detects a collision, as it receives a signal that it cannot decode. since host c cannot decode the frames, it cannot determine which hosts are sending the colliding frames. note that host a (and host b) will detect the collision after host c (point (3) in the ﬁgure below). as shown above, hosts detect collisions when they receive an electrical signal that they cannot decode. in a wired network, a host is able to detect such a collision both while it is listening (e.g. like host c in the ﬁgure above) and also while it is sending its own frame. when a host transmits a frame, it can compare the electrical signal that it transmits with the electrical signal that it senses on the wire. at points (1) and (2) in the ﬁgure above, host a senses only its own signal. at point (3), it senses an electrical signal that differs from its own signal and can thus detects the collision. at this point, its frame is corrupted and it can stop its transmission. the ability to detect collisions while transmitting is the starting point for the carrier sense multiple access with collision detection (csma/cd) medium access control algorithm, which is used in ethernet networks [metcalfe1976] [802.3] . when an ethernet host detects a collision while it is transmitting, it immediately stops its transmission. compared with pure csma, csma/cd is an important improvement since when collisions occur, they only last until colliding hosts have detected it and stopped their transmission. in practice, when a host detects a collision, it sends a special jamming signal on the cable to ensure that all hosts have detected the collision.
[unicast, multicast and broadcast. while the ethernet service is unreliable in theory, a good ethernet network should, in practice, provide a service that :]
the ﬁrst property is a consequence of the utilisation of csma/cd. the second property is a consequence of the physical organisation of the ethernet network as a shared bus. these two properties are important and all evolutions of the ethernet technology have preserved them.
several physical layers have been deﬁned for ethernet networks. the ﬁrst physical layer, usually called 10base5, provided 10 mbps over a thick coaxial cable. the characteristics of the cable and the transceivers that were used then enabled the utilisation of 500 meter long segments. a 10base5 network can also include repeaters between segments. the second physical layer was 10base2. this physical layer used a thin coaxial cable that was easier to install than the 10base5 cable, but could not be longer than 185 meters. a 10basef physical layer was also deﬁned to transport ethernet over point-to-point optical links. the major change to the physical layer was the support of twisted pairs in the 10baset speciﬁcation. twisted pair cables are traditionally used to support the telephone service in ofﬁce buildings. most ofﬁce buildings today are equipped with structured cabling. several twisted pair cables are installed between any room and a central telecom closet per building or per ﬂoor in large buildings. these telecom closets act as concentration points for the telephone service but also for lans. the introduction of the twisted pairs led to two major changes to ethernet. the ﬁrst change concerns the physical topology of the network. 10base2 and 10base5 networks are shared buses, the coaxial cable typically passes through each room that contains a connected computer. a 10baset network is a star-shaped network. all the devices connected to the network are attached to a twisted pair cable that ends in the telecom closet. from a maintenance perspective, this is a major improvement. the cable is a weak point in 10base2 and 10base5 networks. any physical damage on the cable broke the entire network and when such a failure occurred, the network administrator had to manually check the entire cable to detect where it was damaged. with 10baset, when one twisted pair is damaged, only the device connected to this twisted pair is affected and this does not affect the other devices. the second major change introduced by 10baset was that is was impossible to build a 10baset network by simply connecting all the twisted pairs together. all the twisted pairs must be connected to a relay that operates in the physical layer. this relay is called an ethernet hub. a hub is thus a physical layer relay that receives an electrical signal on one of its interfaces, regenerates the signal and transmits it over all its other interfaces. some hubs are also able to convert the electrical signal from one physical layer to another (e.g. 10baset to 10base2 conversion).
computers can directly be attached to ethernet hubs. ethernet hubs themselves can be attached to other ethernet hubs to build a larger network. however, some important guidelines must be followed when building a complex network with hubs. first, the network topology must be a tree. as hubs are relays in the physical layer, adding a link between hub2 and hub3 in the network below would create an electrical shortcut that would completely disrupt the network. this implies that there cannot be any redundancy in a hub-based network. a failure of a hub or of a link between two hubs would partition the network into two isolated networks. second, as hubs are relays in the physical layer, collisions can happen and must be handled by csma/cd as in a 10base5 network. this implies that the maximum delay between any pair of devices in the network cannot be longer than the 51.2
is represented by a plain horizontal arrow, to which the name of the primitive is attached. the dashed lines are used to represent the possible relationship between two (or more) primitives. such a diagram provides information about the ordering of the different primitives, but the distance between two primitives does not represent a precise amount of time. the ﬁgure below provides a representation of the connectionless service as a time-sequence diagram. the user on the left, having address s, issues a data.request primitive containing sdu m that must be delivered by the service provider to destination d. the dashed line between the two primitives indicates that the data.indication primitive that is delivered to the user on the right corresponds to the data.request primitive sent by the user on the left.
there are several possible implementations of the connectionless service, which we will discuss later in this book. before studying these realisations, it is useful to discuss the possible characteristics of the connectionless service. a reliable connectionless service is a service where the service provider guarantees that all sdus submitted in data.requests by a user will eventually be delivered to their destination. such a service would be very useful for users, but guaranteeing perfect delivery is difﬁcult in practice. for this reason, computer networks usually support an unreliable connectionless service. an unreliable connectionless service may suffer from various types of problems compared to a reliable connectionless service. first of all, an unreliable connectionless service does not guarantee the delivery of all sdus. this can be expressed graphically by using the time-sequence diagram below. in practice, an unreliable connectionless service will usually deliver a large fraction of the sdus. however, since the delivery of sdus is not guaranteed, the user must be able to recover from the loss of any sdu. a second imperfection that may affect an unreliable connectionless service is that it may duplicate sdus. some unreliable connectionless service providers may deliver an sdu sent by a user twice or even more. this is illustrated by the time-sequence diagram below. finally, some unreliable connectionless service providers may deliver to a destination a different sdu than the one that was supplied in the data.request. this is illustrated in the ﬁgure below. when a user interacts with a service provider, it must precisely know the limitations of the underlying service to be able to overcome any problem that may arise. this requires a precise deﬁnition of the characteristics of the underlying service. another important characteristic of the connectionless service is whether it preserves the ordering of the sdus sent by one user. from the user’s viewpoint, this is often a desirable characteristic. this is illustrated in the ﬁgure below. however, many connectionless services, and in particular the unreliable services, do not guarantee that they will always preserve the ordering of the sdus sent by each user. this is illustrated in the ﬁgure below.
depicted below which is similar to the one discussed in [jacobson1988] and rfc 896. in this network, we assume that the buffers of the router are inﬁnite to ensure that no packet is lost.
if many tcp senders are attached to the left part of the network above, they all send a window full of segments. these segments are stored in the buffers of the router before being transmitted towards their destination. if there are many senders on the left part of the network, the occupancy of the buffers quickly grows. a consequence of the buffer occupancy is that the round-trip-time, measured by tcp, between the sender and the receiver increases. consider a network where 10,000 bits segments are sent. when the buffer is empty, such a segment requires 1 millisecond to be transmitted on the 10 mbps link and 5 milliseconds to be the transmitted on the 2 mbps link. thus, the round-trip-time measured by tcp is roughly 6 milliseconds if we ignore the propagation delay on the links. most routers manage their buffers as a fifo queue 25. if the buffer contains 100 segments, the round-triptime becomes 1 + 100 × 5 + 5 milliseconds as new segments are only transmitted on the 2 mbps link once all previous segments have been transmitted. unfortunately, tcp uses a retransmission timer and performs go-back-n to recover from transmission errors. if the buffer occupancy is high, tcp assumes that some segments have been lost and retransmits a full window of segments. this increases the occupancy of the buffer and the delay through the buffer... furthermore, the buffer may store and send on the low bandwidth links several retransmissions of the same segment. this problem is called congestion collapse. it occurred several times in the late 1980s. for example, [jacobson1988] notes that in 1986, the usable bandwidth of a 32 kbits link dropped to 40 bits per second due to congestion collapse 26 ! the congestion collapse is a problem that all heterogeneous networks face. different mechanisms have been proposed in the scientiﬁc literature to avoid or control network congestion. some of them have been implemented and deployed in real networks. to understand this problem in more detail, let us ﬁrst consider a simple network with two hosts attached to a high bandwidth link that are sending segments to destination c attached to a low bandwidth link as depicted below.
to avoid congestion collapse, the hosts must regulate their transmission rate 27 by using a congestion control mechanism. such a mechanism can be implemented in the transport layer or in the network layer. in tcp/ip networks, it is implemented in the transport layer, but other technologies such as asynchronous transfer mode (atm) or frame relay include congestion control mechanisms in lower layers. let us ﬁrst consider the simple problem of a set of i hosts that share a single bottleneck link as shown in the example above. in this network, the congestion control scheme must achieve the following objectives [cj1989] :
25 we discuss in another chapter other possible organisations of the router’s buffers. 26 at this time, tcp implementations were mainly following rfc 791. the round-trip-time estimations and the retransmission mechanisms
27 in this section, we focus on congestion control mechanisms that regulate the transmission rate of the hosts. other types of mechanisms have been proposed in the literature. for example, credit-based ﬂow-control has been proposed to avoid congestion in atm networks [kr1995]. with a credit-based mechanism, hosts can only send packets once they have received credits from the routers and the credits depend on the occupancy of the router’s buffers.
the connectionless service is widely used in computer networks as we will see later in this book. several variations to this basic service have been proposed. one of these is the conﬁrmed connectionless service. this service uses a data.conﬁrm primitive in addition to the classical data.request and data.indication primitives. this primitive is issued by the service provider to conﬁrm to a user the delivery of a previously sent sdu to its recipient. note that, like the registered service of the post ofﬁce, the data.conﬁrm only indicates that the sdu has been delivered to the destination user. the data.conﬁrm primitive does not indicate whether the sdu has been processed by the destination user. this conﬁrmed connectionless service is illustrated in the ﬁgure below.
the connectionless service we have described earlier is frequently used by users who need to exchange small sdus. users needing to either send or receive several different and potentially large sdus, or who need structured exchanges often prefer the connection-oriented service. an invocation of the connection-oriented service is divided into three phases. the ﬁrst phase is the establishment of a connection. a connection is a temporary association between two users through a service provider. several connections may exist at the same time between any pair of users. once established, the connection is used to transfer sdus. connections usually provide one bidirectional stream supporting the exchange of sdus between the two users that are associated through the connection. this stream is used to transfer data during the second phase of the connection called the data transfer phase. the third phase is the termination of the connection. once the users have ﬁnished exchanging sdus, they request to the service provider to terminate the connection. as we will see later, there are also some cases where the service provider may need to terminate a connection itself. the establishment of a connection can be modelled by using four primitives : connect.request, connect.indication, connect.response and connect.conﬁrm. the connect.request primitive is used to request the establishment of a connection. the main parameter of this primitive is the address of the destination user. the service provider delivers a connect.indication primitive to inform the destination user of the connection attempt. if it accepts to establish a connection, it responds with a connect.response primitive. at this point, the connection is considered to be open and the destination user can start sending sdus over the connection. the service provider processes the connect.response and will deliver a connect.conﬁrm to the user who initiated the connection. the delivery of this primitive terminates the connection establishment phase. at this point, the connection is considered to be open and both users can send sdus. a successful connection establishment is illustrated below. the example above shows a successful connection establishment. however, in practice not all connections are successfully established. one reason is that the destination user may not agree, for policy or performance reasons, to establish a connection with the initiating user at this time. in this case, the destination user responds to the connect.indication primitive by a disconnect.request primitive that contains a parameter to indicate why the connection has been refused. the service provider will then deliver a disconnect.indication primitive to inform the initiating user. a second reason is when the service provider is unable to reach the destination user. this might happen because the destination user is not currently attached to the network or due to congestion. in these
sourceproviderdestinationtimedata.request(s, d, "m")data.indication(s, d, "m")data.confirmsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
the connectionless service is widely used in computer networks as we will see later in this book. several variations to this basic service have been proposed. one of these is the conﬁrmed connectionless service. this service uses a data.conﬁrm primitive in addition to the classical data.request and data.indication primitives. this primitive is issued by the service provider to conﬁrm to a user the delivery of a previously sent sdu to its recipient. note that, like the registered service of the post ofﬁce, the data.conﬁrm only indicates that the sdu has been delivered to the destination user. the data.conﬁrm primitive does not indicate whether the sdu has been processed by the destination user. this conﬁrmed connectionless service is illustrated in the ﬁgure below.
the connectionless service we have described earlier is frequently used by users who need to exchange small sdus. users needing to either send or receive several different and potentially large sdus, or who need structured exchanges often prefer the connection-oriented service. an invocation of the connection-oriented service is divided into three phases. the ﬁrst phase is the establishment of a connection. a connection is a temporary association between two users through a service provider. several connections may exist at the same time between any pair of users. once established, the connection is used to transfer sdus. connections usually provide one bidirectional stream supporting the exchange of sdus between the two users that are associated through the connection. this stream is used to transfer data during the second phase of the connection called the data transfer phase. the third phase is the termination of the connection. once the users have ﬁnished exchanging sdus, they request to the service provider to terminate the connection. as we will see later, there are also some cases where the service provider may need to terminate a connection itself. the establishment of a connection can be modelled by using four primitives : connect.request, connect.indication, connect.response and connect.conﬁrm. the connect.request primitive is used to request the establishment of a connection. the main parameter of this primitive is the address of the destination user. the service provider delivers a connect.indication primitive to inform the destination user of the connection attempt. if it accepts to establish a connection, it responds with a connect.response primitive. at this point, the connection is considered to be open and the destination user can start sending sdus over the connection. the service provider processes the connect.response and will deliver a connect.conﬁrm to the user who initiated the connection. the delivery of this primitive terminates the connection establishment phase. at this point, the connection is considered to be open and both users can send sdus. a successful connection establishment is illustrated below. the example above shows a successful connection establishment. however, in practice not all connections are successfully established. one reason is that the destination user may not agree, for policy or performance reasons, to establish a connection with the initiating user at this time. in this case, the destination user responds to the connect.indication primitive by a disconnect.request primitive that contains a parameter to indicate why the connection has been refused. the service provider will then deliver a disconnect.indication primitive to inform the initiating user. a second reason is when the service provider is unable to reach the destination user. this might happen because the destination user is not currently attached to the network or due to congestion. in these
sourceproviderdestinationtimedata.request(s, d, "m")data.indication(s, d, "m")data.confirmsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
throughout this book, we will deﬁne a service as a set of capabilities provided by a system (and its underlying elements) to its user. a user interacts with a service through a service access point. note that as shown in the ﬁgure above, users interact with one service provider. in practice, the service provider is distributed over several hosts, but these are implementation details that are not important at this stage. these interactions between a user and a service provider are expressed in [x200] by using primitives, as show in the ﬁgure below. these primitives are an abstract representation of the interactions between a user and a service provider. in practice, these interactions could be implemented as system calls for example.
• x.request. this type of primitive corresponds to a request issued by a user to a service provider • x.indication. this type of primitive is generated by the network provider and delivered to a user (often
• x.response. this type of primitive is generated by a user to answer to an earlier x.indication primitive • x.conﬁrm. this type of primitive is delivered by the service provide to conﬁrm to a user that a previous
primitives can be combined to model different types of services. the simplest service in computer networks is called the connectionless service 3. this service can be modelled by using two primitives :
• data.request(source,destination,sdu). this primitive is issued by a user that speciﬁes, as parameters, its (source) address, the address of the recipient of the message and the message itself. we will use service data unit (sdu) to name the message that is exchanged transparently between two users of a service. • data.indication(source,destination,sdu). this primitive is delivered by a service provider to a user.
it contains as parameters a service data unit as well as the addresses of the sender and the destination users. when discussing the service provided in a computer network, it is often useful to be able to describe the interactions between the users and the provider graphically. a frequently used representation is the time-sequence diagram. in this chapter and later throughout the book, we will often use diagrams such as the ﬁgure below. a time-sequence diagram describes the interactions between two users and a service provider. by convention, the users are represented in the left and right parts of the diagram while the service provider occupies the middle of the diagram. in such a time-sequence diagram, time ﬂows from the top, to the bottom of the diagram. each primitive
user auser bservice provider ("the network")service access pointprimitivesuser auser bservice provider ("the network")x.indicationx.responsex.confirmx.requestsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
is represented by a plain horizontal arrow, to which the name of the primitive is attached. the dashed lines are used to represent the possible relationship between two (or more) primitives. such a diagram provides information about the ordering of the different primitives, but the distance between two primitives does not represent a precise amount of time. the ﬁgure below provides a representation of the connectionless service as a time-sequence diagram. the user on the left, having address s, issues a data.request primitive containing sdu m that must be delivered by the service provider to destination d. the dashed line between the two primitives indicates that the data.indication primitive that is delivered to the user on the right corresponds to the data.request primitive sent by the user on the left.
there are several possible implementations of the connectionless service, which we will discuss later in this book. before studying these realisations, it is useful to discuss the possible characteristics of the connectionless service. a reliable connectionless service is a service where the service provider guarantees that all sdus submitted in data.requests by a user will eventually be delivered to their destination. such a service would be very useful for users, but guaranteeing perfect delivery is difﬁcult in practice. for this reason, computer networks usually support an unreliable connectionless service. an unreliable connectionless service may suffer from various types of problems compared to a reliable connectionless service. first of all, an unreliable connectionless service does not guarantee the delivery of all sdus. this can be expressed graphically by using the time-sequence diagram below. in practice, an unreliable connectionless service will usually deliver a large fraction of the sdus. however, since the delivery of sdus is not guaranteed, the user must be able to recover from the loss of any sdu. a second imperfection that may affect an unreliable connectionless service is that it may duplicate sdus. some unreliable connectionless service providers may deliver an sdu sent by a user twice or even more. this is illustrated by the time-sequence diagram below. finally, some unreliable connectionless service providers may deliver to a destination a different sdu than the one that was supplied in the data.request. this is illustrated in the ﬁgure below. when a user interacts with a service provider, it must precisely know the limitations of the underlying service to be able to overcome any problem that may arise. this requires a precise deﬁnition of the characteristics of the underlying service. another important characteristic of the connectionless service is whether it preserves the ordering of the sdus sent by one user. from the user’s viewpoint, this is often a desirable characteristic. this is illustrated in the ﬁgure below. however, many connectionless services, and in particular the unreliable services, do not guarantee that they will always preserve the ordering of the sdus sent by each user. this is illustrated in the ﬁgure below.
its distance vector to its neighbours to inform them. the route can then be removed from the routing table after some time (e.g. 3 × n seconds), to ensure that the neighbouring routers have received the bad news, even if some distance vectors do not reach them due to transmission errors. consider the example above and assume that the link between routers a and b fails. before the failure, a used b to reach destinations b, c and e while b only used the a-b link to reach a. the affected entries timeout on routers a and b and they both send their distance vector.
• a sends its distance vector [a = 0, d = ∞, c = ∞, d = 1, e = ∞]. d knows that it cannot reach b anymore via a • d sends its distance vector [d = 0, b = ∞, a = 1, c = 2, e = 1] to a and e. a recovers routes towards c and e via d. • b sends its distance vector [b = 0, a = ∞, c = 1, d = 2, e = 1] to e and c. d learns that there is no route anymore to reach a via b.
at this point, all routers have a routing table allowing them to reach all another routers, except router a, which cannot yet reach router b. a recovers the route towards b once router d sends its updated distance vector [a = 1, b = 2, c = 2, d = 1, e = 1]. this last step is illustrated in ﬁgure routing tables computed by distance vector after a failure, which shows the routing tables on all routers.
consider now that the link between d and e fails. the network is now partitioned into two disjoint parts : (a , d) and (b, e, c). the routes towards b, c and e expire ﬁrst on router d. at this time, router d updates its routing table. if d sends [d = 0, a = 1, b = ∞, c = ∞, e = ∞], a learns that b, c and e are unreachable and updates its routing table. unfortunately, if the distance vector sent to a is lost or if a sends its own distance vector ( [a = 0, d = 1, b = 3, c = 3, e = 2] ) at the same time as d sends its distance vector, d updates its routing table to use the
the pseudo-code below shows the operation of an alohanet terminal. we use this python syntax for all medium access control algorithms described in this chapter. the algorithm is applied to each new frame that needs to be transmitted. it attempts to transmit a frame at most max times (while loop). each transmission attempt is performed as follows: first, the frame is sent. each frame is protected by a timeout. then, the terminal waits for either a valid acknowledgement frame or the expiration of its timeout. if the terminal receives an acknowledgement, the frame has been delivered correctly and the algorithm terminates. otherwise, the terminal waits for a random time and attempts to retransmit the frame.
[abramson1970] analysed the performance of alohanet under particular assumptions and found that alohanet worked well when the channel was lightly loaded. in this case, the frames are rarely retransmitted and the channel trafﬁc, i.e. the total number of (correct and retransmitted) frames transmitted per unit of time is close to the channel utilization, i.e. the number of correctly transmitted frames per unit of time. unfortunately, the analysis 2×e = 0.186 times the channel bandwidth. at also reveals that the channel utilization reaches its maximum at higher utilization, alohanet becomes unstable and the network collapses due to collided retransmissions.
note: amateur packet radio packet radio technologies have evolved in various directions since the ﬁrst experiments performed at the university of hawaii. the amateur packet radio service developed by amateur radio operators is one of the descendants alohanet. many amateur radio operators are very interested in new technologies and they often spend countless hours developing new antennas or transceivers. when the ﬁrst personal computers appeared, several amateur radio operators designed radio modems and their own datalink layer protocols [kpd1985] [bnt1997]. this network grew and it was possible to connect to servers in several european countries by only using packet radio relays. some amateur radio operators also developed tcp/ip protocol stacks that were used over the packet radio service. some parts of the amateur packet radio network are connected to the global internet and use the 44.0.0.0/8 preﬁx.
many improvements to alohanet have been proposed since the publication of [abramson1970], and this technique, or some of its variants, are still found in wireless networks today. the slotted technique proposed in [roberts1975] is important because it shows that a simple modiﬁcation can signiﬁcantly improve channel utilization. instead of allowing all terminals to transmit at any time, [roberts1975] proposed to divide time into slots and allow terminals to transmit only at the beginning of each slot. each slot corresponds to the time required to transmit one ﬁxed size frame. in practice, these slots can be imposed by a single clock that is received by all terminals. in alohanet, it could have been located on the central mainframe. the analysis in [roberts1975] reveals that this simple modiﬁcation improves the channel utilization by a factor of two.
aloha and slotted aloha can easily be implemented, but unfortunately, they can only be used in networks that are very lightly loaded. designing a network for a very low utilisation is possible, but it clearly increases the cost of the network. to overcome the problems of aloha, many medium access control mechanisms have been proposed which improve channel utilization. carrier sense multiple access (csma) is a signiﬁcant improvement compared to aloha. csma requires all nodes to listen to the transmission channel to verify that it is free before transmitting a frame [kt1975]. when a node senses the channel to be busy, it defers its transmission until the channel becomes free again. the pseudo-code below provides a more detailed description of the operation of csma.
the above pseudo-code is often called persistent csma [kt1975] as the terminal will continuously listen to the channel and transmit its frame as soon as the channel becomes free. another important variant of csma is the non-persistent csma [kt1975]. the main difference between persistent and non-persistent csma described in the pseudo-code below is that a non-persistent csma node does not continuously listen to the channel to determine when it becomes free. when a non-persistent csma terminal senses the transmission channel to be busy, it waits for a random time before sensing the channel again. this improves channel utilization compared to persistent csma. with persistent csma, when two terminals sense the channel to be busy, they will both transmit (and thus cause a collision) as soon as the channel becomes free. with non-persistent csma, this synchronisation does not occur, as the terminals wait a random time after having sensed the transmission channel. however, the higher channel utilization achieved by non-persistent csma comes at the expense of a slightly higher waiting time in the terminals when the network is lightly loaded.
[kt1975] analyzes in detail the performance of several csma variants. under some assumptions about the transmission channel and the trafﬁc, the analysis compares aloha, slotted aloha, persistent and non-persistent csma. under these assumptions, aloha achieves a channel utilization of only 18.4% of the channel capacity. slotted aloha is able to use 36.6% of this capacity. persistent csma improves the utilization by reaching 52.9% of the capacity while non-persistent csma achieves 81.5% of the channel capacity.
csma improves channel utilization compared to aloha. however, the performance can still be improved, especially in wired networks. consider the situation of two terminals that are connected to the same cable. this cable could, for example, be a coaxial cable as in the early days of ethernet [metcalfe1976]. it could also be built with twisted pairs. before extending csma, it is useful to understand more intuitively, how frames are transmitted in such a network and how collisions can occur. the ﬁgure below illustrates the physical transmission of a frame on such a cable. to transmit its frame, host a must send an electrical signal on the shared medium. the ﬁrst step is thus to begin the transmission of the electrical signal. this is point (1) in the ﬁgure below. this electrical signal will travel along the cable. although electrical signals travel fast, we know that information cannot travel faster than the speed of light (i.e. 300.000 kilometers/second). on a coaxial cable, an electrical signal is slightly slower
the pseudo-code below shows the operation of an alohanet terminal. we use this python syntax for all medium access control algorithms described in this chapter. the algorithm is applied to each new frame that needs to be transmitted. it attempts to transmit a frame at most max times (while loop). each transmission attempt is performed as follows: first, the frame is sent. each frame is protected by a timeout. then, the terminal waits for either a valid acknowledgement frame or the expiration of its timeout. if the terminal receives an acknowledgement, the frame has been delivered correctly and the algorithm terminates. otherwise, the terminal waits for a random time and attempts to retransmit the frame.
[abramson1970] analysed the performance of alohanet under particular assumptions and found that alohanet worked well when the channel was lightly loaded. in this case, the frames are rarely retransmitted and the channel trafﬁc, i.e. the total number of (correct and retransmitted) frames transmitted per unit of time is close to the channel utilization, i.e. the number of correctly transmitted frames per unit of time. unfortunately, the analysis 2×e = 0.186 times the channel bandwidth. at also reveals that the channel utilization reaches its maximum at higher utilization, alohanet becomes unstable and the network collapses due to collided retransmissions.
note: amateur packet radio packet radio technologies have evolved in various directions since the ﬁrst experiments performed at the university of hawaii. the amateur packet radio service developed by amateur radio operators is one of the descendants alohanet. many amateur radio operators are very interested in new technologies and they often spend countless hours developing new antennas or transceivers. when the ﬁrst personal computers appeared, several amateur radio operators designed radio modems and their own datalink layer protocols [kpd1985] [bnt1997]. this network grew and it was possible to connect to servers in several european countries by only using packet radio relays. some amateur radio operators also developed tcp/ip protocol stacks that were used over the packet radio service. some parts of the amateur packet radio network are connected to the global internet and use the 44.0.0.0/8 preﬁx.
many improvements to alohanet have been proposed since the publication of [abramson1970], and this technique, or some of its variants, are still found in wireless networks today. the slotted technique proposed in [roberts1975] is important because it shows that a simple modiﬁcation can signiﬁcantly improve channel utilization. instead of allowing all terminals to transmit at any time, [roberts1975] proposed to divide time into slots and allow terminals to transmit only at the beginning of each slot. each slot corresponds to the time required to transmit one ﬁxed size frame. in practice, these slots can be imposed by a single clock that is received by all terminals. in alohanet, it could have been located on the central mainframe. the analysis in [roberts1975] reveals that this simple modiﬁcation improves the channel utilization by a factor of two.
aloha and slotted aloha can easily be implemented, but unfortunately, they can only be used in networks that are very lightly loaded. designing a network for a very low utilisation is possible, but it clearly increases the cost of the network. to overcome the problems of aloha, many medium access control mechanisms have been proposed which improve channel utilization. carrier sense multiple access (csma) is a signiﬁcant improvement compared to aloha. csma requires all nodes to listen to the transmission channel to verify that it is free before transmitting a frame [kt1975]. when a node senses the channel to be busy, it defers its transmission until the channel becomes free again. the pseudo-code below provides a more detailed description of the operation of csma.
slot time is the optimal delay since it is the shortest delay that ensures that the ﬁrst host will be able to retransmit its frame completely without any collision. if two hosts are competing, the algorithm above will avoid a second collision 50% of the time. however, if the network is heavily loaded, several hosts may be competing at the same time. in this case, the hosts should be able to automatically adapt their retransmission delay. the binary exponential back-off performs this adaptation based on the number of collisions that have affected a frame. after the ﬁrst collision, the host ﬂips a coin and waits 0 or 1 slot time. after the second collision, it generates a random number and waits 0, 1, 2 or 3 slot times, etc. the duration of the waiting time is doubled after each collision. the complete pseudo-code for the csma/cd algorithm is shown in the ﬁgure below.
the inter-frame delay used in this pseudo-code is a short delay corresponding to the time required by a network adapter to switch from transmit to receive mode. it is also used to prevent a host from sending a continuous stream of frames without leaving any transmission opportunities for other hosts on the network. this contributes to the fairness of csma/cd. despite this delay, there are still conditions where csma/cd is not completely fair [ry1994]. consider for example a network with two hosts : a server sending long frames and a client sending acknowledgments. measurements reported in [ry1994] have shown that there are situations where the client could suffer from repeated collisions that lead it to wait for long periods of time due to the exponential back-off algorithm.
the carrier sense multiple access with collision avoidance (csma/ca) medium access control algorithm was designed for the popular wifi wireless network technology [802.11]. csma/ca also senses the transmission channel before transmitting a frame. furthermore, csma/ca tries to avoid collisions by carefully tuning the timers used by csma/ca devices. csma/ca uses acknowledgements like csma. each frame contains a sequence number and a crc. the crc is used to detect transmission errors while the sequence number is used to avoid frame duplication. when a device receives a correct frame, it returns a special acknowledgement frame to the sender. csma/ca introduces a small delay, named short inter frame spacing (sifs), between the reception of a frame and the transmission of the acknowledgement frame. this delay corresponds to the time that is required to switch the radio of a device between the reception and transmission modes. compared to csma, csma/ca deﬁnes more precisely when a device is allowed to send a frame. first, csma/ca deﬁnes two delays : difs and eifs. to send a frame, a device must ﬁrst wait until the channel has been idle for at least the distributed coordination function inter frame space (difs) if the previous frame was received correctly. however, if the previously received frame was corrupted, this indicates that there are collisions and the device must sense the channel idle for at least the extended inter frame space (eifs), with sif s < dif s < eif s. the exact values for sifs, difs and eifs depend on the underlying physical layer [802.11].
the above pseudo-code is often called persistent csma [kt1975] as the terminal will continuously listen to the channel and transmit its frame as soon as the channel becomes free. another important variant of csma is the non-persistent csma [kt1975]. the main difference between persistent and non-persistent csma described in the pseudo-code below is that a non-persistent csma node does not continuously listen to the channel to determine when it becomes free. when a non-persistent csma terminal senses the transmission channel to be busy, it waits for a random time before sensing the channel again. this improves channel utilization compared to persistent csma. with persistent csma, when two terminals sense the channel to be busy, they will both transmit (and thus cause a collision) as soon as the channel becomes free. with non-persistent csma, this synchronisation does not occur, as the terminals wait a random time after having sensed the transmission channel. however, the higher channel utilization achieved by non-persistent csma comes at the expense of a slightly higher waiting time in the terminals when the network is lightly loaded.
[kt1975] analyzes in detail the performance of several csma variants. under some assumptions about the transmission channel and the trafﬁc, the analysis compares aloha, slotted aloha, persistent and non-persistent csma. under these assumptions, aloha achieves a channel utilization of only 18.4% of the channel capacity. slotted aloha is able to use 36.6% of this capacity. persistent csma improves the utilization by reaching 52.9% of the capacity while non-persistent csma achieves 81.5% of the channel capacity.
csma improves channel utilization compared to aloha. however, the performance can still be improved, especially in wired networks. consider the situation of two terminals that are connected to the same cable. this cable could, for example, be a coaxial cable as in the early days of ethernet [metcalfe1976]. it could also be built with twisted pairs. before extending csma, it is useful to understand more intuitively, how frames are transmitted in such a network and how collisions can occur. the ﬁgure below illustrates the physical transmission of a frame on such a cable. to transmit its frame, host a must send an electrical signal on the shared medium. the ﬁrst step is thus to begin the transmission of the electrical signal. this is point (1) in the ﬁgure below. this electrical signal will travel along the cable. although electrical signals travel fast, we know that information cannot travel faster than the speed of light (i.e. 300.000 kilometers/second). on a coaxial cable, an electrical signal is slightly slower
another problem faced by wireless networks is often called the hidden station problem. in a wireless network, radio signals are not always propagated same way in all directions. for example, two devices separated by a wall may not be able to receive each other’s signal while they could both be receiving the signal produced by a third host. this is illustrated in the ﬁgure below, but it can happen in other environments. for example, two devices that are on different sides of a hill may not be able to receive each other’s signal while they are both able to receive the signal sent by a station at the top of the hill. furthermore, the radio propagation conditions may change with time. for example, a truck may temporarily block the communication between two nearby devices.
to avoid collisions in these situations, csma/ca allows devices to reserve the transmission channel for some time. this is done by using two control frames : request to send (rts) and clear to send (cts). both are very short frames to minimize the risk of collisions. to reserve the transmission channel, a device sends a rts frame to the intended recipient of the data frame. the rts frame contains the duration of the requested reservation. the recipient replies, after a sifs delay, with a cts frame which also contains the duration of the reservation. as the duration of the reservation has been sent in both rts and cts, all hosts that could collide with either the sender or the reception of the data frame are informed of the reservation. they can compute the total duration of the transmission and defer their access to the transmission channel until then. this is illustrated in the ﬁgure below where host a reserves the transmission channel to send a data frame to host b. host c notices the reservation and defers its transmission.
the utilization of the reservations with csma/ca is an optimisation that is useful when collisions are frequent. if there are few collisions, the time required to transmit the rts and cts frames can become signiﬁcant and in particular when short frames are exchanged. some devices only turn on rts/cts after transmission errors.
most 802.11 deployments use a maximum payload size of 1500 bytes as they are used in infrastructure networks attached to ethernet lans. an 802.11 data frame is shown below.
the ﬁrst part of the 802.11 header is the 16 bit frame control ﬁeld. this ﬁeld contains ﬂags that indicate the type of frame (data frame, rts/cts, acknowledgement, management frames, etc), whether the frame is sent to or from a ﬁxed lan, etc [802.11]. the duration is a 16 bit ﬁeld that is used to reserve the transmission channel. in data frames, the duration ﬁeld is usually set to the time required to transmit one acknowledgement frame after a sifs delay. note that the duration ﬁeld must be set to zero in multicast and broadcast frames. as these frames are not acknowledged, there is no need to reserve the transmission channel after their transmission. the sequence control ﬁeld contains a 12 bits sequence number that is incremented for each data frame. the astute reader may have noticed that the 802.11 data frames contain three 48-bits address ﬁelds 12 . this is surprising compared to other protocols in the network and datalink layers whose headers only contain a source and a destination address. the need for a third address in the 802.11 header comes from the infrastructure networks. in such a network, frames are usually exchanged between routers and servers attached to the lan and wifi devices attached to one of the access points. the role of the three address ﬁelds is speciﬁed by bit ﬂags in the frame control ﬁeld. when a frame is sent from a wifi device to a server attached to the same lan as the access point, the ﬁrst address of the frame is set to the mac address of the access point, the second address is set to the mac address of the source wifi device and the third address is the address of the ﬁnal destination on the lan. when the server replies, it sends an ethernet frame whose source address is its mac address and the destination address is the mac address of the wifi device. this frame is captured by the access point that converts the ethernet header into an 802.11 frame header. the 802.11 frame sent by the access point contains three addresses : the ﬁrst address is the mac address of the destination wifi device, the second address is the mac address of the access point and the third address the mac address of the server that sent the frame. 802.11 control frames are simpler than data frames. they contain a frame control, a duration ﬁeld and one or two addresses. the acknowledgement frames are very small. they only contain the address of the destination of the acknowledgement. there is no source address and no sequence control ﬁeld in the acknowledgement frames. this is because the acknowledgement frame can easily be associated to the previous frame that it acknowledges. indeed, each unicast data frame contains a duration ﬁeld that is used to reserve the transmission channel to ensure that no collision will affect the acknowledgement frame. the sequence control ﬁeld is mainly used by the receiver to remove duplicate frames. duplicate frames are detected as follows. each data frame contains a 12 bits sequence control ﬁeld and the frame control ﬁeld contains the retry bit ﬂag that is set when a frame is transmitted. each 802.11 receiver stores the most recent sequence number received from each source address in frames whose retry bit is reset. upon reception of a frame with the retry bit set, the receiver veriﬁes its sequence number to determine whether it is a duplicated frame or not. 802.11 rts/cts frames are used to reserve the transmission channel, in order to transmit one data frame and its acknowledgement. the rts frames contain a duration and the transmitter and receiver addresses. the duration
the simplest sliding window protocol uses go-back-n recovery. intuitively, go-back-n operates as follows. a go-back-n receiver is as simple as possible. it only accepts the segments that arrive in-sequence. a go-backn receiver discards any out-of-sequence segment that it receives. when go-back-n receives a data segment, it always returns an acknowledgement containing the sequence number of the last in-sequence segment that it has received. this acknowledgement is said to be cumulative. when a go-back-n receiver sends an acknowledgement for sequence number x, it implicitly acknowledges the reception of all segments whose sequence number is earlier than x. a key advantage of these cumulative acknowledgements is that it is easy to recover from the loss of an acknowledgement. consider for example a go-back-n receiver that received segments 1, 2 and 3. it sent ok1, ok2 and ok3. unfortunately, ok1 and ok2 were lost. thanks to the cumulative acknowledgements, when the receiver receives ok3, it knows that all three segments have been correctly received. the ﬁgure below shows the fsm of a simple go-back-n receiver. this receiver uses two variables : lastack and next. next is the next expected sequence number and lastack the sequence number of the last data segment that has been acknowledged. the receiver only accepts the segments that are received in sequence. maxseq is the number of different sequence numbers (2n).
a go-back-n sender is also very simple. it uses a sending buffer that can store an entire sliding window of segments 3 . the segments are sent with increasing sequence number (modulo maxseq). the sender must wait for
recvd(d(next,sdu,crc))and isok(crc,sdu)data.ind(sdu)recvd(d(t<>next,sdu,crc))and isok(crc,sdu)discard(sdu);send(c(ok,lastack ,crc));-send(c(ok,next,crc));lastack = nextnext=(next+1) % maxseq;wait processsduokall corruptedsegments arediscarded in all statessaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
in the early days of the internet, domains would simply exchange all the routes they know to allow a host inside one domain to reach any host in the global internet. however, in today’s highly commercial internet, this is no longer true as interdomain routing mainly needs to take into account the economical relationships between the domains. furthermore, while intradomain routing usually prefers some routes over others based on their technical merits (e.g. prefer route with the minimum number of hops, prefer route with the minimum delay, prefer high bandwidth routes over low bandwidth ones, etc) interdomain routing mainly deals with economical issues. for interdomain routing, the cost of using a route is often more important than the quality of the route measured by its delay or bandwidth. there are different types of economical relationships that can exist between domains. interdomain routing converts these relationships into peering relationships between domains that are connected via peering links. the ﬁrst category of peering relationship is the customer->provider relationship. such a relationship is used when a customer domain pays an internet service provider to be able to exchange packets with the global internet over an interdomain link. a similar relationship is used when a small internet service provider pays a larger internet service provider to exchange packets with the global internet.
to understand the customer->provider relationship, let us consider the simple internetwork shown in the ﬁgure above. in this internetwork, as7 is a stub domain that is connected to one provider : as4. the contract between as4 and as7 allows a host inside as7 to exchange packets with any host in the internetwork. to enable this exchange of packets, as7 must know a route towards any domain and all the domains of the internetwork must know a route via as4 that allows them to reach hosts inside as7. from a routing perspective, the commercial contract between as7 and as4 leads to the following routes being exchanged :
• over a provider->customer relationship, the provider advertises all the routes that it knows to its customer. the second rule ensures that the customer domain receives a route towards all destinations that are reachable via its provider. the ﬁrst rule allows the routes of the customer domain to be distributed throughout the internet.
3. the network layer is conceptually divided into two planes : the data plane and the control plane. the data plane contains the protocols and mechanisms that allow hosts and routers to exchange packets carrying user data. the control plane contains the protocols and mechanisms that enable routers to efﬁciently learn how to forward packets towards their ﬁnal destination.
the independence of the network layer from the underlying datalink layer is a key principle of the network layer. it ensures that the network layer can be used to allow hosts attached to different types of datalink layers to exchange packets through intermediate routers. furthermore, this allows the datalink layers and the network layer to evolve independently from each other. this enables the network layer to be easily adapted to a new datalink layer every time a new datalink layer is invented. there are two types of service that can be provided by the network layer :
connection-oriented services have been popular with technologies such as x.25 and atm or frame-relay, but nowadays most networks use an unreliable connectionless service. this is our main focus in this chapter.
the internal organisation of the network is orthogonal to the service that it provides, but most of the time a datagram organisation is used to provide a connectionless service while a virtual circuit organisation is used in networks that provide a connection-oriented service.
the ﬁrst and most popular organisation of the network layer is the datagram organisation. this organisation is inspired by the organisation of the postal service. each host is identiﬁed by a network layer address. to send information to a remote host, a host creates a packet that contains :
the network layer limits the maximum packet size. thus, the information must have been divided in packets by the transport layer before being passed to the network layer. to understand the datagram organisation, let us consider the ﬁgure below. a network layer address, represented by a letter, has been assigned to each host and router. to send some information to host j, host a creates a packet containing its own address, the destination address and the information to be exchanged. with the datagram organisation, routers use hop-by-hop forwarding. this means that when a router receives a packet that is not destined to itself, it looks up the destination address of the packet in its routing table. a routing table is a data structure that maps each destination address (or set of destination addresses) to the outgoing interface over which a packet destined to this address must be forwarded to reach its ﬁnal destination. the main constraint imposed on the routing tables is that they must allow any host in the network to reach any other host. this implies that each router must know a route towards each destination, but also that the paths composed from the information stored in the routing tables must not contain loops. otherwise, some destinations would be unreachable.
the physical layer allows thus two or more entities that are directly attached to the same transmission medium to exchange bits. being able to exchange bits is important as virtually any information can be encoded as a sequence of bits. electrical engineers are used to processing streams of bits, but computer scientists usually prefer to deal with higher level concepts. a similar issue arises with ﬁle storage. storage devices such as hard-disks also store streams of bits. there are hardware devices that process the bit stream produced by a hard-disk, but computer scientists have designed ﬁlesystems to allow applications to easily access such storage devices. these ﬁlesystems are typically divided into several layers as well. hard-disks store sectors of 512 bytes or more. unix ﬁlesystems group sectors in larger blocks that can contain data or inodes representing the structure of the ﬁlesystem. finally, applications manipulate ﬁles and directories that are translated in blocks, sectors and eventually bits by the operating system. computer networks use a similar approach. each layer provides a service that is built above the underlying layer and is closer to the needs of the applications. the datalink layer builds on the service provided by the underlying physical layer. the datalink layer allows two hosts that are directly connected through the physical layer to exchange information. the unit of information exchanged between two entities in the datalink layer is a frame. a frame is a ﬁnite sequence of bits. some datalink layers use variable-length frames while others only use ﬁxed-length frames. some datalink layers provide a connection-oriented service while others provide a connectionless service. some datalink layers provide reliable delivery while others do not guarantee the correct delivery of the information. an important point to note about the datalink layer is that although the ﬁgure below indicates that two entities of the datalink layer exchange frames directly, in reality this is slightly different. when the datalink layer entity on the left needs to transmit a frame, it issues as many data.request primitives to the underlying physical layer as there are bits in the frame. the physical layer will then convert the sequence of bits in an electromagnetic or optical signal that will be sent over the physical medium. the physical layer on the right hand side of the ﬁgure will decode the received signal, recover the bits and issue the corresponding data.indication primitives to its datalink layer entity. if there are no transmission errors, this entity will receive the frame sent earlier.
the datalink layer allows directly connected hosts to exchange information, but it is often necessary to exchange information between hosts that are not attached to the same physical medium. this is the task of the network layer. the network layer is built above the datalink layer. network layer entities exchange packets. a packet is a ﬁnite sequence of bytes that is transported by the datalink layer inside one or more frames. a packet usually
physical layerphysical layerbitsphysical transmission medium01010010100010101001010datalinkphysicalframesdatalinkphysicalsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
• rto : the retransmission timeout is computed as rto = min(60, max(1, β × srtt)) where β is used to take into account the delay variance (value : 1.3 to 2.0). the 60 and 1 constants are used to ensure that the rto is not larger than one minute nor smaller than 1 second.
however, in practice, this computation for the retransmission timeout did not work well. the main problem was that the computed rto did not correctly take into account the variations in the measured round-trip-time. van jacobson proposed in his seminal paper [jacobson1988] an improved algorithm to compute the rto and implemented it in the bsd unix distribution. this algorithm is now part of the tcp standard rfc 2988. jacobson’s algorithm uses two state variables, srtt the smoothed rtt and rttvar the estimation of the variance of the rtt and two parameters : α and β. when a tcp connection starts, the ﬁrst rto is set to 3 seconds. when a ﬁrst estimation of the rtt is available, the srtt, rttvar and rto are computed as
the proposed values for the parameters are α = 1 4. this allows a tcp implementation, implemented in the kernel, to perform the rtt computation by using shift operations instead of the more costly ﬂoating point operations [jacobson1988]. the ﬁgure below illustrates the computation of the rto upon rtt changes.
the default go-back-n retransmission strategy was deﬁned in rfc 793. when the retransmission timer expires, tcp retransmits the ﬁrst unacknowledged segment (i.e. the one having sequence number snd.una). after each expiration of the retransmission timeout, rfc 2988 recommends to double the value of the retransmission timeout. this is called an exponential backoff. this doubling of the retransmission timeout after a retransmission was included in tcp to deal with issues such as network/receiver overload and incorrect initial estimations of the retransmission timeout. if the same segment is retransmitted several times, the retransmission timeout is doubled after every retransmission until it reaches a conﬁgured maximum. rfc 2988 suggests a maximum retransmission timeout of at least 60 seconds. once the retransmission timeout reaches this conﬁgured maximum, the remote host is considered to be unreachable and the tcp connection is closed. this retransmission strategy has been reﬁned based on the experience of using tcp on the internet. the ﬁrst reﬁnement was a clariﬁcation of the strategy used to send acknowledgements. as tcp uses piggybacking, the
be exchanged. on the other hand, a server host starts in the init state. when a server process starts to listen to a destination port, the underlying tcp entity creates a tcp control block and a queue to process incoming syn segments. upon reception of a syn segment, the server’s tcp entity replies with a syn+ack and enters the syn rcvd state. it remains in this state until it receives an ack segment that acknowledges its syn+ack segment, with this it then enters the established state. apart from these two paths in the tcp connection establishment fsm, there is a third path that corresponds to the case when both the client and the server send a syn segment to open a tcp connection 13. in this case, the client and the server send a syn segment and enter the syn sent state. upon reception of the syn segment sent by the other host, they reply by sending a syn+ack segment and enter the syn rcvd state. the syn+ack that arrives from the other host allows it to transition to the established state. the ﬁgure below illustrates such a simultaneous establishment of a tcp connection.
13 of course, such a simultaneous tcp establishment can only occur if the source port chosen by the client is equal to the destination port chosen by the server. this may happen when a host can serve both as a client as a server or in peer-to-peer applications when the communicating hosts do not use ephemeral port numbers.
the easiest way to understand the operation of arp is to consider the simple network shown above and assume that host 10.0.1.22/24 needs to send an ipv4 packet to host 10.0.1.8. as this ip address belongs to the same subnet, the packet must be sent directly to its destination via the datalink layer service. to use this service, the sending host must ﬁnd the datalink layer address that is attached to host 10.0.1.8. each ipv4 host maintains an arp cache containing the list of all mappings between ipv4 addresses and datalink layer addresses that it knows. when an ipv4 hosts boots, its arp cache is empty. 10.0.1.22 thus ﬁrst consults its arp cache. as the cache does not contain the requested mapping, host 10.0.1.22 sends a broadcast arp query frame on the lan. the frame contains the datalink layer address of the sending host (a) and the requested ipv4 address (10.0.1.8). this broadcast frame is received by all devices on the lan and only the host that owns the requested ipv4 address replies by returning a unicast arp reply frame with the requested mapping. upon reception of this reply, the sending host updates its arp cache and sends the ipv4 packet by using the datalink layer service. to deal with devices that move or whose addresses are reconﬁgured, most arp implementations remove the cache entries that have not been used for a few minutes. some implementations re-validate arp cache entries from time to time by sending arp queries 13.
note: security issues with the address resolution protocol arp is an old and widely used protocol that was unfortunately designed when security issues were not a concern. arp is almost insecure by design. hosts using arp can be subject to several types of attack. first, a malicious host could create a denial of service attack on a lan by sending random replies to the received arp queries. this would pollute the arp cache of the other hosts on the same lan. on a ﬁxed network, such attacks can be detected by the system administrator who can physically remove the malicious hosts from the lan. on a wireless network, removing a malicious host is much more difﬁcult. a second type of attack are the man-in-the-middle attacks. this name is used for network attacks where the attacker is able to read and possibly modify all the messages sent by the attacked devices. such an attack is possible in a lan. assume, in the ﬁgure above, that host 10.0.1.9 is malicious and would like to receive and modify all the packets sent by host 10.0.1.22 to host 10.0.1.8. this can be achieved easily if host 10.0.1.9 manages, by sending fake arp replies, to convince host 10.0.1.22 (resp. 10.0.1.8) that its own datalink layer address must be used to reach 10.0.1.8 (resp. 10.0.1.22).
arp is used by all devices that are connected to a lan and implement ipv4. both routers and endhosts implement arp. when a host needs to send an ipv4 packet to a destination outside of its local subnet, it must ﬁrst send the packet to one of the routers that reside on this subnet. consider for example the network shown in the ﬁgure below. each host is conﬁgured with an ipv4 address in the 10.0.1.0/24 subnet and uses 10.0.1.1 as its default router. to send a packet to address 1.2.3.4, host 10.0.1.8 will ﬁrst need to know the datalink layer of the default router. it will thus send an arp request for 10.0.1.1. upon reception of the arp reply, host 10.0.1.8 updates its arp table and sends its packet in a frame to its default router. the router will then forward the packet towards its ﬁnal destination.
in the early days of the internet, ip addresses were manually conﬁgured on both hosts and routers and almost never changed. however, this manual conﬁguration can be complex 14 and often causes errors that are sometimes difﬁcult to debug. recent tcp/ip implementations are able to detect some of these misconﬁgurations. for example, if two hosts are attached to the same subnet with the same ipv4 address they will be unable to communicate. to detect this problem hosts send an arp request for their conﬁgured address each time their addressed is changed rfc 5227. if they receive an answer to this arp request, they trigger an alarm or inform the system administrator.
13 see chapter 28 of [benvenuti2005] for a description of the implementation of arp in the linux kernel. 14 for example, consider all the options that can be speciﬁed for the ifconﬁg utility<http://en.wikipedia.org/wiki/ifconﬁg> on unix hosts.
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
slot time is the optimal delay since it is the shortest delay that ensures that the ﬁrst host will be able to retransmit its frame completely without any collision. if two hosts are competing, the algorithm above will avoid a second collision 50% of the time. however, if the network is heavily loaded, several hosts may be competing at the same time. in this case, the hosts should be able to automatically adapt their retransmission delay. the binary exponential back-off performs this adaptation based on the number of collisions that have affected a frame. after the ﬁrst collision, the host ﬂips a coin and waits 0 or 1 slot time. after the second collision, it generates a random number and waits 0, 1, 2 or 3 slot times, etc. the duration of the waiting time is doubled after each collision. the complete pseudo-code for the csma/cd algorithm is shown in the ﬁgure below.
the inter-frame delay used in this pseudo-code is a short delay corresponding to the time required by a network adapter to switch from transmit to receive mode. it is also used to prevent a host from sending a continuous stream of frames without leaving any transmission opportunities for other hosts on the network. this contributes to the fairness of csma/cd. despite this delay, there are still conditions where csma/cd is not completely fair [ry1994]. consider for example a network with two hosts : a server sending long frames and a client sending acknowledgments. measurements reported in [ry1994] have shown that there are situations where the client could suffer from repeated collisions that lead it to wait for long periods of time due to the exponential back-off algorithm.
the carrier sense multiple access with collision avoidance (csma/ca) medium access control algorithm was designed for the popular wifi wireless network technology [802.11]. csma/ca also senses the transmission channel before transmitting a frame. furthermore, csma/ca tries to avoid collisions by carefully tuning the timers used by csma/ca devices. csma/ca uses acknowledgements like csma. each frame contains a sequence number and a crc. the crc is used to detect transmission errors while the sequence number is used to avoid frame duplication. when a device receives a correct frame, it returns a special acknowledgement frame to the sender. csma/ca introduces a small delay, named short inter frame spacing (sifs), between the reception of a frame and the transmission of the acknowledgement frame. this delay corresponds to the time that is required to switch the radio of a device between the reception and transmission modes. compared to csma, csma/ca deﬁnes more precisely when a device is allowed to send a frame. first, csma/ca deﬁnes two delays : difs and eifs. to send a frame, a device must ﬁrst wait until the channel has been idle for at least the distributed coordination function inter frame space (difs) if the previous frame was received correctly. however, if the previously received frame was corrupted, this indicates that there are collisions and the device must sense the channel idle for at least the extended inter frame space (eifs), with sif s < dif s < eif s. the exact values for sifs, difs and eifs depend on the underlying physical layer [802.11].
a simple solution is to use shortest path routing and to minimise the number of intermediate routers to reach each destination. more complex algorithms can take into account the expected load on the links to ensure that congestion does not occur for a given trafﬁc demand. these algorithms must all ensure that :
• all routers are conﬁgured with a route to reach each destination • none of the paths composed with the entries found in the routing tables contain a cycle. such a cycle would
the main drawback of static routing is that it does not adapt to the evolution of the network. when a new router or link is added, all routing tables must be recomputed. furthermore, when a link or router fails, the routing tables must be updated as well.
distance vector routing is a simple distributed routing protocol. distance vector routing allows routers to automatically discover the destinations reachable inside the network as well as the shortest path to reach each of these destinations. the shortest path is computed based on metrics or costs that are associated to each link. we use l.cost to represent the metric that has been conﬁgured for link l on a router. each router maintains a routing table. the routing table r can be modelled as a data structure that stores, for each known destination address d, the following attributes :
• r[d].link is the outgoing link that the router uses to forward packets towards destination d • r[d].cost is the sum of the metrics of the links that compose the shortest path to reach destination d • r[d].time is the timestamp of the last distance vector containing destination d
a router that uses distance vector routing regularly sends its distance vector over all its interfaces. the distance vector is a summary of the router’s routing table that indicates the distance towards each known destination. this distance vector can be computed from the routing table by using the pseudo-code below.
when a router boots, it does not know any destination in the network and its routing table only contains itself. it thus sends to all its neighbours a distance vector that contains only its address at a distance of 0. when a router receives a distance vector on link l, it processes it as follows.
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
• the ip address of any host residing directly inside domain dom (e.g. h2.dom in the ﬁgure above) • the nameserver(s) that are responsible for any direct sub-domain of domain dom (i.e. sdom1.dom and
to retrieve the mapping for host h2.dom, a client sends its query to the name server that is responsible for domain .dom. the name server directly answers the query. to retrieve a mapping for h3.a.sdom1.dom a dns client ﬁrst sends a query to the name server that is responsible for the .dom domain. this nameserver returns the nameserver that is responsible for the sdom1.dom domain. this nameserver can now be contacted to obtain the nameserver that is responsible for the a.sdom1.dom domain. this nameserver can be contacted to retrieve the mapping for the h3.a.sdom1.dom name. thanks to this organisation of the nameservers, it is possible for a dns client to obtain the mapping of any host inside the .dom domain or any of its subdomains. to ensure that any dns client will be able to resolve any fully qualiﬁed domain name, there are special nameservers that are responsible for the root of the domain name hierarchy. these nameservers are called root nameserver. there are currently about a dozen root nameservers 6. each root nameserver maintains the list 7 of all the nameservers that are responsible for each of the top-level domain names and their ip addresses 8. all root nameservers are synchronised and provide the same answers. by querying any of the root nameservers, a dns client can obtain the nameserver that is responsible for any top-level-domain name. from this nameserver, it is possible to resolve any domain name. to be able to contact the root nameservers, each dns client must know their ip addresses. this implies, that dns clients must maintain an up-to-date list of the ip addresses of the root nameservers 9. without this list, it is impossible to contact the root nameservers. forcing all internet hosts to maintain the most recent version of this list would be difﬁcult from an operational point of view. to solve this problem, the designers of the dns the dns resolvers. a resolver is a server that provides the name introduced a special type of dns server : resolution service for a set of clients. a network usually contains a few resolvers. each host in these networks is conﬁgured to send all its dns queries via one of its local resolvers. these queries are called recursive queries as the resolver must recurse through the hierarchy of nameservers to obtain the answer. dns resolvers have several advantages over letting each internet host query directly nameservers. firstly, regular internet hosts do not need to maintain the up-to-date list of the ip addresses of the root servers. secondly, regular internet hosts do not need to send queries to nameservers all over the internet. furthermore, as a dns resolver serves a large number of hosts, it can cache the received answers. this allows the resolver to quickly return answers for popular dns queries and reduces the load on all dns servers [jsbm2002]. the last component of the domain name system is the dns protocol. the dns protocol runs above both the datagram service and the bytestream services. in practice, the datagram service is used when short queries and responses are exchanged, and the bytestream service is used when longer responses are expected. in this section, we will only discuss the utilisation of the dns protocol above the datagram service. this is the most frequent utilisation of the dns. dns messages are composed of ﬁve parts that are named sections in rfc 1035. the ﬁrst three sections are mandatory and the last two sections are optional. the ﬁrst section of a dns message is its header. it contains information about the type of message and the content of the other sections. the second section contains the question sent to the name server or resolver. the third section contains the answer to the question. when a client sends a dns query, the answer section is empty. the fourth section, named authority, contains information about the servers that can provide an authoritative answer if required. the last section contains additional information that is supplied by the resolver or server but was not requested in the question. the header of dns messages is composed of 12 bytes and its structure is shown in the ﬁgure below. the id (identiﬁer) is a 16-bits random value chosen by the client. when a client sends a question to a dns server, it remembers the question and its identiﬁer. when a server returns an answer, it returns in the id ﬁeld the identiﬁer
7 a copy of the information maintained by each root nameserver is available at http://www.internic.net/zones/root.zone 8 until february 2008, the root dns servers only had ipv4 addresses. ipv6 addresses were added to the root dns servers slowly to avoid creating problems as discussed in http://www.icann.org/en/committees/security/sac018.pdf in 2010, several dns root servers are still not reachable by using ipv6.
the easiest way to understand the operation of arp is to consider the simple network shown above and assume that host 10.0.1.22/24 needs to send an ipv4 packet to host 10.0.1.8. as this ip address belongs to the same subnet, the packet must be sent directly to its destination via the datalink layer service. to use this service, the sending host must ﬁnd the datalink layer address that is attached to host 10.0.1.8. each ipv4 host maintains an arp cache containing the list of all mappings between ipv4 addresses and datalink layer addresses that it knows. when an ipv4 hosts boots, its arp cache is empty. 10.0.1.22 thus ﬁrst consults its arp cache. as the cache does not contain the requested mapping, host 10.0.1.22 sends a broadcast arp query frame on the lan. the frame contains the datalink layer address of the sending host (a) and the requested ipv4 address (10.0.1.8). this broadcast frame is received by all devices on the lan and only the host that owns the requested ipv4 address replies by returning a unicast arp reply frame with the requested mapping. upon reception of this reply, the sending host updates its arp cache and sends the ipv4 packet by using the datalink layer service. to deal with devices that move or whose addresses are reconﬁgured, most arp implementations remove the cache entries that have not been used for a few minutes. some implementations re-validate arp cache entries from time to time by sending arp queries 13.
note: security issues with the address resolution protocol arp is an old and widely used protocol that was unfortunately designed when security issues were not a concern. arp is almost insecure by design. hosts using arp can be subject to several types of attack. first, a malicious host could create a denial of service attack on a lan by sending random replies to the received arp queries. this would pollute the arp cache of the other hosts on the same lan. on a ﬁxed network, such attacks can be detected by the system administrator who can physically remove the malicious hosts from the lan. on a wireless network, removing a malicious host is much more difﬁcult. a second type of attack are the man-in-the-middle attacks. this name is used for network attacks where the attacker is able to read and possibly modify all the messages sent by the attacked devices. such an attack is possible in a lan. assume, in the ﬁgure above, that host 10.0.1.9 is malicious and would like to receive and modify all the packets sent by host 10.0.1.22 to host 10.0.1.8. this can be achieved easily if host 10.0.1.9 manages, by sending fake arp replies, to convince host 10.0.1.22 (resp. 10.0.1.8) that its own datalink layer address must be used to reach 10.0.1.8 (resp. 10.0.1.22).
arp is used by all devices that are connected to a lan and implement ipv4. both routers and endhosts implement arp. when a host needs to send an ipv4 packet to a destination outside of its local subnet, it must ﬁrst send the packet to one of the routers that reside on this subnet. consider for example the network shown in the ﬁgure below. each host is conﬁgured with an ipv4 address in the 10.0.1.0/24 subnet and uses 10.0.1.1 as its default router. to send a packet to address 1.2.3.4, host 10.0.1.8 will ﬁrst need to know the datalink layer of the default router. it will thus send an arp request for 10.0.1.1. upon reception of the arp reply, host 10.0.1.8 updates its arp table and sends its packet in a frame to its default router. the router will then forward the packet towards its ﬁnal destination.
in the early days of the internet, ip addresses were manually conﬁgured on both hosts and routers and almost never changed. however, this manual conﬁguration can be complex 14 and often causes errors that are sometimes difﬁcult to debug. recent tcp/ip implementations are able to detect some of these misconﬁgurations. for example, if two hosts are attached to the same subnet with the same ipv4 address they will be unable to communicate. to detect this problem hosts send an arp request for their conﬁgured address each time their addressed is changed rfc 5227. if they receive an answer to this arp request, they trigger an alarm or inform the system administrator.
13 see chapter 28 of [benvenuti2005] for a description of the implementation of arp in the linux kernel. 14 for example, consider all the options that can be speciﬁed for the ifconﬁg utility<http://en.wikipedia.org/wiki/ifconﬁg> on unix hosts.
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
the best solution to allow bgp routers to distribute, inside an as, all the routes learned over bgp sessions is to establish bgp sessions among all the bgp routers inside the as. in practice, there are two types of bgp sessions :
in practice, each bgp router inside a domain maintains an ibgp session with every other bgp router in the domain 34. this creates a full-mesh of ibgp sessions among all bgp routers of the domain. ibgp sessions, like ebgp sessions run over tcp connections. note that in contrast with ebgp sessions that are established between directly connected routers, ibgp sessions are often established between routers that are not directly connected. an important point to note about ibgp sessions is that a bgp router only advertises a route over an ibgp session provided that :
a bgp router does not advertise a route that it has learned over an ibgp session over another ibgp session. note that a router can, of course, advertise over an ebgp session a route that it has learned over an ibgp session. this difference between the behaviour of a bgp router over ibgp and ebgp session is due to the utilisation of a full-mesh of ibgp sessions. consider a network containing three bgp routers : a, b and c interconnected via a full-mesh of ibgp sessions. if router a learns a route towards preﬁx p from router b, router a does not need to advertise the received route to router c since router c also learns the same route over the c-b ibgp session. let us consider what happens when router r1 sends to understand the utilisation of an ibgp session, u(194.100.0.0/23,195.100.0.1,as10) in the network shown below. this bgp message is processed by r2 which advertises it over its ibgp session with r4. the bgp update sent by r2 contains the same nexthop and the same as-path as in the bgp update received by r2. r4 then sends u(194.100.0.0/23,195.100.0.5,as20:as10) to r3. note that the bgp nexthop and the as-path are only updated 35 when a bgp route is advertised over an ebgp session.
note: loopback interfaces and ibgp sessions in addition to their physical interfaces, routers can also be conﬁgured with a special loopback interface. a loopback interface is a software interface that is always up. when a loopback interface is conﬁgured on a router, the address associated to this interface is advertised by the intradomain routing protocol. consider for example
34 using a full-mesh of ibgp sessions is suitable in small networks. however, this solution does not scale in large networks containing ibgp sessions must be established in a domain containing n bgp routers. large domains use either
hundreds or more routers since n×(n−1) route reﬂection rfc 4456 or confederations rfc 5065 to scale their ibgp, but this goes beyond this introduction.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.8/30195.100.0.9195.100.0.10ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
slot time is the optimal delay since it is the shortest delay that ensures that the ﬁrst host will be able to retransmit its frame completely without any collision. if two hosts are competing, the algorithm above will avoid a second collision 50% of the time. however, if the network is heavily loaded, several hosts may be competing at the same time. in this case, the hosts should be able to automatically adapt their retransmission delay. the binary exponential back-off performs this adaptation based on the number of collisions that have affected a frame. after the ﬁrst collision, the host ﬂips a coin and waits 0 or 1 slot time. after the second collision, it generates a random number and waits 0, 1, 2 or 3 slot times, etc. the duration of the waiting time is doubled after each collision. the complete pseudo-code for the csma/cd algorithm is shown in the ﬁgure below.
the inter-frame delay used in this pseudo-code is a short delay corresponding to the time required by a network adapter to switch from transmit to receive mode. it is also used to prevent a host from sending a continuous stream of frames without leaving any transmission opportunities for other hosts on the network. this contributes to the fairness of csma/cd. despite this delay, there are still conditions where csma/cd is not completely fair [ry1994]. consider for example a network with two hosts : a server sending long frames and a client sending acknowledgments. measurements reported in [ry1994] have shown that there are situations where the client could suffer from repeated collisions that lead it to wait for long periods of time due to the exponential back-off algorithm.
the carrier sense multiple access with collision avoidance (csma/ca) medium access control algorithm was designed for the popular wifi wireless network technology [802.11]. csma/ca also senses the transmission channel before transmitting a frame. furthermore, csma/ca tries to avoid collisions by carefully tuning the timers used by csma/ca devices. csma/ca uses acknowledgements like csma. each frame contains a sequence number and a crc. the crc is used to detect transmission errors while the sequence number is used to avoid frame duplication. when a device receives a correct frame, it returns a special acknowledgement frame to the sender. csma/ca introduces a small delay, named short inter frame spacing (sifs), between the reception of a frame and the transmission of the acknowledgement frame. this delay corresponds to the time that is required to switch the radio of a device between the reception and transmission modes. compared to csma, csma/ca deﬁnes more precisely when a device is allowed to send a frame. first, csma/ca deﬁnes two delays : difs and eifs. to send a frame, a device must ﬁrst wait until the channel has been idle for at least the distributed coordination function inter frame space (difs) if the previous frame was received correctly. however, if the previously received frame was corrupted, this indicates that there are collisions and the device must sense the channel idle for at least the extended inter frame space (eifs), with sif s < dif s < eif s. the exact values for sifs, difs and eifs depend on the underlying physical layer [802.11].
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
note: reliability of the connection-oriented service an important point to note about the connection-oriented service is its reliability. a connection-oriented service can only guarantee the correct delivery of all sdus provided that the connection has been released gracefully. this implies that while the connection is active, there is no guarantee for the actual delivery of the sdus exchanged as the connection may need to be released abruptly at any time.
given the growing complexity of computer networks, during the 1970s network researchers proposed various reference models to facilitate the description of network protocols and services. of these, the open systems interconnection (osi) model [zimmermann80] was probably the most inﬂuential. it served as the basis for the standardisation work performed within the iso to develop global computer network standards. the reference model that we use in this book can be considered as a simpliﬁed version of the osi reference model 4.
our reference model is divided into ﬁve layers, as shown in the ﬁgure below. starting from the bottom, the ﬁrst layer is the physical layer. two communicating devices are linked through a physical medium. this physical medium is used to transfer an electrical or optical signal between two directly connected devices. several types of physical mediums are used in practice :
• electrical cable. information can be transmitted over different types of electrical cables. the most common ones are the twisted pairs that are used in the telephone network, but also in enterprise networks and coaxial cables. coaxial cables are still used in cable tv networks, but are no longer used in enterprise networks. some networking technologies operate over the classical electrical cable.
• optical ﬁber. optical ﬁbers are frequently used in public and enterprise networks when the distance between the communication devices is larger than one kilometer. there are two main types of optical ﬁbers : multimode and monomode. multimode is much cheaper than monomode ﬁber because a led can be
sourceproviderdestinationtimedata.request("a")source -> destinationconnection closedconnection openedconnection openeddata.request("b")data.request("c")data.indication("a")data.indication("b")disconnect.req(graceful)disconnect.ind(graceful)data.indication("c")data.indication("d")data.request("d")disconnect.ind(graceful)disconnect.req(graceful)connection closedconnection closedsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
• client software, that allows users to easily create and read email messages • software, that allows servers to efﬁciently exchange email messages
we will ﬁrst discuss the format of email messages followed by the protocols that are used on today’s internet to exchange and retrieve emails. other email systems have been developed in the past [bush1993] [genilloud1990] [gc2000], but today most email solutions have migrated to the internet email. information about the software that is used to compose and deliver emails may be found on wikipedia among others, for both email clients and email servers. more detailed information about the full internet mail architecture may be found in rfc 5598. email messages, like postal mail, are composed of two parts :
• a header that plays the same role as the letterhead in regular mail. it contains metadata about the message. • the body that contains the message itself.
email messages are entirely composed of lines of ascii characters. each line can contain up to 998 characters and is terminated by the cr and lf control characters rfc 5322. the lines that compose the header appear before the message body. an empty line, containing only the cr and lf characters, marks the end of the header. this is illustrated in the ﬁgure below.
the email header contains several lines that all begin with a keyword followed by a colon and additional information. the format of email messages and the different types of header lines are deﬁned in rfc 5322. two of these header lines are mandatory and must appear in all email messages :
• the sender address. this header line starts with from:. this contains the (optional) name of the sender followed by its email address between < and >. email addresses are always composed of a username followed by the @ sign and a domain name.
• the date. this header line starts with date:. rfc 5322 precisely deﬁnes the format used to encode a date. other header lines appear in most email messages. the subject: header line allows the sender to indicate the topic discussed in the email. three types of header lines can be used to specify the recipients of a message :
• the cc: header line is used by the sender to provide a list of email addresses that must receive a carbon copy of the message. several addresses can be listed in this header line, separated by commas. all recipients of the email message receive the to: and cc: header lines.
• the bcc: header line is used by the sender to provide a list of comma separated email addresses that must receive a blind carbon copy of the message. the bcc: header line is not delivered to the recipients of the email message.
the ﬁrst problem faced by a token ring network is that as the token represents the authorization to transmit, it must continuously travel on the ring when no data frame is being transmitted. let us assume that a token has been produced and sent on the ring by one station. in token ring networks, the token is a 24 bits frame whose structure is shown below.
the token is composed of three ﬁelds. first, the starting delimiter is the marker that indicates the beginning of a frame. the ﬁrst token ring networks used manchester coding and the starting delimiter contained both symbols representing 0 and symbols that do not represent bits. the last ﬁeld is the ending delimiter which marks the end of the token. the access control ﬁeld is present in all frames, and contains several ﬂags. the most important is the token bit that is set in token frames and reset in other frames. let us consider the ﬁve station network depicted in ﬁgure a token ring network above and assume that station s1 sends a token. if we neglect the propagation delay on the inter-station links, as each station introduces a one bit delay, the ﬁrst bit of the frame would return to s1 while it sends the ﬁfth bit of the token. if station s1 is powered off at that time, only the ﬁrst ﬁve bits of the token will travel on the ring. to avoid this problem, there is a special station called the monitor on each token ring. to ensure that the token can travel forever on the ring, this monitor inserts a delay that is equal to at least 24 bit transmission times. if station s3 was the monitor in ﬁgure a token ring network, s1 would have been able to transmit the entire token before receiving the ﬁrst bit of the token from its upstream neighbour. now that we have explained how the token can be forwarded on the ring, let us analyse how a station can capture a token to transmit a data frame. for this, we need some information about the format of the data frames. an 802.5 data frame begins with the starting delimiter followed by the access control ﬁeld whose token bit is reset, a frame control ﬁeld that allows for the deﬁnition of several types of frames, destination and source address, a payload, a crc, the ending delimiter and a frame status ﬁeld. the format of the token ring data frames is illustrated below.
to capture a token, a station must operate in listen mode. in this mode, the station receives bits from its upstream neighbour. if the bits correspond to a data frame, they must be forwarded to the downstream neighbour. if they correspond to a token, the station can capture it and transmit its data frame. both the data frame and the token are encoded as a bit string beginning with the starting delimiter followed by the access control ﬁeld. when the station receives the ﬁrst bit of a starting delimiter, it cannot know whether this is a data frame or a token and
microseconds slot time. if the delay is longer, collisions between short frames may not be correctly detected. this constraint limits the geographical spread of 10baset networks containing hubs.
in the late 1980s, 10 mbps became too slow for some applications and network manufacturers developed several lan technologies that offered higher bandwidth, such as the 100 mbps fddi lan that used optical ﬁbers. as the development of 10base5, 10base2 and 10baset had shown that ethernet could be adapted to different physical layers, several manufacturers started to work on 100 mbps ethernet and convinced ieee to standardise this new technology that was initially called fast ethernet. fast ethernet was designed under two constraints. first, fast ethernet had to support twisted pairs. although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. second, fast ethernet had to be perfectly compatible with the existing 10 mbps ethernets to allow fast ethernet technology to be used initially as a backbone technology to interconnect 10 mbps ethernet networks. this forced fast ethernet to use exactly the same frame format as 10 mbps ethernet. this implied that the minimum fast ethernet frame size remained at 512 bits. to preserve csma/cd with this minimum frame size and 100 mbps instead of 10 mbps, the duration of the slot time was decreased to 5.12 microseconds. the evolution of ethernet did not stop. in 1998, the ieee published a ﬁrst standard to provide gigabit ethernet over optical ﬁbers. several other types of physical layers were added afterwards. the 10 gigabit ethernet standard appeared in 2002. work is ongoing to develop standards for 40 gigabit and 100 gigabit ethernet and some are thinking about terabit ethernet. the table below lists the main ethernet standards. a more detailed list may be found at http://en.wikipedia.org/wiki/ethernet_physical_layer
comments thick coaxial cable, 500m thin coaxial cable, 185m two pairs of category 3+ utp 10 mb/s over optical ﬁber category 5 utp or stp, 100 m maximum two multimode optical ﬁber, 2 km maximum
standard 10base5 10base2 10baset 10base-f 100base-tx 100base-fx 1000base-cx two pairs shielded twisted pair, 25m maximum 1000base-sx two multimode or single mode optical ﬁbers with lasers 10 gbps 40-100 gbps
increasing the physical layer bandwidth as in fast ethernet was only one of the solutions to improve the performance of ethernet lans. a second solution was to replace the hubs with more intelligent devices. as ethernet hubs operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach
address. as this address is placed at the beginning of the frame, an ethernet interface can quickly verify whether it is the frame recipient and if not, cancel the processing of the arriving frame. the second ﬁeld is the source address. while the destination address can be either a unicast or a multicast/broadcast address, the source address must always be a unicast address. the third ﬁeld is a 16 bits integer that indicates which type of network layer packet is carried inside the frame. this ﬁeld is often called the ethertype. frequently used ethertype values 6 include 0x0800 for ipv4, 0x86dd for ipv6 7 and 0x806 for the address resolution protocol (arp). the fourth part of the ethernet frame is the payload. the minimum length of the payload is 46 bytes to ensure a minimum frame size, including the header of 512 bits. the ethernet payload cannot be longer than 1500 bytes. this size was found reasonable when the ﬁrst ethernet speciﬁcation was written. at that time, xerox had been using its experimental 3 mbps ethernet that offered 554 bytes of payload and rfc 1122 required a minimum mtu of 572 bytes for ipv4. 1500 bytes was large enough to support these needs without forcing the network adapters to contain overly large memories. furthermore, simulations and measurement studies performed in ethernet networks revealed that csma/cd was able to achieve a very high utilization. this is illustrated in the ﬁgure below based on [sh1980], which shows the channel utilization achieved in ethernet networks containing different numbers of hosts that are sending frames of different sizes.
the last ﬁeld of the ethernet frame is a 32 bit cyclical redundancy check (crc). this crc is able to catch a much larger number of transmission errors than the internet checksum used by ip, udp and tcp [sgp98]. the format of the ethernet frame is shown below.
note: where should the crc be located in a frame ? the transport and datalink layers usually chose different strategies to place their crcs or checksums. transport layer protocols usually place their crcs or checksums in the segment header. datalink layer protocols sometimes place their crc in the frame header, but often in a trailer at the end of the frame. this choice reﬂects implementation assumptions, but also inﬂuences performance rfc 893. when the crc is placed in the trailer, as in ethernet, the datalink layer can compute it while transmitting the frame and insert it at the end of the transmission. all ethernet interfaces use this optimisation today. when the checksum is placed in the header, as in a tcp segment, it is impossible for the network interface to compute it while transmitting the segment. some network interfaces provide hardware assistance to compute the tcp checksum, but this is more complex than if the tcp checksum were placed in the trailer 8.
6 the ofﬁcial list of all assigned ethernet type values is available from http://standards.ieee.org/regauth/ethertype/eth.txt 7 the attentive reader may question the need for different ethertypes for ipv4 and ipv6 while the ip header already contains a version ﬁeld that can be used to distinguish between ipv4 and ipv6 packets. theoretically, ipv4 and ipv6 could have used the same ethertype. unfortunately, developers of the early ipv6 implementations found that some devices did not check the version ﬁeld of the ipv4 packets that they received and parsed frames whose ethertype was set to 0x0800 as ipv4 packets. sending ipv6 packets to such devices would have caused disruptions. to avoid this problem, the ietf decided to apply for a distinct ethertype value for ipv6.
[unicast, multicast and broadcast. while the ethernet service is unreliable in theory, a good ethernet network should, in practice, provide a service that :]
the ﬁrst property is a consequence of the utilisation of csma/cd. the second property is a consequence of the physical organisation of the ethernet network as a shared bus. these two properties are important and all evolutions of the ethernet technology have preserved them.
several physical layers have been deﬁned for ethernet networks. the ﬁrst physical layer, usually called 10base5, provided 10 mbps over a thick coaxial cable. the characteristics of the cable and the transceivers that were used then enabled the utilisation of 500 meter long segments. a 10base5 network can also include repeaters between segments. the second physical layer was 10base2. this physical layer used a thin coaxial cable that was easier to install than the 10base5 cable, but could not be longer than 185 meters. a 10basef physical layer was also deﬁned to transport ethernet over point-to-point optical links. the major change to the physical layer was the support of twisted pairs in the 10baset speciﬁcation. twisted pair cables are traditionally used to support the telephone service in ofﬁce buildings. most ofﬁce buildings today are equipped with structured cabling. several twisted pair cables are installed between any room and a central telecom closet per building or per ﬂoor in large buildings. these telecom closets act as concentration points for the telephone service but also for lans. the introduction of the twisted pairs led to two major changes to ethernet. the ﬁrst change concerns the physical topology of the network. 10base2 and 10base5 networks are shared buses, the coaxial cable typically passes through each room that contains a connected computer. a 10baset network is a star-shaped network. all the devices connected to the network are attached to a twisted pair cable that ends in the telecom closet. from a maintenance perspective, this is a major improvement. the cable is a weak point in 10base2 and 10base5 networks. any physical damage on the cable broke the entire network and when such a failure occurred, the network administrator had to manually check the entire cable to detect where it was damaged. with 10baset, when one twisted pair is damaged, only the device connected to this twisted pair is affected and this does not affect the other devices. the second major change introduced by 10baset was that is was impossible to build a 10baset network by simply connecting all the twisted pairs together. all the twisted pairs must be connected to a relay that operates in the physical layer. this relay is called an ethernet hub. a hub is thus a physical layer relay that receives an electrical signal on one of its interfaces, regenerates the signal and transmits it over all its other interfaces. some hubs are also able to convert the electrical signal from one physical layer to another (e.g. 10baset to 10base2 conversion).
computers can directly be attached to ethernet hubs. ethernet hubs themselves can be attached to other ethernet hubs to build a larger network. however, some important guidelines must be followed when building a complex network with hubs. first, the network topology must be a tree. as hubs are relays in the physical layer, adding a link between hub2 and hub3 in the network below would create an electrical shortcut that would completely disrupt the network. this implies that there cannot be any redundancy in a hub-based network. a failure of a hub or of a link between two hubs would partition the network into two isolated networks. second, as hubs are relays in the physical layer, collisions can happen and must be handled by csma/cd as in a 10base5 network. this implies that the maximum delay between any pair of devices in the network cannot be longer than the 51.2
microseconds slot time. if the delay is longer, collisions between short frames may not be correctly detected. this constraint limits the geographical spread of 10baset networks containing hubs.
in the late 1980s, 10 mbps became too slow for some applications and network manufacturers developed several lan technologies that offered higher bandwidth, such as the 100 mbps fddi lan that used optical ﬁbers. as the development of 10base5, 10base2 and 10baset had shown that ethernet could be adapted to different physical layers, several manufacturers started to work on 100 mbps ethernet and convinced ieee to standardise this new technology that was initially called fast ethernet. fast ethernet was designed under two constraints. first, fast ethernet had to support twisted pairs. although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. second, fast ethernet had to be perfectly compatible with the existing 10 mbps ethernets to allow fast ethernet technology to be used initially as a backbone technology to interconnect 10 mbps ethernet networks. this forced fast ethernet to use exactly the same frame format as 10 mbps ethernet. this implied that the minimum fast ethernet frame size remained at 512 bits. to preserve csma/cd with this minimum frame size and 100 mbps instead of 10 mbps, the duration of the slot time was decreased to 5.12 microseconds. the evolution of ethernet did not stop. in 1998, the ieee published a ﬁrst standard to provide gigabit ethernet over optical ﬁbers. several other types of physical layers were added afterwards. the 10 gigabit ethernet standard appeared in 2002. work is ongoing to develop standards for 40 gigabit and 100 gigabit ethernet and some are thinking about terabit ethernet. the table below lists the main ethernet standards. a more detailed list may be found at http://en.wikipedia.org/wiki/ethernet_physical_layer
comments thick coaxial cable, 500m thin coaxial cable, 185m two pairs of category 3+ utp 10 mb/s over optical ﬁber category 5 utp or stp, 100 m maximum two multimode optical ﬁber, 2 km maximum
standard 10base5 10base2 10baset 10base-f 100base-tx 100base-fx 1000base-cx two pairs shielded twisted pair, 25m maximum 1000base-sx two multimode or single mode optical ﬁbers with lasers 10 gbps 40-100 gbps
increasing the physical layer bandwidth as in fast ethernet was only one of the solutions to improve the performance of ethernet lans. a second solution was to replace the hubs with more intelligent devices. as ethernet hubs operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach
deﬁned and implemented. when isps started to upgrade their physical infrastructure to provide internet access over asymmetric digital subscriber lines (adsl), they tried to reuse their existing authentication (and billing) systems. to meet these requirements, the ietf developed speciﬁcations to allow ppp frames to be transported over other networks than the point-to-point links for which ppp was designed. nowadays, most adsl deployments use ppp over either atm rfc 2364 or ethernet rfc 2516.
ethernet was designed in the 1970s at the palo alto research center [metcalfe1976]. the ﬁrst prototype 4 used a coaxial cable as the shared medium and 3 mbps of bandwidth. ethernet was improved during the late 1970s and in the 1980s, digital equipment, intel and xerox published the ﬁrst ofﬁcial ethernet speciﬁcation [dix]. this speciﬁcation deﬁnes several important parameters for ethernet networks. the ﬁrst decision was to standardise the commercial ethernet at 10 mbps. the second decision was the duration of the slot time. in ethernet, a long slot time enables networks to span a long distance but forces the host to use a larger minimum frame size. the compromise was a slot time of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes. the third decision was the frame format. the experimental 3 mbps ethernet network built at xerox used short frames containing 8 bit source and destination addresses ﬁelds, a 16 bit type indication, up to 554 bytes of payload and a 16 bit crc. using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. although the initial ethernet speciﬁcation [dix] only allowed up to 1024 hosts on an ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. the ﬁrst change was to require each host attached to an ethernet network to have a globally unique datalink layer address. until then, datalink layer addresses were manually conﬁgured on each host. [dp1981] went against that state of the art and noted “suitable installation-speciﬁc administrative procedures are also needed for assigning numbers to hosts on a network. if a host is moved from one network to another it may be necessary to change its host number if its former number is in use on the new network. this is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). it is anticipated that in future ofﬁce environments, hosts locations will change as often as telephones are changed in present-day ofﬁces.” the second change introduced by ethernet was to encode each address as a 48 bits ﬁeld [dp1981]. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages [dp1981] including the ability to allocate large blocks of addresses to manufacturers. eventually, other lan technologies opted for 48 bits addresses as well [802]_ . the third change introduced by ethernet was the deﬁnition of broadcast and multicast addresses. the need for multicast ethernet was foreseen in [dp1981] and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer. the datalink layer addresses used in ethernet networks are often called mac addresses. they are structured as shown in the ﬁgure below. the ﬁrst bit of the address indicates whether the address identiﬁes a network adapter or a multicast group. the upper 24 bits are used to encode an organisation unique identiﬁer (oui). this oui identiﬁes a block of addresses that has been allocated by the secretariat 5 who is responsible for the uniqueness of ethernet addresses to a manufacturer. once a manufacturer has received an oui, it can build and sell products with one of the 16 million addresses in this block.
the original 10 mbps ethernet speciﬁcation [dix] deﬁned a simple frame format where each frame is composed of ﬁve ﬁelds. the ethernet frame starts with a preamble (not shown in the ﬁgure below) that is used by the physical layer of the receiver to synchronise its clock with the sender’s clock. the ﬁrst ﬁeld of the frame is the destination
4 additional information about the history of the ethernet technology may be found at http://ethernethistory.typepad.com/ 5 initially, the ouis were allocated by xerox [dp1981]. however, once ethernet became an ieee and later an iso standard, the allocation
deﬁned and implemented. when isps started to upgrade their physical infrastructure to provide internet access over asymmetric digital subscriber lines (adsl), they tried to reuse their existing authentication (and billing) systems. to meet these requirements, the ietf developed speciﬁcations to allow ppp frames to be transported over other networks than the point-to-point links for which ppp was designed. nowadays, most adsl deployments use ppp over either atm rfc 2364 or ethernet rfc 2516.
ethernet was designed in the 1970s at the palo alto research center [metcalfe1976]. the ﬁrst prototype 4 used a coaxial cable as the shared medium and 3 mbps of bandwidth. ethernet was improved during the late 1970s and in the 1980s, digital equipment, intel and xerox published the ﬁrst ofﬁcial ethernet speciﬁcation [dix]. this speciﬁcation deﬁnes several important parameters for ethernet networks. the ﬁrst decision was to standardise the commercial ethernet at 10 mbps. the second decision was the duration of the slot time. in ethernet, a long slot time enables networks to span a long distance but forces the host to use a larger minimum frame size. the compromise was a slot time of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes. the third decision was the frame format. the experimental 3 mbps ethernet network built at xerox used short frames containing 8 bit source and destination addresses ﬁelds, a 16 bit type indication, up to 554 bytes of payload and a 16 bit crc. using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. although the initial ethernet speciﬁcation [dix] only allowed up to 1024 hosts on an ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. the ﬁrst change was to require each host attached to an ethernet network to have a globally unique datalink layer address. until then, datalink layer addresses were manually conﬁgured on each host. [dp1981] went against that state of the art and noted “suitable installation-speciﬁc administrative procedures are also needed for assigning numbers to hosts on a network. if a host is moved from one network to another it may be necessary to change its host number if its former number is in use on the new network. this is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). it is anticipated that in future ofﬁce environments, hosts locations will change as often as telephones are changed in present-day ofﬁces.” the second change introduced by ethernet was to encode each address as a 48 bits ﬁeld [dp1981]. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages [dp1981] including the ability to allocate large blocks of addresses to manufacturers. eventually, other lan technologies opted for 48 bits addresses as well [802]_ . the third change introduced by ethernet was the deﬁnition of broadcast and multicast addresses. the need for multicast ethernet was foreseen in [dp1981] and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer. the datalink layer addresses used in ethernet networks are often called mac addresses. they are structured as shown in the ﬁgure below. the ﬁrst bit of the address indicates whether the address identiﬁes a network adapter or a multicast group. the upper 24 bits are used to encode an organisation unique identiﬁer (oui). this oui identiﬁes a block of addresses that has been allocated by the secretariat 5 who is responsible for the uniqueness of ethernet addresses to a manufacturer. once a manufacturer has received an oui, it can build and sell products with one of the 16 million addresses in this block.
the original 10 mbps ethernet speciﬁcation [dix] deﬁned a simple frame format where each frame is composed of ﬁve ﬁelds. the ethernet frame starts with a preamble (not shown in the ﬁgure below) that is used by the physical layer of the receiver to synchronise its clock with the sender’s clock. the ﬁrst ﬁeld of the frame is the destination
4 additional information about the history of the ethernet technology may be found at http://ethernethistory.typepad.com/ 5 initially, the ouis were allocated by xerox [dp1981]. however, once ethernet became an ieee and later an iso standard, the allocation
• rto : the retransmission timeout is computed as rto = min(60, max(1, β × srtt)) where β is used to take into account the delay variance (value : 1.3 to 2.0). the 60 and 1 constants are used to ensure that the rto is not larger than one minute nor smaller than 1 second.
however, in practice, this computation for the retransmission timeout did not work well. the main problem was that the computed rto did not correctly take into account the variations in the measured round-trip-time. van jacobson proposed in his seminal paper [jacobson1988] an improved algorithm to compute the rto and implemented it in the bsd unix distribution. this algorithm is now part of the tcp standard rfc 2988. jacobson’s algorithm uses two state variables, srtt the smoothed rtt and rttvar the estimation of the variance of the rtt and two parameters : α and β. when a tcp connection starts, the ﬁrst rto is set to 3 seconds. when a ﬁrst estimation of the rtt is available, the srtt, rttvar and rto are computed as
the proposed values for the parameters are α = 1 4. this allows a tcp implementation, implemented in the kernel, to perform the rtt computation by using shift operations instead of the more costly ﬂoating point operations [jacobson1988]. the ﬁgure below illustrates the computation of the rto upon rtt changes.
the default go-back-n retransmission strategy was deﬁned in rfc 793. when the retransmission timer expires, tcp retransmits the ﬁrst unacknowledged segment (i.e. the one having sequence number snd.una). after each expiration of the retransmission timeout, rfc 2988 recommends to double the value of the retransmission timeout. this is called an exponential backoff. this doubling of the retransmission timeout after a retransmission was included in tcp to deal with issues such as network/receiver overload and incorrect initial estimations of the retransmission timeout. if the same segment is retransmitted several times, the retransmission timeout is doubled after every retransmission until it reaches a conﬁgured maximum. rfc 2988 suggests a maximum retransmission timeout of at least 60 seconds. once the retransmission timeout reaches this conﬁgured maximum, the remote host is considered to be unreachable and the tcp connection is closed. this retransmission strategy has been reﬁned based on the experience of using tcp on the internet. the ﬁrst reﬁnement was a clariﬁcation of the strategy used to send acknowledgements. as tcp uses piggybacking, the
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
slot time is the optimal delay since it is the shortest delay that ensures that the ﬁrst host will be able to retransmit its frame completely without any collision. if two hosts are competing, the algorithm above will avoid a second collision 50% of the time. however, if the network is heavily loaded, several hosts may be competing at the same time. in this case, the hosts should be able to automatically adapt their retransmission delay. the binary exponential back-off performs this adaptation based on the number of collisions that have affected a frame. after the ﬁrst collision, the host ﬂips a coin and waits 0 or 1 slot time. after the second collision, it generates a random number and waits 0, 1, 2 or 3 slot times, etc. the duration of the waiting time is doubled after each collision. the complete pseudo-code for the csma/cd algorithm is shown in the ﬁgure below.
the inter-frame delay used in this pseudo-code is a short delay corresponding to the time required by a network adapter to switch from transmit to receive mode. it is also used to prevent a host from sending a continuous stream of frames without leaving any transmission opportunities for other hosts on the network. this contributes to the fairness of csma/cd. despite this delay, there are still conditions where csma/cd is not completely fair [ry1994]. consider for example a network with two hosts : a server sending long frames and a client sending acknowledgments. measurements reported in [ry1994] have shown that there are situations where the client could suffer from repeated collisions that lead it to wait for long periods of time due to the exponential back-off algorithm.
the carrier sense multiple access with collision avoidance (csma/ca) medium access control algorithm was designed for the popular wifi wireless network technology [802.11]. csma/ca also senses the transmission channel before transmitting a frame. furthermore, csma/ca tries to avoid collisions by carefully tuning the timers used by csma/ca devices. csma/ca uses acknowledgements like csma. each frame contains a sequence number and a crc. the crc is used to detect transmission errors while the sequence number is used to avoid frame duplication. when a device receives a correct frame, it returns a special acknowledgement frame to the sender. csma/ca introduces a small delay, named short inter frame spacing (sifs), between the reception of a frame and the transmission of the acknowledgement frame. this delay corresponds to the time that is required to switch the radio of a device between the reception and transmission modes. compared to csma, csma/ca deﬁnes more precisely when a device is allowed to send a frame. first, csma/ca deﬁnes two delays : difs and eifs. to send a frame, a device must ﬁrst wait until the channel has been idle for at least the distributed coordination function inter frame space (difs) if the previous frame was received correctly. however, if the previously received frame was corrupted, this indicates that there are collisions and the device must sense the channel idle for at least the extended inter frame space (eifs), with sif s < dif s < eif s. the exact values for sifs, difs and eifs depend on the underlying physical layer [802.11].
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
depicted below which is similar to the one discussed in [jacobson1988] and rfc 896. in this network, we assume that the buffers of the router are inﬁnite to ensure that no packet is lost.
if many tcp senders are attached to the left part of the network above, they all send a window full of segments. these segments are stored in the buffers of the router before being transmitted towards their destination. if there are many senders on the left part of the network, the occupancy of the buffers quickly grows. a consequence of the buffer occupancy is that the round-trip-time, measured by tcp, between the sender and the receiver increases. consider a network where 10,000 bits segments are sent. when the buffer is empty, such a segment requires 1 millisecond to be transmitted on the 10 mbps link and 5 milliseconds to be the transmitted on the 2 mbps link. thus, the round-trip-time measured by tcp is roughly 6 milliseconds if we ignore the propagation delay on the links. most routers manage their buffers as a fifo queue 25. if the buffer contains 100 segments, the round-triptime becomes 1 + 100 × 5 + 5 milliseconds as new segments are only transmitted on the 2 mbps link once all previous segments have been transmitted. unfortunately, tcp uses a retransmission timer and performs go-back-n to recover from transmission errors. if the buffer occupancy is high, tcp assumes that some segments have been lost and retransmits a full window of segments. this increases the occupancy of the buffer and the delay through the buffer... furthermore, the buffer may store and send on the low bandwidth links several retransmissions of the same segment. this problem is called congestion collapse. it occurred several times in the late 1980s. for example, [jacobson1988] notes that in 1986, the usable bandwidth of a 32 kbits link dropped to 40 bits per second due to congestion collapse 26 ! the congestion collapse is a problem that all heterogeneous networks face. different mechanisms have been proposed in the scientiﬁc literature to avoid or control network congestion. some of them have been implemented and deployed in real networks. to understand this problem in more detail, let us ﬁrst consider a simple network with two hosts attached to a high bandwidth link that are sending segments to destination c attached to a low bandwidth link as depicted below.
to avoid congestion collapse, the hosts must regulate their transmission rate 27 by using a congestion control mechanism. such a mechanism can be implemented in the transport layer or in the network layer. in tcp/ip networks, it is implemented in the transport layer, but other technologies such as asynchronous transfer mode (atm) or frame relay include congestion control mechanisms in lower layers. let us ﬁrst consider the simple problem of a set of i hosts that share a single bottleneck link as shown in the example above. in this network, the congestion control scheme must achieve the following objectives [cj1989] :
25 we discuss in another chapter other possible organisations of the router’s buffers. 26 at this time, tcp implementations were mainly following rfc 791. the round-trip-time estimations and the retransmission mechanisms
27 in this section, we focus on congestion control mechanisms that regulate the transmission rate of the hosts. other types of mechanisms have been proposed in the literature. for example, credit-based ﬂow-control has been proposed to avoid congestion in atm networks [kr1995]. with a credit-based mechanism, hosts can only send packets once they have received credits from the routers and the credits depend on the occupancy of the router’s buffers.
microseconds slot time. if the delay is longer, collisions between short frames may not be correctly detected. this constraint limits the geographical spread of 10baset networks containing hubs.
in the late 1980s, 10 mbps became too slow for some applications and network manufacturers developed several lan technologies that offered higher bandwidth, such as the 100 mbps fddi lan that used optical ﬁbers. as the development of 10base5, 10base2 and 10baset had shown that ethernet could be adapted to different physical layers, several manufacturers started to work on 100 mbps ethernet and convinced ieee to standardise this new technology that was initially called fast ethernet. fast ethernet was designed under two constraints. first, fast ethernet had to support twisted pairs. although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. second, fast ethernet had to be perfectly compatible with the existing 10 mbps ethernets to allow fast ethernet technology to be used initially as a backbone technology to interconnect 10 mbps ethernet networks. this forced fast ethernet to use exactly the same frame format as 10 mbps ethernet. this implied that the minimum fast ethernet frame size remained at 512 bits. to preserve csma/cd with this minimum frame size and 100 mbps instead of 10 mbps, the duration of the slot time was decreased to 5.12 microseconds. the evolution of ethernet did not stop. in 1998, the ieee published a ﬁrst standard to provide gigabit ethernet over optical ﬁbers. several other types of physical layers were added afterwards. the 10 gigabit ethernet standard appeared in 2002. work is ongoing to develop standards for 40 gigabit and 100 gigabit ethernet and some are thinking about terabit ethernet. the table below lists the main ethernet standards. a more detailed list may be found at http://en.wikipedia.org/wiki/ethernet_physical_layer
comments thick coaxial cable, 500m thin coaxial cable, 185m two pairs of category 3+ utp 10 mb/s over optical ﬁber category 5 utp or stp, 100 m maximum two multimode optical ﬁber, 2 km maximum
standard 10base5 10base2 10baset 10base-f 100base-tx 100base-fx 1000base-cx two pairs shielded twisted pair, 25m maximum 1000base-sx two multimode or single mode optical ﬁbers with lasers 10 gbps 40-100 gbps
increasing the physical layer bandwidth as in fast ethernet was only one of the solutions to improve the performance of ethernet lans. a second solution was to replace the hubs with more intelligent devices. as ethernet hubs operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach
these four basic physical organisations of local area networks are shown graphically in the ﬁgure below. we will ﬁrst focus on one physical organisation at a time.
the common problem among all of these network organisations is how to efﬁciently share the access to the local area network. if two devices send a frame at the same time, the two electrical, optical or radio signals that correspond to these frames will appear at the same time on the transmission medium and a receiver will not be able to decode either frame. such simultaneous transmissions are called collisions. a collision may involve frames transmitted by two or more devices attached to the local area network. collisions are the main cause of errors in wired local area networks. all local area network technologies rely on a medium access control algorithm to regulate the transmissions to either minimise or avoid collisions. there are two broad families of medium access control algorithms :
1. deterministic or pessimistic mac algorithms. these algorithms assume that collisions are a very severe problem and that they must be completely avoided. these algorithms ensure that at any time, at most one device is allowed to send a frame on the lan. this is usually achieved by using a distributed protocol which elects one device that is allowed to transmit at each time. a deterministic mac algorithm ensures that no collision will happen, but there is some overhead in regulating the transmission of all the devices attached to the lan.
2. stochastic or optimistic mac algorithms. these algorithms assume that collisions are part of the normal operation of a local area network. they aim to minimise the number of collisions, but they do not try to avoid all collisions. stochastic algorithms are usually easier to implement than deterministic ones.
we ﬁrst discuss a simple deterministic mac algorithm and then we describe several important optimistic algorithms, before coming back to a distributed and deterministic mac algorithm.
a ﬁrst solution to share the available resources among all the devices attached to one local area network is to deﬁne, a priori, the distribution of the transmission resources among the different devices. if n devices need to share the transmission capacities of a lan operating at b mbps, each device could be allocated a bandwidth of b n mbps. limited resources need to be shared in other environments than local area networks. since the ﬁrst radio transmissions by marconi more than one century ago, many applications that exchange information through radio signals have been developed. each radio signal is an electromagnetic wave whose power is centered around a given frequency. the radio spectrum corresponds to frequencies ranging between roughly 3 khz and 300 ghz. frequency allocation plans negotiated among governments reserve most frequency ranges for speciﬁc applications such as broadcast radio, broadcast television, mobile communications, aeronautical radio navigation, amateur radio, satellite, etc. each frequency range is then subdivided into channels and each channel can be reserved for a given application, e.g. a radio broadcaster in a given region. frequency division multiplexing (fdm) is a static allocation scheme in which a frequency is allocated to each device attached to the shared medium. as each device uses a different transmission frequency, collisions cannot
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
note: reliability of the connection-oriented service an important point to note about the connection-oriented service is its reliability. a connection-oriented service can only guarantee the correct delivery of all sdus provided that the connection has been released gracefully. this implies that while the connection is active, there is no guarantee for the actual delivery of the sdus exchanged as the connection may need to be released abruptly at any time.
given the growing complexity of computer networks, during the 1970s network researchers proposed various reference models to facilitate the description of network protocols and services. of these, the open systems interconnection (osi) model [zimmermann80] was probably the most inﬂuential. it served as the basis for the standardisation work performed within the iso to develop global computer network standards. the reference model that we use in this book can be considered as a simpliﬁed version of the osi reference model 4.
our reference model is divided into ﬁve layers, as shown in the ﬁgure below. starting from the bottom, the ﬁrst layer is the physical layer. two communicating devices are linked through a physical medium. this physical medium is used to transfer an electrical or optical signal between two directly connected devices. several types of physical mediums are used in practice :
• electrical cable. information can be transmitted over different types of electrical cables. the most common ones are the twisted pairs that are used in the telephone network, but also in enterprise networks and coaxial cables. coaxial cables are still used in cable tv networks, but are no longer used in enterprise networks. some networking technologies operate over the classical electrical cable.
• optical ﬁber. optical ﬁbers are frequently used in public and enterprise networks when the distance between the communication devices is larger than one kilometer. there are two main types of optical ﬁbers : multimode and monomode. multimode is much cheaper than monomode ﬁber because a led can be
sourceproviderdestinationtimedata.request("a")source -> destinationconnection closedconnection openedconnection openeddata.request("b")data.request("c")data.indication("a")data.indication("b")disconnect.req(graceful)disconnect.ind(graceful)data.indication("c")data.indication("d")data.request("d")disconnect.ind(graceful)disconnect.req(graceful)connection closedconnection closedsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
the physical layer allows thus two or more entities that are directly attached to the same transmission medium to exchange bits. being able to exchange bits is important as virtually any information can be encoded as a sequence of bits. electrical engineers are used to processing streams of bits, but computer scientists usually prefer to deal with higher level concepts. a similar issue arises with ﬁle storage. storage devices such as hard-disks also store streams of bits. there are hardware devices that process the bit stream produced by a hard-disk, but computer scientists have designed ﬁlesystems to allow applications to easily access such storage devices. these ﬁlesystems are typically divided into several layers as well. hard-disks store sectors of 512 bytes or more. unix ﬁlesystems group sectors in larger blocks that can contain data or inodes representing the structure of the ﬁlesystem. finally, applications manipulate ﬁles and directories that are translated in blocks, sectors and eventually bits by the operating system. computer networks use a similar approach. each layer provides a service that is built above the underlying layer and is closer to the needs of the applications. the datalink layer builds on the service provided by the underlying physical layer. the datalink layer allows two hosts that are directly connected through the physical layer to exchange information. the unit of information exchanged between two entities in the datalink layer is a frame. a frame is a ﬁnite sequence of bits. some datalink layers use variable-length frames while others only use ﬁxed-length frames. some datalink layers provide a connection-oriented service while others provide a connectionless service. some datalink layers provide reliable delivery while others do not guarantee the correct delivery of the information. an important point to note about the datalink layer is that although the ﬁgure below indicates that two entities of the datalink layer exchange frames directly, in reality this is slightly different. when the datalink layer entity on the left needs to transmit a frame, it issues as many data.request primitives to the underlying physical layer as there are bits in the frame. the physical layer will then convert the sequence of bits in an electromagnetic or optical signal that will be sent over the physical medium. the physical layer on the right hand side of the ﬁgure will decode the received signal, recover the bits and issue the corresponding data.indication primitives to its datalink layer entity. if there are no transmission errors, this entity will receive the frame sent earlier.
the datalink layer allows directly connected hosts to exchange information, but it is often necessary to exchange information between hosts that are not attached to the same physical medium. this is the task of the network layer. the network layer is built above the datalink layer. network layer entities exchange packets. a packet is a ﬁnite sequence of bytes that is transported by the datalink layer inside one or more frames. a packet usually
physical layerphysical layerbitsphysical transmission medium01010010100010101001010datalinkphysicalframesdatalinkphysicalsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
• the physical layer may deliver more bits to the receiver than the bits sent by the sender • the physical layer may deliver fewer bits to the receiver than the bits sent by the sender
the datalink layer must allow endsystems to exchange frames containing packets despite all of these limitations. on point-to-point links and local area networks, the ﬁrst problem to be solved is how to encode a frame as a sequence of bits, so that the receiver can easily recover the received frame despite the limitations of the physical layer. if the physical layer were perfect, the problem would be very simple. the datalink layer would simply need to deﬁne how to encode each frame as a sequence of consecutive bits. the receiver would then easily be able to extract the frames from the received bits. unfortunately, the imperfections of the physical layer make this framing problem slightly more complex. several solutions have been proposed and are used in practice in different datalink layer technologies.
this is the framing problem. it can be deﬁned as : “how does a sender encode frames so that the receiver can efﬁciently extract them from the stream of bits that it receives from the physical layer”. a ﬁrst solution to solve the framing problem is to require the physical layer to remain idle for some time after the transmission of each frame. these idle periods can be detected by the receiver and serve as a marker to delineate frame boundaries. unfortunately, this solution is not sufﬁcient for two reasons. first, some physical layers cannot remain idle and always need to transmit bits. second, inserting an idle period between frames decreases the maximum bandwidth that can be achieved by the datalink layer. some physical layers provide an alternative to this idle period. all physical layers are able to send and receive physical symbols that represent values 0 and 1. however, for various reasons that are outside the scope of this chapter, several physical layers are able to exchange other physical symbols as well. for example, the manchester encoding used in several physical layers can send four different symbols. the manchester encoding is a differential encoding scheme in which time is divided into ﬁxed-length periods. each period is divided in two halves and two different voltage levels can be applied. to send a symbol, the sender must set one of these two voltage levels during each half period. to send a 1 (resp. 0), the sender must set a high (resp. low) voltage during the ﬁrst half of the period and a low (resp. high) voltage during the second half. this encoding ensures that there will be a transition at the middle of each period and allows the receiver to synchronise its clock to the sender’s clock. apart from the encodings for 0 and 1, the manchester encoding also supports two additional symbols : invh and invb where the same voltage level is used for the two half periods. by deﬁnition, these two symbols cannot appear inside a frame which is only composed of 0 and 1. some technologies use these special symbols as markers for the beginning or end of frames.
unfortunately, multi-symbol encodings cannot be used by all physical layers and a generic solution which can be used with any physical layer that is able to transmit and receive only 0 and 1 is required. this generic solution is called stufﬁng and two variants exist : bit stufﬁng and character stufﬁng. to enable a receiver to easily delineate the frame boundaries, these two techniques reserve special bit strings as frame boundary markers and encode the frames so that these special bit strings do not appear inside the frames. bit stufﬁng reserves the 01111110 bit string as the frame boundary marker and ensures that there will never be six consecutive 1 symbols transmitted by the physical layer inside a frame. with bit stufﬁng, a frame is sent as follows. first, the sender transmits the marker, i.e. 01111110. then, it sends all the bits of the frame and inserts
these four basic physical organisations of local area networks are shown graphically in the ﬁgure below. we will ﬁrst focus on one physical organisation at a time.
the common problem among all of these network organisations is how to efﬁciently share the access to the local area network. if two devices send a frame at the same time, the two electrical, optical or radio signals that correspond to these frames will appear at the same time on the transmission medium and a receiver will not be able to decode either frame. such simultaneous transmissions are called collisions. a collision may involve frames transmitted by two or more devices attached to the local area network. collisions are the main cause of errors in wired local area networks. all local area network technologies rely on a medium access control algorithm to regulate the transmissions to either minimise or avoid collisions. there are two broad families of medium access control algorithms :
1. deterministic or pessimistic mac algorithms. these algorithms assume that collisions are a very severe problem and that they must be completely avoided. these algorithms ensure that at any time, at most one device is allowed to send a frame on the lan. this is usually achieved by using a distributed protocol which elects one device that is allowed to transmit at each time. a deterministic mac algorithm ensures that no collision will happen, but there is some overhead in regulating the transmission of all the devices attached to the lan.
2. stochastic or optimistic mac algorithms. these algorithms assume that collisions are part of the normal operation of a local area network. they aim to minimise the number of collisions, but they do not try to avoid all collisions. stochastic algorithms are usually easier to implement than deterministic ones.
we ﬁrst discuss a simple deterministic mac algorithm and then we describe several important optimistic algorithms, before coming back to a distributed and deterministic mac algorithm.
a ﬁrst solution to share the available resources among all the devices attached to one local area network is to deﬁne, a priori, the distribution of the transmission resources among the different devices. if n devices need to share the transmission capacities of a lan operating at b mbps, each device could be allocated a bandwidth of b n mbps. limited resources need to be shared in other environments than local area networks. since the ﬁrst radio transmissions by marconi more than one century ago, many applications that exchange information through radio signals have been developed. each radio signal is an electromagnetic wave whose power is centered around a given frequency. the radio spectrum corresponds to frequencies ranging between roughly 3 khz and 300 ghz. frequency allocation plans negotiated among governments reserve most frequency ranges for speciﬁc applications such as broadcast radio, broadcast television, mobile communications, aeronautical radio navigation, amateur radio, satellite, etc. each frequency range is then subdivided into channels and each channel can be reserved for a given application, e.g. a radio broadcaster in a given region. frequency division multiplexing (fdm) is a static allocation scheme in which a frequency is allocated to each device attached to the shared medium. as each device uses a different transmission frequency, collisions cannot
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
become overloaded. otherwise, the segments sent by the sender are not correctly received by the destination. the transport protocols that rely on pipelining allow the sender to transmit w unacknowledged segments before being forced to wait for an acknowledgement from the receiving entity. this is implemented by using a sliding window. the sliding window is the set of consecutive sequence numbers that the sender can use when transmitting segments without being forced to wait for an acknowledgement. the ﬁgure below shows a sliding window containing ﬁve segments (6,7,8,9 and 10). two of these sequence numbers (6 and 7) have been used to send segments and only three sequence numbers (8, 9 and 10) remain in the sliding window. the sliding window is said to be closed once all sequence numbers contained in the sliding window have been used.
the ﬁgure below illustrates the operation of the sliding window. the sliding window shown contains three segments. the sender can thus transmit three segments before being forced to wait for an acknowledgement. the sliding window moves to the higher sequence numbers upon reception of acknowledgements. when the ﬁrst acknowledgement (ok0) is received, it allows the sender to move its sliding window to the right and sequence number 3 becomes available. this sequence number is used later to transmit sdu d.
in practice, as the segment header encodes the sequence number in an n bits string, only the sequence numbers between 0 and 2n − 1 can be used. this implies that the same sequence number is used for different segments and that the sliding window will wrap. this is illustrated in the ﬁgure below assuming that 2 bits are used to encode the sequence number in the segment header. note that upon reception of ok1, the sender slides its window and can use sequence number 0 again. unfortunately, segment losses do not disappear because a transport protocol is using a sliding window. to recover from segment losses, a sliding window protocol must deﬁne :
service provider is forced to terminate a connection it cannot guarantee that all sdus sent by each user have been delivered to the other user. this connection release is said to be abrupt as it can cause losses of data.
an abrupt connection release can also be triggered by one of the users. if a user needs, for any reason, to terminate a connection quickly, it can issue a disconnect.request primitive and to request an abrupt release. the service provider will process the request, stop the two data streams and deliver the disconnect.indication primitive to the remote user as soon as possible. as illustrated in the ﬁgure below, this abrupt connection release may cause losses of sdus.
to ensure a reliable delivery of the sdus sent by each user over a connection, we need to consider the two streams that compose a connection as independent. a user should be able to release the stream that it uses to send sdus once it has sent all the sdus that it planned to send over this connection, but still continue to receive sdus over the opposite stream. this graceful connection release is usually performed as shown in the ﬁgure below. one user issues a disconnect.request primitive to its provider once it has issued all its data.request primitives. the service provider will wait until all data.indication primitives have been delivered to the receiving user before issuing the disconnnect.indication primitive. this primitive informs the receiving user that it will no longer receive sdus over this connection, but it is still able to issue data.request primitives on the stream in the opposite direction. once the user has issued all of its data.request primitives, it issues a disconnnect.request primitive to request the termination of the remaining stream. the service provider will process the request and deliver the corresponding disconnect.indication to the other user once it has delivered all the pending data.indication primitives. at this
sourceproviderdestinationtimedata.request("a")data.request("b")data.indication("a")data.indication("c")connection openedconnection openeddisconnect.indicationdisconnect.indicationsourceproviderdestinationtimedata.request("a")data.request("b")data.indication("a")data.request("c")connection openedconnection openeddisconnect.req(abrupt)disconnect.indicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
does not have a matching connection attempt and replies by sending a reject. unfortunately, this segment never reaches the remote entity. instead, the remote entity receives a retransmission of an older ca segment that contains the same sequence number as the ﬁrst cr segment. this ca segment cannot be accepted by the remote entity as a conﬁrmation of the transport connection as its acknowledgement number cannot have the same value as the sequence number of the ﬁrst ca segment.
when we discussed the connection-oriented service, we mentioned that there are two types of connection releases : abrupt release and graceful release. the ﬁrst solution to release a transport connection is to deﬁne a new control segment (e.g. the dr segment) and consider the connection to be released once this segment has been sent or received. this is illustrated in the ﬁgure below.
as the entity that sends the dr segment cannot know whether the other entity has already sent all its data on the connection, sdus can be lost during such an abrupt connection release. the second method to release a transport connection is to release independently the two directions of data transfer. once a user of the transport service has sent all its sdus, it performs a disconnect.req for its direction of data transfer. the transport entity sends a control segment to request the release of the connection after the delivery of all previous sdus to the remote user. this is usually done by placing in the dr the next sequence number and by delivering the disconnect.ind only after all previous data.ind. the remote entity conﬁrms the reception of the dr segment and the release of the corresponding direction of data transfer by returning an acknowledgement. this is illustrated in the ﬁgure below.
if, unfortunately, the distance vector sent to router c is lost due to a transmission error or because router c is overloaded, a new count to inﬁnity problem can occur. if router c sends its distance vector [a = 2, b = 1, c = 0, e = ∞] to router e, this router installs a route of distance 3 to reach a via c. router e sends its distance vectors [a = 3, b = ∞, c = 1, e = 1] to router b and [a = ∞, b = 1, c = ∞, e = 0] to router c. this distance vector allows b to recover a route of distance 4 to reach a.
link state routing is the second family of routing protocols. while distance vector routers use a distributed algorithm to compute their routing tables, link-state routers exchange messages to allow each router to learn the entire network topology. based on this learned topology, each router is then able to compute its routing table by using a shortest path computation [dijkstra1959]. for link-state routing, a network is modelled as a directed weighted graph. each router is a node, and the links between routers are the edges in the graph. a positive weight is associated to each directed edge and routers use the shortest path to reach each destination. in practice, different types of weight can be associated to each directed edge :
bandwidth where c is a constant larger than the highest link bandwidth in the network. if all link weights are conﬁgured this way, shortest path routing prefers higher bandwidth paths over lower bandwidth paths
usually, the same weight is associated to the two directed edges that correspond to a physical link (i.e. r1 → r2 and r2 → r1). however, nothing in the link state protocols requires this. for example, if the weight is set in function of the link bandwidth, then an asymmetric adsl link could have a different weight for the upstream and downstream directions. other variants are possible. some networks use optimisation algorithms to ﬁnd the best set of weights to minimize congestion inside the network for a given trafﬁc demand [frt2002]. when a link-state router boots, it ﬁrst needs to discover to which routers it is directly connected. for this, each router sends a hello message every n seconds on all of its interfaces. this message contains the router’s address. each router has a unique address. as its neighbouring routers also send hello messages, the router automatically discovers to which neighbours it is connected. these hello messages are only sent to neighbours who are directly connected to a router, and a router never forwards the hello messages that they receive. hello messages are also used to detect link and router failures. a link is considered to have failed if no hello message has been received from the neighbouring router for a period of k × n seconds.
another problem faced by wireless networks is often called the hidden station problem. in a wireless network, radio signals are not always propagated same way in all directions. for example, two devices separated by a wall may not be able to receive each other’s signal while they could both be receiving the signal produced by a third host. this is illustrated in the ﬁgure below, but it can happen in other environments. for example, two devices that are on different sides of a hill may not be able to receive each other’s signal while they are both able to receive the signal sent by a station at the top of the hill. furthermore, the radio propagation conditions may change with time. for example, a truck may temporarily block the communication between two nearby devices.
to avoid collisions in these situations, csma/ca allows devices to reserve the transmission channel for some time. this is done by using two control frames : request to send (rts) and clear to send (cts). both are very short frames to minimize the risk of collisions. to reserve the transmission channel, a device sends a rts frame to the intended recipient of the data frame. the rts frame contains the duration of the requested reservation. the recipient replies, after a sifs delay, with a cts frame which also contains the duration of the reservation. as the duration of the reservation has been sent in both rts and cts, all hosts that could collide with either the sender or the reception of the data frame are informed of the reservation. they can compute the total duration of the transmission and defer their access to the transmission channel until then. this is illustrated in the ﬁgure below where host a reserves the transmission channel to send a data frame to host b. host c notices the reservation and defers its transmission.
the utilization of the reservations with csma/ca is an optimisation that is useful when collisions are frequent. if there are few collisions, the time required to transmit the rts and cts frames can become signiﬁcant and in particular when short frames are exchanged. some devices only turn on rts/cts after transmission errors.
3. the network layer is conceptually divided into two planes : the data plane and the control plane. the data plane contains the protocols and mechanisms that allow hosts and routers to exchange packets carrying user data. the control plane contains the protocols and mechanisms that enable routers to efﬁciently learn how to forward packets towards their ﬁnal destination.
the independence of the network layer from the underlying datalink layer is a key principle of the network layer. it ensures that the network layer can be used to allow hosts attached to different types of datalink layers to exchange packets through intermediate routers. furthermore, this allows the datalink layers and the network layer to evolve independently from each other. this enables the network layer to be easily adapted to a new datalink layer every time a new datalink layer is invented. there are two types of service that can be provided by the network layer :
connection-oriented services have been popular with technologies such as x.25 and atm or frame-relay, but nowadays most networks use an unreliable connectionless service. this is our main focus in this chapter.
the internal organisation of the network is orthogonal to the service that it provides, but most of the time a datagram organisation is used to provide a connectionless service while a virtual circuit organisation is used in networks that provide a connection-oriented service.
the ﬁrst and most popular organisation of the network layer is the datagram organisation. this organisation is inspired by the organisation of the postal service. each host is identiﬁed by a network layer address. to send information to a remote host, a host creates a packet that contains :
the network layer limits the maximum packet size. thus, the information must have been divided in packets by the transport layer before being passed to the network layer. to understand the datagram organisation, let us consider the ﬁgure below. a network layer address, represented by a letter, has been assigned to each host and router. to send some information to host j, host a creates a packet containing its own address, the destination address and the information to be exchanged. with the datagram organisation, routers use hop-by-hop forwarding. this means that when a router receives a packet that is not destined to itself, it looks up the destination address of the packet in its routing table. a routing table is a data structure that maps each destination address (or set of destination addresses) to the outgoing interface over which a packet destined to this address must be forwarded to reach its ﬁnal destination. the main constraint imposed on the routing tables is that they must allow any host in the network to reach any other host. this implies that each router must know a route towards each destination, but also that the paths composed from the information stored in the routing tables must not contain loops. otherwise, some destinations would be unreachable.
many protocols have been deﬁned for networked applications. in this section, we describe some of the important applications that are used on the internet. we ﬁrst explain the domain name system (dns) that enables hosts to be identiﬁed by human-friendly names instead of the ipv4 or ipv6 addresses that are used by the network. then, we describe the operation of electronic mail, one of the ﬁrst killer applications on the global internet, and the protocols used on world wide web.
in the early days of the internet, there were only a few number of hosts (mainly minicomputers) connected to the network. the most popular applications were remote login and ﬁle transfer. by 1983, there were already ﬁve hundred hosts attached to the internet. each of these hosts were identiﬁed by a unique ipv4 address. forcing human users to remember the ipv4 addresses of the remote hosts that they want to use was not user-friendly. human users prefer to remember names, and use them when needed. using names as aliases for addresses is a common technique in computer science. it simpliﬁes the development of applications and allows the developer to ignore the low level details. for example, by using a programming language instead of writing machine code, a developer can write software without knowing whether the variables that it uses are stored in memory or inside registers. because names are at a higher level than addresses, they allow (both in the example of programming above, and on the internet) to treat addresses as mere technical identiﬁers, which can change at will. only the names are stable. on today’s internet, where switching to another isp means changing your ip addresses, the user-friendliness of domain names is less important (they are not often typed by users) but their stability remains a very important, may be their most important property. the ﬁrst solution that allowed applications to use names was the hosts.txt ﬁle. this ﬁle is similar to the symbol table found in compiled code. it contains the mapping between the name of each internet host and its associated ip address 2. it was maintained by sri international that coordinated the network information center (nic). when a new host was connected to the network, the system administrator had to register its name and ip address at the nic. the nic updated the hosts.txt ﬁle on its server. all internet hosts regularly retrieved the updated hosts.txt ﬁle from the server maintained by sri. this ﬁle was stored at a well-known location on each internet host (see rfc 952) and networked applications could use it to ﬁnd the ip address corresponding to a name. a hosts.txt ﬁle can be used when there are up to a few hundred hosts on the network. however, it is clearly not suitable for a network containing thousands or millions of hosts. a key issue in a large network is to deﬁne a suitable naming scheme. the arpanet initially used a ﬂat naming space, i.e. each host was assigned a unique name. to limit collisions between names, these names usually contained the name of the institution and a sufﬁx to identify the host inside the institution (a kind of poor man’s hierarchical naming scheme). on the arpanet few institutions had several hosts connected to the network. however, the limitations of a ﬂat naming scheme became clear before the end of the arpanet and rfc 819 proposed a hierarchical naming scheme. while rfc 819 discussed the possibility of organising the names as a directed graph, the internet opted eventually for a tree structure capable of containing all names. in this tree, the top-level domains are those that are directly attached to the root. the ﬁrst top-level domain was .arpa 3. this top-level name was initially added as a sufﬁx to the names of the hosts attached to the arpanet and listed in the hosts.txt ﬁle. in 1984, the .gov, .edu, .com, .mil and .org generic top-level domain names were added and rfc 1032 proposed the utilisation of the two letter iso-3166 country codes as top-level domain names. since iso-3166 deﬁnes a two letter code for each country recognised by the united nations, this allowed all countries to automatically have a top-level domain. these domains include .be for belgium, .fr for france, .us for the usa, .ie for ireland or .tv for tuvalu, a group of small islands in the paciﬁc and .tm for turkmenistan. today, the set of top-level domain-names is managed by the internet corporation for assigned names and numbers (icann). recently, icann added a dozen of generic top-level domains that are not related to a country and the .cat top-level domain has been registered for the catalan language. there are ongoing discussions within icann to increase the number of top-level domains.
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
the ﬁrst step of the bgp decision process ensures that a bgp router does not install in its fib a route whose nexthop is considered to be unreachable by the intradomain routing protocol. this could happen, for example, when a router has crashed. the intradomain routing protocol usually advertises the failure of this router before the failure of the bgp sessions that it terminates. this rule implies that the bgp decision process must be re-run each time the intradomain routing protocol reports a change in the reachability of a preﬁx containing one of more bgp nexthops. the second rule allows each domain to deﬁne its routing preferences. the local-pref attribute is set by the import ﬁlter of the router that learned a route over an ebgp session. in contrast with intradomain routing protocols, bgp does not contain an explicit metric. this is because in the global internet it is impossible for all domains to agree on a common metric that meets the requirements of all domains. despite this, bgp routers prefer routes having a short as-path attribute over routes with a long aspath. this step of the bgp decision process is motivated by the fact that operators expect that a route with a long as-path is lower quality than a route with a shorter as-path. however, studies have shown that there was not always a strong correlation between the quality of a route and the length of its as-path [hfpmc2002]. before explaining the fourth step of the bgp decision process, let us ﬁrst describe the ﬁfth and the sixth steps of the bgp decision process. these two steps are used to implement hot potato routing. intuitively, when a domain implements hot potato routing, it tries to forward packets that are destined to addresses outside of its domain, to other domains as quickly as possible. to understand hot potato routing, let us consider the two domains shown in the ﬁgure below. as2 advertises preﬁx 1.0.0.0/8 over the r2-r6 and r3-r7 peering links. the routers inside as1 learn two routes towards 1.0.0.0/8: one via r6-r2 and the second via r7-r3.
with the ﬁfth step of the bgp decision process, a router always prefers to use a route learned over an ebgp session compared to a route learned over an ibgp session. thus, router r6 (resp. r7) prefers to use the route via router r2 (resp. r3) to reach preﬁx 1.0.0.0/8. the sixth step of the bgp decision process takes into account the distance, measured as the length of the shortest intradomain path, between a bgp router and the bgp nexthop for routes learned over ibgp sessions. this rule is used on router r8 in the example above. this router has received two routes towards 1.0.0.0/8:
the ﬁrst route, via r7 is the one that router r8 prefers, as this is the route that minimises the cost of forwarding packets inside as1 before sending them to as2.
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
the best solution to allow bgp routers to distribute, inside an as, all the routes learned over bgp sessions is to establish bgp sessions among all the bgp routers inside the as. in practice, there are two types of bgp sessions :
in practice, each bgp router inside a domain maintains an ibgp session with every other bgp router in the domain 34. this creates a full-mesh of ibgp sessions among all bgp routers of the domain. ibgp sessions, like ebgp sessions run over tcp connections. note that in contrast with ebgp sessions that are established between directly connected routers, ibgp sessions are often established between routers that are not directly connected. an important point to note about ibgp sessions is that a bgp router only advertises a route over an ibgp session provided that :
a bgp router does not advertise a route that it has learned over an ibgp session over another ibgp session. note that a router can, of course, advertise over an ebgp session a route that it has learned over an ibgp session. this difference between the behaviour of a bgp router over ibgp and ebgp session is due to the utilisation of a full-mesh of ibgp sessions. consider a network containing three bgp routers : a, b and c interconnected via a full-mesh of ibgp sessions. if router a learns a route towards preﬁx p from router b, router a does not need to advertise the received route to router c since router c also learns the same route over the c-b ibgp session. let us consider what happens when router r1 sends to understand the utilisation of an ibgp session, u(194.100.0.0/23,195.100.0.1,as10) in the network shown below. this bgp message is processed by r2 which advertises it over its ibgp session with r4. the bgp update sent by r2 contains the same nexthop and the same as-path as in the bgp update received by r2. r4 then sends u(194.100.0.0/23,195.100.0.5,as20:as10) to r3. note that the bgp nexthop and the as-path are only updated 35 when a bgp route is advertised over an ebgp session.
note: loopback interfaces and ibgp sessions in addition to their physical interfaces, routers can also be conﬁgured with a special loopback interface. a loopback interface is a software interface that is always up. when a loopback interface is conﬁgured on a router, the address associated to this interface is advertised by the intradomain routing protocol. consider for example
34 using a full-mesh of ibgp sessions is suitable in small networks. however, this solution does not scale in large networks containing ibgp sessions must be established in a domain containing n bgp routers. large domains use either
hundreds or more routers since n×(n−1) route reﬂection rfc 4456 or confederations rfc 5065 to scale their ibgp, but this goes beyond this introduction.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.8/30195.100.0.9195.100.0.10ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. this can be implemented by starting a timer when the ﬁrst fragment of a packet is received. if the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost. the original ip speciﬁcation, in rfc 791, deﬁned several types of options that can be added to the ip header. each option is encoded using a type length value format. they are not widely used today and are thus only brieﬂy described. additional details may be found in rfc 791. the most interesting options in ipv4 are the three options that are related to routing. the record route option was deﬁned to allow network managers to determine the path followed by a packet. when the record route option was present, routers on the packet’s path had to insert their ip address in the option. this option was implemented, but as the optional part of the ipv4 header can only contain 44 bytes, it is impossible to discover an entire path on the global internet. traceroute(8), despite its limitations, is a better solution to record the path towards a destination. the other routing options are the strict source route and the loose source route option. the main idea behind these options is that a host may want, for any reason, to specify the path to be followed by the packets that it sends. the strict source route option allows a host to indicate inside each packet the exact path to be followed. the strict source route option contains a list of ipv4 address and a pointer to indicate the next address in the list. when a router receives a packet containing this option, it does not lookup the destination address in its routing table but forwards the packet directly to the next router in the list and advances the pointer. this is illustrated in the ﬁgure below where s forces its packets to follow the ra-rb-rd path.
the maximum length of the optional part of the ipv4 header is a severe limitation for the strict source route option as for the record route option. the loose source route option does not suffer from this limitation. this option allows the sending host to indicate inside its packet some of the routers that must be traversed to reach the destination. this is shown in the ﬁgure below. s sends a packet containing a list of addresses and a pointer to the next router in the list. initially, this pointer points to rb. when ra receives the packet sent by s, it looks up in its forwarding table the address pointed in the loose source route option and not the destination address. the packet is then forwarded to router rb that recognises its address in the option and advances the pointer. as there is no address listed in the loose source route option anymore, rb and other downstream routers forward the packet by performing a lookup for the destination address.
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
when developing its family of standards, the ieee 802.11 working group took a similar approach as the ieee 802.3 working group that developed various types of physical layers for ethernet networks. 802.11 networks use the csma/ca medium access control technique described earlier and they all assume the same architecture and use the same frame format. the architecture of wifi networks is slightly different from the local area networks that we have discussed until now. there are, in practice, two main types of wifi networks : independent or adhoc networks and infrastructure networks 11. an independent or adhoc network is composed of a set of devices that communicate with each other. these devices play the same role and the adhoc network is usually not connected to the global internet. adhoc networks are used when for example a few laptops need to exchange information or to connect a computer with a wifi printer.
most wifi networks are infrastructure networks. an infrastructure network contains one or more access points that are attached to a ﬁxed local area network (usually an ethernet network) that is connected to other networks such as the internet. the ﬁgure below shows such a network with two access points and four wifi devices. each wifi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the lan. an 802.11 access point is a relay that operates in the datalink layer like switches. the ﬁgure below represents the layers of the reference model that are involved when a wifi host communicates with a host attached to an ethernet network through an access point. 802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in ethernet lans. we review the key parts of the 802.11 frames. additional details may be found in [802.11] and [gast2002] . an 802.11 frame contains a ﬁxed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits crc. although the payload can contain up to 2324 bytes,
when developing its family of standards, the ieee 802.11 working group took a similar approach as the ieee 802.3 working group that developed various types of physical layers for ethernet networks. 802.11 networks use the csma/ca medium access control technique described earlier and they all assume the same architecture and use the same frame format. the architecture of wifi networks is slightly different from the local area networks that we have discussed until now. there are, in practice, two main types of wifi networks : independent or adhoc networks and infrastructure networks 11. an independent or adhoc network is composed of a set of devices that communicate with each other. these devices play the same role and the adhoc network is usually not connected to the global internet. adhoc networks are used when for example a few laptops need to exchange information or to connect a computer with a wifi printer.
most wifi networks are infrastructure networks. an infrastructure network contains one or more access points that are attached to a ﬁxed local area network (usually an ethernet network) that is connected to other networks such as the internet. the ﬁgure below shows such a network with two access points and four wifi devices. each wifi device is associated to one access point and uses this access point as a relay to exchange frames with the devices that are associated to another access point or reachable through the lan. an 802.11 access point is a relay that operates in the datalink layer like switches. the ﬁgure below represents the layers of the reference model that are involved when a wifi host communicates with a host attached to an ethernet network through an access point. 802.11 devices exchange variable length frames, which have a slightly different structure than the simple frame format used in ethernet lans. we review the key parts of the 802.11 frames. additional details may be found in [802.11] and [gast2002] . an 802.11 frame contains a ﬁxed length header, a variable length payload that may contain up 2324 bytes of user data and a 32 bits crc. although the payload can contain up to 2324 bytes,
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. this can be implemented by starting a timer when the ﬁrst fragment of a packet is received. if the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost. the original ip speciﬁcation, in rfc 791, deﬁned several types of options that can be added to the ip header. each option is encoded using a type length value format. they are not widely used today and are thus only brieﬂy described. additional details may be found in rfc 791. the most interesting options in ipv4 are the three options that are related to routing. the record route option was deﬁned to allow network managers to determine the path followed by a packet. when the record route option was present, routers on the packet’s path had to insert their ip address in the option. this option was implemented, but as the optional part of the ipv4 header can only contain 44 bytes, it is impossible to discover an entire path on the global internet. traceroute(8), despite its limitations, is a better solution to record the path towards a destination. the other routing options are the strict source route and the loose source route option. the main idea behind these options is that a host may want, for any reason, to specify the path to be followed by the packets that it sends. the strict source route option allows a host to indicate inside each packet the exact path to be followed. the strict source route option contains a list of ipv4 address and a pointer to indicate the next address in the list. when a router receives a packet containing this option, it does not lookup the destination address in its routing table but forwards the packet directly to the next router in the list and advances the pointer. this is illustrated in the ﬁgure below where s forces its packets to follow the ra-rb-rd path.
the maximum length of the optional part of the ipv4 header is a severe limitation for the strict source route option as for the record route option. the loose source route option does not suffer from this limitation. this option allows the sending host to indicate inside its packet some of the routers that must be traversed to reach the destination. this is shown in the ﬁgure below. s sends a packet containing a list of addresses and a pointer to the next router in the list. initially, this pointer points to rb. when ra receives the packet sent by s, it looks up in its forwarding table the address pointed in the loose source route option and not the destination address. the packet is then forwarded to router rb that recognises its address in the option and advances the pointer. as there is no address listed in the loose source route option anymore, rb and other downstream routers forward the packet by performing a lookup for the destination address.
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. this can be implemented by starting a timer when the ﬁrst fragment of a packet is received. if the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost. the original ip speciﬁcation, in rfc 791, deﬁned several types of options that can be added to the ip header. each option is encoded using a type length value format. they are not widely used today and are thus only brieﬂy described. additional details may be found in rfc 791. the most interesting options in ipv4 are the three options that are related to routing. the record route option was deﬁned to allow network managers to determine the path followed by a packet. when the record route option was present, routers on the packet’s path had to insert their ip address in the option. this option was implemented, but as the optional part of the ipv4 header can only contain 44 bytes, it is impossible to discover an entire path on the global internet. traceroute(8), despite its limitations, is a better solution to record the path towards a destination. the other routing options are the strict source route and the loose source route option. the main idea behind these options is that a host may want, for any reason, to specify the path to be followed by the packets that it sends. the strict source route option allows a host to indicate inside each packet the exact path to be followed. the strict source route option contains a list of ipv4 address and a pointer to indicate the next address in the list. when a router receives a packet containing this option, it does not lookup the destination address in its routing table but forwards the packet directly to the next router in the list and advances the pointer. this is illustrated in the ﬁgure below where s forces its packets to follow the ra-rb-rd path.
the maximum length of the optional part of the ipv4 header is a severe limitation for the strict source route option as for the record route option. the loose source route option does not suffer from this limitation. this option allows the sending host to indicate inside its packet some of the routers that must be traversed to reach the destination. this is shown in the ﬁgure below. s sends a packet containing a list of addresses and a pointer to the next router in the list. initially, this pointer points to rb. when ra receives the packet sent by s, it looks up in its forwarding table the address pointed in the loose source route option and not the destination address. the packet is then forwarded to router rb that recognises its address in the option and advances the pointer. as there is no address listed in the loose source route option anymore, rb and other downstream routers forward the packet by performing a lookup for the destination address.
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
to solve these problems, ipv4 includes a packet fragmentation and reassembly mechanism. both hosts and intermediate routers may fragment an ipv4 packet if the packet is too long to be sent via the datalink layer. in ipv4, fragmentation is completely performed in the ip layer and a large ipv4 is fragmented into two or more ipv4 packets (called fragments). the ipv4 fragments of a large packet are normal ipv4 packets that are forwarded towards the destination of the large packet by intermediate routers. the ipv4 fragmentation mechanism relies on four ﬁelds of the ipv4 header : length, identiﬁcation, the ﬂags and the fragment offset. the ipv4 header contains two ﬂags : more fragments and don’t fragment (df). when the df ﬂag is set, this indicates that the packet cannot be fragmented. the basic operation of the ipv4 fragmentation is as follows. a large packet is fragmented into two or more fragments. the size of all fragments, except the last one, is equal to the maximum transmission unit of the link used to forward the packet. each ipv4 packet contains a 16 bits identiﬁcation ﬁeld. when a packet is fragmented, the identiﬁcation of the large packet is copied in all fragments to allow the destination to reassemble the received fragments together. in each fragment, the fragment offset indicates, in units of 8 bytes, the position of the payload of the fragment in the payload of the original packet. the length ﬁeld in each fragment indicates the length of the payload of the fragment as in a normal ipv4 packet. finally, the more fragments ﬂag is set only in the last fragment of a large packet. the following pseudo-code details the ipv4 fragmentation, assuming that the packet does not contain options.
the fragments of an ipv4 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. furthermore, some fragments may be lost and never reach the destination. the reassembly algorithm used by the destination host is roughly as follows. first, the destination can verify whether a received ipv4 packet is a fragment or not by checking the value of the more fragments ﬂag and the fragment offset. if the fragment offset is set to 0 and the more fragments ﬂag is reset, the received packet has not been fragmented. otherwise, the packet has been fragmented and must be reassembled. the reassembly algorithm relies on the identiﬁcation ﬁeld of the received fragments to associate a fragment with the corresponding packet being reassembled. furthermore, the fragment offset ﬁeld indicates the position of the fragment payload in the original unfragmented packet. finally, the packet with the more fragments ﬂag reset allows the destination to determine the total length of the original unfragmented packet. note that the reassembly algorithm must deal with the unreliability of the ip network. this implies that a fragment may be duplicated or a fragment may never reach the destination. the destination can easily detect fragment duplication thanks to the fragment offset. to deal with fragment losses, the reassembly algorithm must bound the
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
the jumbogram option contains the packet length as a 32 bits ﬁeld. such packets can only be sent from a source to a destination if all the routers on the path support this option. however, as of this writing it does not seem that the jumbogram option has been implemented. the router alert option deﬁned in rfc 2711 is the second example of a hop-by-hop option. the packets that contain this option should be processed in a special way by intermediate routers. this option is used for ip packets that carry resource reservation protocol (rsvp) messages. its usage is explained later. the type 0 routing header deﬁned in rfc 2460 is an example of an ipv6 option that must be processed by some routers. this option is encoded as shown below.
the type 0 routing option was intended to allow a host to indicate a loose source route that should be followed by a packet by specifying the addresses of some of the routers that must forward this packet. unfortunately, further work with this routing header, including an entertaining demonstration with scapy [be2007] , revealed some severe security problems with this routing header. for this reason, loose source routing with the type 0 routing header has been removed from the ipv6 speciﬁcation rfc 5095. in ipv6, fragmentation is performed exclusively by the source host and relies on the fragmentation header. this 64 bits header is composed of six ﬁelds :
• a next header ﬁeld that indicates the type of the header that follows the fragmentation header • a reserved ﬁeld set to 0. • the fragment offset is a 13-bit unsigned integer that contains the offset, in 8 bytes units, of the data following
• the more ﬂag, which is set to 0 in the last fragment of a packet and to 1 in all other fragments. • the 32 bits identiﬁcation ﬁeld indicates to which original packet a fragment belongs. when a host sends fragmented packets, it should ensure that it does not reuse the same identiﬁcation ﬁeld for packets sent to the same destination during a period of msl seconds. this is easier with the 32 bits identiﬁcation used in the ipv6 fragmentation header, than with the 16 bits identiﬁcation ﬁeld of the ipv4 header.
some ipv6 implementations send the fragments of a packet in increasing fragment offset order, starting from the ﬁrst fragment. others send the fragments in reverse order, starting from the last fragment. the latter solution can be advantageous for the host that needs to reassemble the fragments, as it can easily allocate the buffer required to
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
than the speed of light and 200.000 kilometers per second is a reasonable estimation. this implies that if the cable has a length of one kilometer, the electrical signal will need 5 microseconds to travel from one end of the cable to the other. the ends of coaxial cables are equipped with termination points that ensure that the electrical signal is not reﬂected back to its source. this is illustrated at point (3) in the ﬁgure, where the electrical signal has reached the left endpoint and host b. at this point, b starts to receive the frame being transmitted by a. notice that there is a delay between the transmission of a bit on host a and its reception by host b. if there were other hosts attached to the cable, they would receive the ﬁrst bit of the frame at slightly different times. as we will see later, this timing difference is a key problem for mac algorithms. at point (4), the electrical signal has reached both ends of the cable and occupies it completely. host a continues to transmit the electrical signal until the end of the frame. as shown at point (5), when the sending host stops its transmission, the electrical signal corresponding to the end of the frame leaves the coaxial cable. the channel becomes empty again once the entire electrical signal has been removed from the cable.
now that we have looked at how a frame is actually transmitted as an electrical signal on a shared bus, it is interesting to look in more detail at what happens when two hosts transmit a frame at almost the same time. this is illustrated in the ﬁgure below, where hosts a and b start their transmission at the same time (point (1)). at this time, if host c senses the channel, it will consider it to be free. this will not last a long time and at point (2) the electrical signals from both host a and host b reach host c. the combined electrical signal (shown graphically as the superposition of the two curves in the ﬁgure) cannot be decoded by host c. host c detects a collision, as it receives a signal that it cannot decode. since host c cannot decode the frames, it cannot determine which hosts are sending the colliding frames. note that host a (and host b) will detect the collision after host c (point (3) in the ﬁgure below). as shown above, hosts detect collisions when they receive an electrical signal that they cannot decode. in a wired network, a host is able to detect such a collision both while it is listening (e.g. like host c in the ﬁgure above) and also while it is sending its own frame. when a host transmits a frame, it can compare the electrical signal that it transmits with the electrical signal that it senses on the wire. at points (1) and (2) in the ﬁgure above, host a senses only its own signal. at point (3), it senses an electrical signal that differs from its own signal and can thus detects the collision. at this point, its frame is corrupted and it can stop its transmission. the ability to detect collisions while transmitting is the starting point for the carrier sense multiple access with collision detection (csma/cd) medium access control algorithm, which is used in ethernet networks [metcalfe1976] [802.3] . when an ethernet host detects a collision while it is transmitting, it immediately stops its transmission. compared with pure csma, csma/cd is an important improvement since when collisions occur, they only last until colliding hosts have detected it and stopped their transmission. in practice, when a host detects a collision, it sends a special jamming signal on the cable to ensure that all hosts have detected the collision.
in comparison with ipv4, the ipv6 packets are much simpler and easier to process by routers. a ﬁrst important difference is that there is no checksum inside the ipv6 header. this is mainly because all datalink layers and transport protocols include a checksum or a crc to protect their frames/segments against transmission errors. adding a checksum in the ipv6 header would have forced each router to recompute the checksum of all packets, with limited beneﬁt in detecting errors. in practice, an ip checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. however, this beneﬁt was found to be too small given the reliability of current memories and the cost of computing the checksum on each router. a second difference with ipv4 is that the ipv6 header does not support fragmentation and reassembly. experience with ipv4 has shown that fragmenting packets in routers was costly [km1995] and the developers of ipv6 have decided that routers would not fragment packets anymore. if a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an icmpv6 messages to inform the sender of the problem. the sender can then either fragment the packet or perform path mtu discovery. in ipv6, packet fragmentation is performed only by the source by using ipv6 options. the third difference are the ipv6 options, which are simpler and easier to process than the ipv4 options.
note: header compression on low bandwidth links given the size of the ipv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for voice over ip applications. in such environments, several techniques can be used to reduce the overhead. a ﬁrst solution is to use data compression in the datalink layer to compress all the information exchanged [thomborson1992]. these techniques are similar to the data compression algorithms used in tools such as compress(1) or gzip(1) rfc 1951. they compress streams of bits without taking advantage of the fact that these streams contain ip packets with a known structure. a second solution is to compress the ip and tcp header. these header compression techniques, such as the one deﬁned in rfc 2507 take advantage of the redundancy found in successive packets from the same ﬂow to signiﬁcantly reduce the size of the protocol headers. another solution is to deﬁne a compressed encoding of the ipv6 header that matches the capabilities of the underlying datalink layer rfc 4944.
in ipv6, each option is considered as one header containing a multiple of 8 bytes to ensure that ipv6 options in a packet are aligned on 64 bit boundaries. ipv6 deﬁnes several type of options :
• the hop-by-hop options are options that must be processed by the routers on the packet’s path • the type 0 routing header, which is similar to the ipv4 loose source routing option • the fragmentation option, which is used when fragmenting an ipv6 packet • the destination options • the security options that allow ipv6 hosts to exchange packets with cryptographic authentication (ah
rfc 2460 provides lots of detail on the encodings of the different types of options. in this section, we only discus some of them. the reader may consult rfc 2460 for more information about the other options. the ﬁrst point to note is that each option contains a next header ﬁeld, which indicates the type of header that follows the option. a second point to note is that in order to allow routers to efﬁciently parse ipv6 packets, the options that must be processed by routers (hop-by-hop options and type 0 routing header) must appear ﬁrst in the packet. this allows the router to process a packet without being forced to analyse all the packet’s options. a third point to note is that hop-by-hop and destination options are encoded using a type length value format. furthermore, the type ﬁeld contains bits that indicate whether a router that does not understand this option should ignore the option or discard the packet. this allows the introduction of new options into the network without forcing all devices to be upgraded to support them at the same time. two hop-by-hop options have been deﬁned. rfc 2675 speciﬁes the jumbogram that enables ipv6 to support packets containing a payload larger than 65535 bytes. these jumbo packets have their payload length set to 0 and
in a network using virtual circuits, all hosts are identiﬁed with a network layer address. however, a host must explicitly request the establishment of a virtual circuit before being able to send packets to a destination host. the request to establish a virtual circuit is processed by the control plane, which installs state to create the virtual circuit between the source and the destination through intermediate routers. all the packets that are sent on the virtual circuit contain a virtual circuit identiﬁer that allows the routers to determine to which virtual circuit each packet belongs. this is illustrated in the ﬁgure below with one virtual circuit between host a and host i and another one between host a and host j.
the establishment of a virtual circuit is performed using a signalling protocol in the control plane. usually, the source host sends a signalling message to indicate to its router the address of the destination and possibly some performance characteristics of the virtual circuit to be established. the ﬁrst router can process the signalling message in two different ways. a ﬁrst solution is for the router to consult its routing table, remember the characteristics of the requested virtual circuit and forward it over its outgoing interface towards the destination. the signalling message is thus forwarded hop-by-hop until it reaches the destination and the virtual circuit is opened along the path followed by the signalling message. this is illustrated with the red virtual circuit in the ﬁgure below.
a second solution can be used if the routers know the entire topology of the network. in this case, the ﬁrst router can use a technique called source routing. upon reception of the signalling message, the ﬁrst router chooses the path of the virtual circuit in the network. this path is encoded as the list of the addresses of all intermediate routers to reach the destination. it is included in the signalling message and intermediate routers can remove their address from the signalling message before forwarding it. this technique enables routers to spread the virtual circuits throughout the network better. if the routers know the load of remote links, they can also select the least loaded path when establishing a virtual circuit. this solution is illustrated with the blue circuit in the ﬁgure above. the last point to be discussed about the virtual circuit organisation is its data plane. the data plane mainly deﬁnes the format of the data packets and the algorithm used by routers to forward packets. the data packets contain a virtual circuit identiﬁer, encoded as a ﬁxed number of bits. these virtual circuit identiﬁers are usually called labels.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
the ﬁrst rule ensures that a tcp connection used for bulk data transfer always sends full tcp segments. the second rule sends one partially ﬁlled tcp segment every round-trip-time. this algorithm, called the nagle algorithm, takes a few lines of code in all tcp implementations. these lines of code have a huge impact on the packets that are exchanged in tcp/ip networks. researchers have analysed the distribution of the packet sizes by capturing and analysing all the packets passing through a given link. these studies have shown several important results :
• in tcp/ipv4 networks, most of the bytes are exchanged in long packets, usually packets containing up to 1460 bytes of payload which is the default mss for hosts attached to an ethernet network, the most popular type of lan
the ﬁgure below provides a distribution of the packet sizes measured on a link. it shows a three-modal distribution of the packet size. 50% of the packets contain pure tcp acknowledgements and occupy 40 bytes. about 20% of the packets contain about 500 bytes 18 of user data and 12% of the packets contain 1460 bytes of user data. however, most of the user data is transported in large packets. this packet size distribution has implications on the design of routers as we discuss in the next chapter.
recent measurements indicate that these packet size distributions are still valid in today’s internet, although the packet distribution tends to become bimodal with small packets corresponding to tcp pure acks (40-64 bytes depending on the utilisation of tcp options) and large 1460-bytes packets carrying most of the user data.
from a performance point of view, one of the main limitations of the original tcp speciﬁcation is the 16 bits window ﬁeld in the tcp header. as this ﬁeld indicates the current size of the receive window in bytes, it limits the tcp receive window at 65535 bytes. this limitation was not a severe problem when tcp was designed since at that time high-speed wide area networks offered a maximum bandwidth of 56 kbps. however, in today’s network, this limitation is not acceptable anymore. the table below provides the rough 19 maximum throughput that can be achieved by a tcp connection with a 64 kbytes window in function of the connection’s round-trip-time
to solve this problem, a backward compatible extension that allows tcp to use larger receive windows was proposed in rfc 1323. today, most tcp implementations support this option. the basic idea is that instead of
18 when these measurements were taken, some hosts had a default mss of 552 bytes (e.g. bsd unix derivatives) or 536 bytes (the default mss speciﬁed in rfc 793). today, most tcp implementation derive the mss from the maximum packet size of the lan interface they use (ethernet in most cases).
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
the longest preﬁx match can be implemented by using different data structures. one possibility is to use a trie. the ﬁgure below shows a trie that encodes six routes having different outgoing interfaces.
note: special ipv4 addresses most unicast ipv4 addresses can appear as source and destination addresses in packets on the global internet. however, it is worth noting that some blocks of ipv4 addresses have a special usage, as described in rfc 5735. these include :
if, unfortunately, the distance vector sent to router c is lost due to a transmission error or because router c is overloaded, a new count to inﬁnity problem can occur. if router c sends its distance vector [a = 2, b = 1, c = 0, e = ∞] to router e, this router installs a route of distance 3 to reach a via c. router e sends its distance vectors [a = 3, b = ∞, c = 1, e = 1] to router b and [a = ∞, b = 1, c = ∞, e = 0] to router c. this distance vector allows b to recover a route of distance 4 to reach a.
link state routing is the second family of routing protocols. while distance vector routers use a distributed algorithm to compute their routing tables, link-state routers exchange messages to allow each router to learn the entire network topology. based on this learned topology, each router is then able to compute its routing table by using a shortest path computation [dijkstra1959]. for link-state routing, a network is modelled as a directed weighted graph. each router is a node, and the links between routers are the edges in the graph. a positive weight is associated to each directed edge and routers use the shortest path to reach each destination. in practice, different types of weight can be associated to each directed edge :
bandwidth where c is a constant larger than the highest link bandwidth in the network. if all link weights are conﬁgured this way, shortest path routing prefers higher bandwidth paths over lower bandwidth paths
usually, the same weight is associated to the two directed edges that correspond to a physical link (i.e. r1 → r2 and r2 → r1). however, nothing in the link state protocols requires this. for example, if the weight is set in function of the link bandwidth, then an asymmetric adsl link could have a different weight for the upstream and downstream directions. other variants are possible. some networks use optimisation algorithms to ﬁnd the best set of weights to minimize congestion inside the network for a given trafﬁc demand [frt2002]. when a link-state router boots, it ﬁrst needs to discover to which routers it is directly connected. for this, each router sends a hello message every n seconds on all of its interfaces. this message contains the router’s address. each router has a unique address. as its neighbouring routers also send hello messages, the router automatically discovers to which neighbours it is connected. these hello messages are only sent to neighbours who are directly connected to a router, and a router never forwards the hello messages that they receive. hello messages are also used to detect link and router failures. a link is considered to have failed if no hello message has been received from the neighbouring router for a period of k × n seconds.
the ethernet frame format shown above is speciﬁed in [dix]. this is the format used to send both ipv4 rfc 894 and ipv6 packets rfc 2464. after the publication of [dix], the institute of electrical and electronic engineers (ieee) began to standardise several local area network technologies. ieee worked on several lan technologies, starting with ethernet, token ring and token bus. these three technologies were completely different, but they all agreed to use the 48 bits mac addresses speciﬁed initially for ethernet [802]_ . while developing its ethernet standard [802.3], the ieee 802.3 working group was confronted with a problem. ethernet mandated a minimum payload size of 46 bytes, while some companies were looking for a lan technology that could transparently transport short frames containing only a few bytes of payload. such a frame can be sent by an ethernet host by padding it to ensure that the payload is at least 46 bytes long. however since the ethernet header [dix] does not contain a length ﬁeld, it is impossible for the receiver to determine how many useful bytes were placed inside the payload ﬁeld. to solve this problem, the ieee decided to replace the type ﬁeld of the ethernet [dix] header with a length ﬁeld 9. this length ﬁeld contains the number of useful bytes in the frame payload. the payload must still contain at least 46 bytes, but padding bytes are added by the sender and removed by the receiver. in order to add the length ﬁeld without signiﬁcantly changing the frame format, ieee had to remove the type ﬁeld. without this ﬁeld, it is impossible for a receiving host to identify the type of network layer packet inside a received frame. to solve this new problem, ieee developed a completely new sublayer called the logical link control [802.2]. several protocols were deﬁned in this sublayer. one of them provided a slightly different version of the type ﬁeld of the original ethernet frame format. another contained acknowledgements and retransmissions to provide a reliable service... in practice, [802.2] is never used to support ip in ethernet networks. the ﬁgure below shows the ofﬁcial [802.3] frame format.
9 fortunately, ieee was able to deﬁne the [802.3] frame format while maintaining backward compatibility with the ethernet [dix] frame format. the trick was to only assign values above 1500 as ethertype values. when a host receives a frame, it can determine whether the frame’s format by checking its ethertype/length ﬁeld. a value lower smaller than 1501 is clearly a length indicator and thus an [802.3] frame. a value larger than 1501 can only be type and thus a [dix] frame.
the ethernet frame format shown above is speciﬁed in [dix]. this is the format used to send both ipv4 rfc 894 and ipv6 packets rfc 2464. after the publication of [dix], the institute of electrical and electronic engineers (ieee) began to standardise several local area network technologies. ieee worked on several lan technologies, starting with ethernet, token ring and token bus. these three technologies were completely different, but they all agreed to use the 48 bits mac addresses speciﬁed initially for ethernet [802]_ . while developing its ethernet standard [802.3], the ieee 802.3 working group was confronted with a problem. ethernet mandated a minimum payload size of 46 bytes, while some companies were looking for a lan technology that could transparently transport short frames containing only a few bytes of payload. such a frame can be sent by an ethernet host by padding it to ensure that the payload is at least 46 bytes long. however since the ethernet header [dix] does not contain a length ﬁeld, it is impossible for the receiver to determine how many useful bytes were placed inside the payload ﬁeld. to solve this problem, the ieee decided to replace the type ﬁeld of the ethernet [dix] header with a length ﬁeld 9. this length ﬁeld contains the number of useful bytes in the frame payload. the payload must still contain at least 46 bytes, but padding bytes are added by the sender and removed by the receiver. in order to add the length ﬁeld without signiﬁcantly changing the frame format, ieee had to remove the type ﬁeld. without this ﬁeld, it is impossible for a receiving host to identify the type of network layer packet inside a received frame. to solve this new problem, ieee developed a completely new sublayer called the logical link control [802.2]. several protocols were deﬁned in this sublayer. one of them provided a slightly different version of the type ﬁeld of the original ethernet frame format. another contained acknowledgements and retransmissions to provide a reliable service... in practice, [802.2] is never used to support ip in ethernet networks. the ﬁgure below shows the ofﬁcial [802.3] frame format.
9 fortunately, ieee was able to deﬁne the [802.3] frame format while maintaining backward compatibility with the ethernet [dix] frame format. the trick was to only assign values above 1500 as ethertype values. when a host receives a frame, it can determine whether the frame’s format by checking its ethertype/length ﬁeld. a value lower smaller than 1501 is clearly a length indicator and thus an [802.3] frame. a value larger than 1501 can only be type and thus a [dix] frame.
the best solution to allow bgp routers to distribute, inside an as, all the routes learned over bgp sessions is to establish bgp sessions among all the bgp routers inside the as. in practice, there are two types of bgp sessions :
in practice, each bgp router inside a domain maintains an ibgp session with every other bgp router in the domain 34. this creates a full-mesh of ibgp sessions among all bgp routers of the domain. ibgp sessions, like ebgp sessions run over tcp connections. note that in contrast with ebgp sessions that are established between directly connected routers, ibgp sessions are often established between routers that are not directly connected. an important point to note about ibgp sessions is that a bgp router only advertises a route over an ibgp session provided that :
a bgp router does not advertise a route that it has learned over an ibgp session over another ibgp session. note that a router can, of course, advertise over an ebgp session a route that it has learned over an ibgp session. this difference between the behaviour of a bgp router over ibgp and ebgp session is due to the utilisation of a full-mesh of ibgp sessions. consider a network containing three bgp routers : a, b and c interconnected via a full-mesh of ibgp sessions. if router a learns a route towards preﬁx p from router b, router a does not need to advertise the received route to router c since router c also learns the same route over the c-b ibgp session. let us consider what happens when router r1 sends to understand the utilisation of an ibgp session, u(194.100.0.0/23,195.100.0.1,as10) in the network shown below. this bgp message is processed by r2 which advertises it over its ibgp session with r4. the bgp update sent by r2 contains the same nexthop and the same as-path as in the bgp update received by r2. r4 then sends u(194.100.0.0/23,195.100.0.5,as20:as10) to r3. note that the bgp nexthop and the as-path are only updated 35 when a bgp route is advertised over an ebgp session.
note: loopback interfaces and ibgp sessions in addition to their physical interfaces, routers can also be conﬁgured with a special loopback interface. a loopback interface is a software interface that is always up. when a loopback interface is conﬁgured on a router, the address associated to this interface is advertised by the intradomain routing protocol. consider for example
34 using a full-mesh of ibgp sessions is suitable in small networks. however, this solution does not scale in large networks containing ibgp sessions must be established in a domain containing n bgp routers. large domains use either
hundreds or more routers since n×(n−1) route reﬂection rfc 4456 or confederations rfc 5065 to scale their ibgp, but this goes beyond this introduction.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.8/30195.100.0.9195.100.0.10ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
of the network. from a performance perspective, it would be more interesting to have devices that operate in the datalink layer and can analyse the destination address of each frame and forward the frames selectively on the link that leads to the destination. such devices are usually called ethernet switches 10. an ethernet switch is a relay that operates in the datalink layer as is illustrated in the ﬁgure below.
an ethernet switch understands the format of the ethernet frames and can selectively forward frames over each interface. for this, each ethernet switch maintains a mac address table. this table contains, for each mac address known by the switch, the identiﬁer of the switch’s port over which a frame sent towards this address must be forwarded to reach its destination. this is illustrated below with the mac address table of the bottom switch. when the switch receives a frame destined to address b, it forwards the frame on its south port. if it receives a frame destined to address d, it forwards it only on its north port.
one of the selling points of ethernet networks is that, thanks to the utilisation of 48 bits mac addresses, an ethernet lan is plug and play at the datalink layer. when two hosts are attached to the same ethernet segment or hub, they can immediately exchange ethernet frames without requiring any conﬁguration. it is important to retain this plug and play capability for ethernet switches as well. this implies that ethernet switches must be able to build their mac address table automatically without requiring any manual conﬁguration. this automatic conﬁguration is performed by the the mac address learning algorithm that runs on each ethernet switch. this algorithm extracts the source address of the received frames and remembers the port over which a frame from
10 the ﬁrst ethernet relays that operated in the datalink layers were called bridges. in practice, the main difference between switches and bridges is that bridges were usually implemented in software while switches are hardware-based devices. throughout this text, we always use switch when referring to a relay in the datalink layer, but you might still see the word bridge.
of the network. from a performance perspective, it would be more interesting to have devices that operate in the datalink layer and can analyse the destination address of each frame and forward the frames selectively on the link that leads to the destination. such devices are usually called ethernet switches 10. an ethernet switch is a relay that operates in the datalink layer as is illustrated in the ﬁgure below.
an ethernet switch understands the format of the ethernet frames and can selectively forward frames over each interface. for this, each ethernet switch maintains a mac address table. this table contains, for each mac address known by the switch, the identiﬁer of the switch’s port over which a frame sent towards this address must be forwarded to reach its destination. this is illustrated below with the mac address table of the bottom switch. when the switch receives a frame destined to address b, it forwards the frame on its south port. if it receives a frame destined to address d, it forwards it only on its north port.
one of the selling points of ethernet networks is that, thanks to the utilisation of 48 bits mac addresses, an ethernet lan is plug and play at the datalink layer. when two hosts are attached to the same ethernet segment or hub, they can immediately exchange ethernet frames without requiring any conﬁguration. it is important to retain this plug and play capability for ethernet switches as well. this implies that ethernet switches must be able to build their mac address table automatically without requiring any manual conﬁguration. this automatic conﬁguration is performed by the the mac address learning algorithm that runs on each ethernet switch. this algorithm extracts the source address of the received frames and remembers the port over which a frame from
10 the ﬁrst ethernet relays that operated in the datalink layers were called bridges. in practice, the main difference between switches and bridges is that bridges were usually implemented in software while switches are hardware-based devices. throughout this text, we always use switch when referring to a relay in the datalink layer, but you might still see the word bridge.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
the easiest way to understand the operation of arp is to consider the simple network shown above and assume that host 10.0.1.22/24 needs to send an ipv4 packet to host 10.0.1.8. as this ip address belongs to the same subnet, the packet must be sent directly to its destination via the datalink layer service. to use this service, the sending host must ﬁnd the datalink layer address that is attached to host 10.0.1.8. each ipv4 host maintains an arp cache containing the list of all mappings between ipv4 addresses and datalink layer addresses that it knows. when an ipv4 hosts boots, its arp cache is empty. 10.0.1.22 thus ﬁrst consults its arp cache. as the cache does not contain the requested mapping, host 10.0.1.22 sends a broadcast arp query frame on the lan. the frame contains the datalink layer address of the sending host (a) and the requested ipv4 address (10.0.1.8). this broadcast frame is received by all devices on the lan and only the host that owns the requested ipv4 address replies by returning a unicast arp reply frame with the requested mapping. upon reception of this reply, the sending host updates its arp cache and sends the ipv4 packet by using the datalink layer service. to deal with devices that move or whose addresses are reconﬁgured, most arp implementations remove the cache entries that have not been used for a few minutes. some implementations re-validate arp cache entries from time to time by sending arp queries 13.
note: security issues with the address resolution protocol arp is an old and widely used protocol that was unfortunately designed when security issues were not a concern. arp is almost insecure by design. hosts using arp can be subject to several types of attack. first, a malicious host could create a denial of service attack on a lan by sending random replies to the received arp queries. this would pollute the arp cache of the other hosts on the same lan. on a ﬁxed network, such attacks can be detected by the system administrator who can physically remove the malicious hosts from the lan. on a wireless network, removing a malicious host is much more difﬁcult. a second type of attack are the man-in-the-middle attacks. this name is used for network attacks where the attacker is able to read and possibly modify all the messages sent by the attacked devices. such an attack is possible in a lan. assume, in the ﬁgure above, that host 10.0.1.9 is malicious and would like to receive and modify all the packets sent by host 10.0.1.22 to host 10.0.1.8. this can be achieved easily if host 10.0.1.9 manages, by sending fake arp replies, to convince host 10.0.1.22 (resp. 10.0.1.8) that its own datalink layer address must be used to reach 10.0.1.8 (resp. 10.0.1.22).
arp is used by all devices that are connected to a lan and implement ipv4. both routers and endhosts implement arp. when a host needs to send an ipv4 packet to a destination outside of its local subnet, it must ﬁrst send the packet to one of the routers that reside on this subnet. consider for example the network shown in the ﬁgure below. each host is conﬁgured with an ipv4 address in the 10.0.1.0/24 subnet and uses 10.0.1.1 as its default router. to send a packet to address 1.2.3.4, host 10.0.1.8 will ﬁrst need to know the datalink layer of the default router. it will thus send an arp request for 10.0.1.1. upon reception of the arp reply, host 10.0.1.8 updates its arp table and sends its packet in a frame to its default router. the router will then forward the packet towards its ﬁnal destination.
in the early days of the internet, ip addresses were manually conﬁgured on both hosts and routers and almost never changed. however, this manual conﬁguration can be complex 14 and often causes errors that are sometimes difﬁcult to debug. recent tcp/ip implementations are able to detect some of these misconﬁgurations. for example, if two hosts are attached to the same subnet with the same ipv4 address they will be unable to communicate. to detect this problem hosts send an arp request for their conﬁgured address each time their addressed is changed rfc 5227. if they receive an answer to this arp request, they trigger an alarm or inform the system administrator.
13 see chapter 28 of [benvenuti2005] for a description of the implementation of arp in the linux kernel. 14 for example, consider all the options that can be speciﬁed for the ifconﬁg utility<http://en.wikipedia.org/wiki/ifconﬁg> on unix hosts.
• the physical layer may deliver more bits to the receiver than the bits sent by the sender • the physical layer may deliver fewer bits to the receiver than the bits sent by the sender
the datalink layer must allow endsystems to exchange frames containing packets despite all of these limitations. on point-to-point links and local area networks, the ﬁrst problem to be solved is how to encode a frame as a sequence of bits, so that the receiver can easily recover the received frame despite the limitations of the physical layer. if the physical layer were perfect, the problem would be very simple. the datalink layer would simply need to deﬁne how to encode each frame as a sequence of consecutive bits. the receiver would then easily be able to extract the frames from the received bits. unfortunately, the imperfections of the physical layer make this framing problem slightly more complex. several solutions have been proposed and are used in practice in different datalink layer technologies.
this is the framing problem. it can be deﬁned as : “how does a sender encode frames so that the receiver can efﬁciently extract them from the stream of bits that it receives from the physical layer”. a ﬁrst solution to solve the framing problem is to require the physical layer to remain idle for some time after the transmission of each frame. these idle periods can be detected by the receiver and serve as a marker to delineate frame boundaries. unfortunately, this solution is not sufﬁcient for two reasons. first, some physical layers cannot remain idle and always need to transmit bits. second, inserting an idle period between frames decreases the maximum bandwidth that can be achieved by the datalink layer. some physical layers provide an alternative to this idle period. all physical layers are able to send and receive physical symbols that represent values 0 and 1. however, for various reasons that are outside the scope of this chapter, several physical layers are able to exchange other physical symbols as well. for example, the manchester encoding used in several physical layers can send four different symbols. the manchester encoding is a differential encoding scheme in which time is divided into ﬁxed-length periods. each period is divided in two halves and two different voltage levels can be applied. to send a symbol, the sender must set one of these two voltage levels during each half period. to send a 1 (resp. 0), the sender must set a high (resp. low) voltage during the ﬁrst half of the period and a low (resp. high) voltage during the second half. this encoding ensures that there will be a transition at the middle of each period and allows the receiver to synchronise its clock to the sender’s clock. apart from the encodings for 0 and 1, the manchester encoding also supports two additional symbols : invh and invb where the same voltage level is used for the two half periods. by deﬁnition, these two symbols cannot appear inside a frame which is only composed of 0 and 1. some technologies use these special symbols as markers for the beginning or end of frames.
unfortunately, multi-symbol encodings cannot be used by all physical layers and a generic solution which can be used with any physical layer that is able to transmit and receive only 0 and 1 is required. this generic solution is called stufﬁng and two variants exist : bit stufﬁng and character stufﬁng. to enable a receiver to easily delineate the frame boundaries, these two techniques reserve special bit strings as frame boundary markers and encode the frames so that these special bit strings do not appear inside the frames. bit stufﬁng reserves the 01111110 bit string as the frame boundary marker and ensures that there will never be six consecutive 1 symbols transmitted by the physical layer inside a frame. with bit stufﬁng, a frame is sent as follows. first, the sender transmits the marker, i.e. 01111110. then, it sends all the bits of the frame and inserts
depicted below which is similar to the one discussed in [jacobson1988] and rfc 896. in this network, we assume that the buffers of the router are inﬁnite to ensure that no packet is lost.
if many tcp senders are attached to the left part of the network above, they all send a window full of segments. these segments are stored in the buffers of the router before being transmitted towards their destination. if there are many senders on the left part of the network, the occupancy of the buffers quickly grows. a consequence of the buffer occupancy is that the round-trip-time, measured by tcp, between the sender and the receiver increases. consider a network where 10,000 bits segments are sent. when the buffer is empty, such a segment requires 1 millisecond to be transmitted on the 10 mbps link and 5 milliseconds to be the transmitted on the 2 mbps link. thus, the round-trip-time measured by tcp is roughly 6 milliseconds if we ignore the propagation delay on the links. most routers manage their buffers as a fifo queue 25. if the buffer contains 100 segments, the round-triptime becomes 1 + 100 × 5 + 5 milliseconds as new segments are only transmitted on the 2 mbps link once all previous segments have been transmitted. unfortunately, tcp uses a retransmission timer and performs go-back-n to recover from transmission errors. if the buffer occupancy is high, tcp assumes that some segments have been lost and retransmits a full window of segments. this increases the occupancy of the buffer and the delay through the buffer... furthermore, the buffer may store and send on the low bandwidth links several retransmissions of the same segment. this problem is called congestion collapse. it occurred several times in the late 1980s. for example, [jacobson1988] notes that in 1986, the usable bandwidth of a 32 kbits link dropped to 40 bits per second due to congestion collapse 26 ! the congestion collapse is a problem that all heterogeneous networks face. different mechanisms have been proposed in the scientiﬁc literature to avoid or control network congestion. some of them have been implemented and deployed in real networks. to understand this problem in more detail, let us ﬁrst consider a simple network with two hosts attached to a high bandwidth link that are sending segments to destination c attached to a low bandwidth link as depicted below.
to avoid congestion collapse, the hosts must regulate their transmission rate 27 by using a congestion control mechanism. such a mechanism can be implemented in the transport layer or in the network layer. in tcp/ip networks, it is implemented in the transport layer, but other technologies such as asynchronous transfer mode (atm) or frame relay include congestion control mechanisms in lower layers. let us ﬁrst consider the simple problem of a set of i hosts that share a single bottleneck link as shown in the example above. in this network, the congestion control scheme must achieve the following objectives [cj1989] :
25 we discuss in another chapter other possible organisations of the router’s buffers. 26 at this time, tcp implementations were mainly following rfc 791. the round-trip-time estimations and the retransmission mechanisms
27 in this section, we focus on congestion control mechanisms that regulate the transmission rate of the hosts. other types of mechanisms have been proposed in the literature. for example, credit-based ﬂow-control has been proposed to avoid congestion in atm networks [kr1995]. with a credit-based mechanism, hosts can only send packets once they have received credits from the routers and the credits depend on the occupancy of the router’s buffers.
second, as the network layer is imperfect, the cr or ca segment can be lost, delayed, or suffer from transmission errors. to deal with these problems, the control segments must be protected by using a crc or checksum to detect transmission errors. furthermore, since the ca segment acknowledges the reception of the cr segment, the cr segment can be protected by using a retransmission timer. unfortunately, this scheme is not sufﬁcient to ensure the reliability of the transport service. consider for example a short-lived transport connection where a single, but important transfer (e.g. money transfer from a bank account) is sent. such a short-lived connection starts with a cr segment acknowledged by a ca segment, then the data segment is sent, acknowledged and the connection terminates. unfortunately, as the network layer service is unreliable, delays combined to retransmissions may lead to the situation depicted in the ﬁgure below, where a delayed cr and data segments from a former connection are accepted by the receiving entity as valid segments, and the corresponding data is delivered to the user. duplicating sdus is not acceptable, and the transport protocol must solve this problem.
to avoid these duplicates, transport protocols require the network layer to bound the maximum segment lifetime (msl). the organisation of the network must guarantee that no segment remains in the network for longer than msl seconds. on today’s internet, msl is expected to be 2 minutes. to avoid duplicate transport connections, transport protocol entities must be able to safely distinguish between a duplicate cr segment and a new cr segment, without forcing each transport entity to remember all the transport connections that it has established in the past. a classical solution to avoid remembering the previous transport connections to detect duplicates is to use a clock inside each transport entity. this transport clock has the following characteristics :
• the transport clock is implemented as a k bits counter and its clock cycle is such that 2k × cycle >> m sl. furthermore, the transport clock counter is incremented every clock cycle and after each connection establishment. this clock is illustrated in the ﬁgure below.
it should be noted that transport clocks do not need and usually are not synchronised to the real-time clock. precisely synchronising real-time clocks is an interesting problem, but it is outside the scope of this document. see [mills2006] for a detailed discussion on synchronising the real-time clock.
explicitly the sender of the reception of d(2,c) and the sender could retransmit this segment although it has already been received. a possible solution to improve the performance of selective repeat is to provide additional information about the received segments in the acknowledgements that are returned by the receiver. for example, the receiver could add in the returned acknowledgement the list of the sequence numbers of all segments that have already been received. such acknowledgements are sometimes called selective acknowledgements. this is illustrated in the ﬁgure below. in the ﬁgure above, when the sender receives c(ok,0,[2]), it knows that all segments up to and including d(0,...) have been correctly received. it also knows that segment d(2,...) has been received and can cancel the retransmission timer associated to this segment. however, this segment should not be removed from the sending buffer before the reception of a cumulative acknowledgement (c(ok,2) in the ﬁgure above) that covers this segment.
note: maximum window size with go-back-n and selective repeat a transport protocol that uses n bits to encode its sequence number can send up to 2n different segments. however, to ensure a reliable delivery of the segments, go-back-n and selective repeat cannot use a sending window of 2n segments. consider ﬁrst go-back-n and assume that a sender sends 2n segments. these segments are received in-sequence by the destination, but all the returned acknowledgements are lost. the sender will retransmit all segments and they will all be accepted by the receiver and delivered a second time to the user. it is easy to see that this problem can be avoided if the maximum size of the sending window is 2n − 1 segments. a similar problem occurs with selective repeat. however, as the receiver accepts out-of-sequence segments, a sending window of 2n − 1 segments is not sufﬁcient to ensure a reliable delivery of all segments. it can be easily shown that to avoid this problem, a selective repeat sender cannot use a window that is larger than 2n
go-back-n or selective repeat are used by transport protocols to provide a reliable data transfer above an unreliable network layer service. until now, we have assumed that the size of the sliding window was ﬁxed for the entire lifetime of the connection. in practice a transport layer entity is usually implemented in the operating system and shares memory with other parts of the system. furthermore, a transport layer entity must support several (possibly hundreds or thousands) of transport connections at the same time. this implies that the memory which can be used to support the sending or the receiving buffer of a transport connection may change during the lifetime of the connection 4 . thus, a transport protocol must allow the sender and the receiver to adjust their window sizes. to deal with this issue, transport protocols allow the receiver to advertise the current size of its receiving window in all the acknowledgements that it sends. the receiving window advertised by the receiver bounds the size of the sending buffer used by the sender. in practice, the sender maintains two state variables : swin, the size of its sending window (that may be adjusted by the system) and rwin, the size of the receiving window advertised by the receiver. at any time, the number of unacknowledged segments cannot be larger than min(swin,rwin) 5 . the utilisation of dynamic windows is illustrated in the ﬁgure below. the receiver may adjust its advertised receive window based on its current memory consumption, but also to limit the bandwidth used by the sender. in practice, the receive buffer can also shrink as the application may not able to process the received data quickly enough. in this case, the receive buffer may be completely full and the advertised receive window may shrink to 0. when the sender receives an acknowledgement with a receive window set to 0, it is blocked until it receives an acknowledgement with a positive receive window. unfortunately, as shown in the ﬁgure below, the loss of this acknowledgement could cause a deadlock as the sender waits for an acknowledgement while the receiver is waiting for a data segment. to solve this problem, transport protocols rely on a special timer : the persistence timer. this timer is started by the sender whenever it receives an acknowledgement advertising a receive window set to 0. when the timer expires, the sender retransmits an old segment in order to force the receiver to send a new acknowledgement, and hence send the current receive window size. to conclude our description of the basic mechanisms found in transport protocols, we still need to discuss the impact of segments arriving in the wrong order. if two consecutive segments are reordered, the receiver relies on their sequence numbers to reorder them in its receive buffer. unfortunately, as transport protocols reuse the same sequence number for different segments, if a segment is delayed for a prolonged period of time, it might still be accepted by the receiver. this is illustrated in the ﬁgure below where segment d(1,b) is delayed.
4 for a discussion on how the sending buffer can change, see e.g. [smm1998] 5 note that if the receive window shrinks, it might happen that the sender has already sent a segment that is not anymore inside its window.
denial of service attacks when a tcp entity opens a tcp connection, it creates a transmission control block (tcb). the tcb contains the entire state that is maintained by the tcp entity for each tcp connection. during connection establishment, the tcb contains the local ip address, the remote ip address, the local port number, the remote port number, the current local sequence number, the last sequence number received from the remote entity. until the mid 1990s, tcp implementations had a limit on the number of tcp connections that could be in the syn rcvd state at a given time. many implementations set this limit to about 100 tcbs. this limit was considered sufﬁcient even for heavily load http servers given the small delay between the reception of a syn segment and the reception of the ack segment that terminates the establishment of the tcp connection. when the limit of 100 tcbs in the syn rcvd state is reached, the tcp entity discards all received tcp syn segments that do not correspond to an existing tcb. this limit of 100 tcbs in the syn rcvd state was chosen to protect the tcp entity from the risk of overloading its memory with too many tcbs in the syn rcvd state. however, it was also the reason for a new type of denial of service (dos) attack rfc 4987. a dos attack is deﬁned as an attack where an attacker can render a resource unavailable in the network. for example, an attacker may cause a dos attack on a 2 mbps link used by a company by sending more than 2 mbps of packets through this link. in this case, the dos attack was more subtle. as a tcp entity discards all received syn segments as soon as it has 100 tcbs in the syn rcvd state, an attacker simply had to send a few 100 syn segments every second to a server and never reply to the received syn+ack segments. to avoid being caught, attackers were of course sending these syn segments with a different address than their own ip address a. on most tcp implementations, once a tcb entered the syn rcvd state, it remained in this state for several seconds, waiting for a retransmission of the initial syn segment. this attack was later called a syn ﬂood attack and the servers of the isp named panix were among the ﬁrst to be affected by this attack. to avoid the syn ﬂood attacks, recent tcp implementations no longer enter the syn rcvd state upon reception of a syn segment. instead, they reply directly with a syn+ack segment and wait until the reception of a valid ack. this implementation trick is only possible if the tcp implementation is able to verify that the received ack segment acknowledges the syn+ack segment sent earlier without storing the initial sequence number of this syn+ack segment in a tcb. the solution to solve this problem, which is known as syn cookies is to compute the 32 bits of the isn as follows :
• the high order bits contain the low order bits of a counter that is incremented slowly • the low order bits contain a hash value computed over the local and remote ip addresses and ports and
the advantage of the syn cookies is that by using them, the server does not need to create a tcb upon reception of the syn segment and can still check the returned ack segment by recomputing the syn cookie.
retransmitting the ﬁrst syn segment as ip provides an unreliable connectionless service, the syn and syn+ack segments sent to open a tcp connection could be lost. current tcp implementations start a retransmission timer when they send the ﬁrst syn segment. this timer is often set to three seconds for the ﬁrst retransmission and then doubles after each retransmission rfc 2988. tcp implementations also enforce a maximum number of retransmissions for the initial syn segment.
as explained earlier, tcp segments may contain an optional header extension. in the syn and syn+ack segments, these options are used to negotiate some parameters and the utilisation of extensions to the basic tcp speciﬁcation. the ﬁrst parameter which is negotiated during the establishment of a tcp connection is the maximum segment size (mss). the mss is the size of the largest segment that a tcp entity is able to process. according to rfc 879, all tcp implementations must be able to receive tcp segments containing 536 bytes of payload. however, most tcp implementations are able to process larger segments. such tcp implementations use the tcp mss option in the syn/syn+ack segment to indicate the largest segment they are able to process. the mss value indicates the maximum size of the payload of the tcp segments. the client (resp. server) stores in its tcb the mss value announced by the server (resp. the client).
or permanent error in routing tables 7. consider for example the situation depicted in the ﬁgure below where destination d uses address 11.0.0.56. if s sends a packet towards this destination, the packet is forwarded to router b which forwards it to router c that forwards it back to router a, etc.
unfortunately, such loops can occur for two reasons in ip networks. first, if the network uses static routing, the loop can be caused by a simple conﬁguration error. second, if the network uses dynamic routing, such a loop can occur transiently, for example during the convergence of the routing protocol after a link or router failure. the ttl ﬁeld of the ipv4 header ensures that even if there are forwarding loops in the network, packets will not loop forever. hosts send their ipv4 packets with a positive ttl (usually 64 or more 8). when a router receives an ipv4 packet, it ﬁrst decrements the ttl by one. if the ttl becomes 0, the packet is discarded and a message is sent back to the packet’s source (see section icmp). otherwise, the router performs a lookup in its forwarding table to forward the packet. a second problem for ipv4 is the heterogeneity of the datalink layer. ipv4 is used above many very different datalink layers. each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterised by a maximum frame size. from ip’s point of view, a datalink layer interface is characterised by its maximum transmission unit (mtu). the mtu of an interface is the largest ipv4 packet (including header) that it can send. the table below provides some common mtu sizes 9.
although ipv4 can send 64 kbytes long packets, few datalink layer technologies that are used today are able to send a 64 kbytes ipv4 packet inside a frame. furthermore, as illustrated in the ﬁgure below, another problem is that a host may send a packet that would be too large for one of the datalink layers used by the intermediate routers.
7 the initial ip speciﬁcation in rfc 791 suggested that routers would decrement the ttl at least once every second. this would ensure that a packet would never remain for more than ttl seconds in the network. however, in practice most router implementations simply chose to decrement the ttl by one.
to solve these problems, ipv4 includes a packet fragmentation and reassembly mechanism. both hosts and intermediate routers may fragment an ipv4 packet if the packet is too long to be sent via the datalink layer. in ipv4, fragmentation is completely performed in the ip layer and a large ipv4 is fragmented into two or more ipv4 packets (called fragments). the ipv4 fragments of a large packet are normal ipv4 packets that are forwarded towards the destination of the large packet by intermediate routers. the ipv4 fragmentation mechanism relies on four ﬁelds of the ipv4 header : length, identiﬁcation, the ﬂags and the fragment offset. the ipv4 header contains two ﬂags : more fragments and don’t fragment (df). when the df ﬂag is set, this indicates that the packet cannot be fragmented. the basic operation of the ipv4 fragmentation is as follows. a large packet is fragmented into two or more fragments. the size of all fragments, except the last one, is equal to the maximum transmission unit of the link used to forward the packet. each ipv4 packet contains a 16 bits identiﬁcation ﬁeld. when a packet is fragmented, the identiﬁcation of the large packet is copied in all fragments to allow the destination to reassemble the received fragments together. in each fragment, the fragment offset indicates, in units of 8 bytes, the position of the payload of the fragment in the payload of the original packet. the length ﬁeld in each fragment indicates the length of the payload of the fragment as in a normal ipv4 packet. finally, the more fragments ﬂag is set only in the last fragment of a large packet. the following pseudo-code details the ipv4 fragmentation, assuming that the packet does not contain options.
the fragments of an ipv4 packet may arrive at the destination in any order, as each fragment is forwarded independently in the network and may follow different paths. furthermore, some fragments may be lost and never reach the destination. the reassembly algorithm used by the destination host is roughly as follows. first, the destination can verify whether a received ipv4 packet is a fragment or not by checking the value of the more fragments ﬂag and the fragment offset. if the fragment offset is set to 0 and the more fragments ﬂag is reset, the received packet has not been fragmented. otherwise, the packet has been fragmented and must be reassembled. the reassembly algorithm relies on the identiﬁcation ﬁeld of the received fragments to associate a fragment with the corresponding packet being reassembled. furthermore, the fragment offset ﬁeld indicates the position of the fragment payload in the original unfragmented packet. finally, the packet with the more fragments ﬂag reset allows the destination to determine the total length of the original unfragmented packet. note that the reassembly algorithm must deal with the unreliability of the ip network. this implies that a fragment may be duplicated or a fragment may never reach the destination. the destination can easily detect fragment duplication thanks to the fragment offset. to deal with fragment losses, the reassembly algorithm must bound the
cases, the service provider responds to the connect.request with a disconnect.indication primitive whose reason parameter contains additional information about the failure of the connection.
once the connection has been established, the service provider supplies two data streams to the communicating users. the ﬁrst data stream can be used by the initiating user to send sdus. the second data stream allows the responding user to send sdus to the initiating user. the data streams can be organised in different ways. a ﬁrst organisation is the message-mode transfer. with the message-mode transfer, the service provider guarantees that one and only one data.indication will be delivered to the endpoint of the data stream for each data.request primitive issued by the other endpoint. the message-mode transfer is illustrated in the ﬁgure below. the main advantage of the message-transfer mode is that the recipient receives exactly the sdus that were sent by the other user. if each sdu contains a command, the receiving user can process each command as soon as it receives a sdu. unfortunately, the message-mode transfer is not widely used on the internet. on the internet, the most popular connection-oriented service transfers sdus in stream-mode. with the stream-mode, the service provider supplies a byte stream that links the two communicating users. the sending user sends bytes by using data.request primitives that contain sequences of bytes as sdus. the service provider delivers sdus containing consecutive bytes to the receiving user by using data.indication primitives. the service provider ensures that all the bytes sent at one end
sourceproviderdestinationtimeconnect.requestconnect.indicationconnect.confirmconnect.responsesource considersconnection opendestination considersconnection opensourceproviderdestinationtimeconnect.requestconnect.indicationdisconnect.indicationdisconnect.requestconnection rejectedby providerconnection rejected by destinationconnect.requestdisconnect.indicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
must forward the entire delimiter to its downstream neighbour. it is only when it receives the fourth bit of the access control ﬁeld (i.e. the token bit) that the station knows whether the frame is a data frame or a token. if the token bit is reset, it indicates a data frame and the remaining bits of the data frame must be forwarded to the downstream station. otherwise (token bit is set), this is a token and the station can capture it by resetting the bit that is currently in its buffer. thanks to this modiﬁcation, the beginning of the token is now the beginning of a data frame and the station can switch to transmit mode and send its data frame starting at the ﬁfth bit of the access control ﬁeld. thus, the one-bit delay introduced by each token ring station plays a key role in enabling the stations to efﬁciently capture the token. after having transmitted its data frame, the station must remain in transmit mode until it has received the last bit of its own data frame. this ensures that the bits sent by a station do not remain in the network forever. a data frame sent by a station in a token ring network passes in front of all stations attached to the network. each station can detect the data frame and analyse the destination address to possibly capture the frame. the frame status ﬁeld that appears after the ending delimiter is used to provide acknowledgements without requiring special frames. the frame status contains two ﬂags : a and c. both ﬂags are reset when a station sends a data frame. these ﬂags can be modiﬁed by their recipients. when a station senses its address as the destination address of a frame, it can capture the frame, check its crc and place it in its own buffers. the destination of a frame must set the a bit (resp. c bit) of the frame status ﬁeld once it has seen (resp. copied) a data frame. by inspecting the frame status of the returning frame, the sender can verify whether its frame has been received correctly by its destination. the text above describes the basic operation of a token ring network when all stations work correctly. unfortunately, a real token ring network must be able to handle various types of anomalies and this increases the complexity of token ring stations. we brieﬂy list the problems and outline their solutions below. a detailed description of the operation of token ring stations may be found in [802.5]. the ﬁrst problem is when all the stations attached to the network start. one of them must bootstrap the network by sending the ﬁrst token. for this, all stations implement a distributed election mechanism that is used to select the monitor. any station can become a monitor. the monitor manages the token ring network and ensures that it operates correctly. its ﬁrst role is to introduce a delay of 24 bit transmission times to ensure that the token can travel smoothly on the ring. second, the monitor sends the ﬁrst token on the ring. it must also verify that the token passes regularly. according to the token ring standard [802.5], a station cannot retain the token to transmit data frames for a duration longer than the token holding time (tht) (slightly less than 10 milliseconds). on a network containing n stations, the monitor must receive the token at least every n × t ht seconds. if the monitor does not receive a token during such a period, it cuts the ring for some time and then reinitialises the ring and sends a token. several other anomalies may occur in a token ring network. for example, a station could capture a token and be powered off before having resent the token. another station could have captured the token, sent its data frame and be powered off before receiving all of its data frame. in this case, the bit string corresponding to the end of a frame would remain in the ring without being removed by its sender. several techniques are deﬁned in [802.5] to allow the monitor to handle all these problems. if unfortunately, the monitor fails, another station will be elected to become the new monitor.
in this section, we review the key characteristics of several datalink layer technologies. we discuss in more detail the technologies that are widely used today. a detailed survey of all datalink layer technologies would be outside the scope of this book.
many point-to-point datalink layers 2 have been developed, starting in the 1960s [mcfadyen1976]. in this section, we focus on the protocols that are often used to transport ip packets between hosts or routers that are directly connected by a point-to-point link. this link can be a dedicated physical cable, a leased line through the telephone network or a dial-up connection with modems on the two communicating hosts.
note: reliability of the connection-oriented service an important point to note about the connection-oriented service is its reliability. a connection-oriented service can only guarantee the correct delivery of all sdus provided that the connection has been released gracefully. this implies that while the connection is active, there is no guarantee for the actual delivery of the sdus exchanged as the connection may need to be released abruptly at any time.
given the growing complexity of computer networks, during the 1970s network researchers proposed various reference models to facilitate the description of network protocols and services. of these, the open systems interconnection (osi) model [zimmermann80] was probably the most inﬂuential. it served as the basis for the standardisation work performed within the iso to develop global computer network standards. the reference model that we use in this book can be considered as a simpliﬁed version of the osi reference model 4.
our reference model is divided into ﬁve layers, as shown in the ﬁgure below. starting from the bottom, the ﬁrst layer is the physical layer. two communicating devices are linked through a physical medium. this physical medium is used to transfer an electrical or optical signal between two directly connected devices. several types of physical mediums are used in practice :
• electrical cable. information can be transmitted over different types of electrical cables. the most common ones are the twisted pairs that are used in the telephone network, but also in enterprise networks and coaxial cables. coaxial cables are still used in cable tv networks, but are no longer used in enterprise networks. some networking technologies operate over the classical electrical cable.
• optical ﬁber. optical ﬁbers are frequently used in public and enterprise networks when the distance between the communication devices is larger than one kilometer. there are two main types of optical ﬁbers : multimode and monomode. multimode is much cheaper than monomode ﬁber because a led can be
sourceproviderdestinationtimedata.request("a")source -> destinationconnection closedconnection openedconnection openeddata.request("b")data.request("c")data.indication("a")data.indication("b")disconnect.req(graceful)disconnect.ind(graceful)data.indication("c")data.indication("d")data.request("d")disconnect.ind(graceful)disconnect.req(graceful)connection closedconnection closedsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
denial of service attacks when a tcp entity opens a tcp connection, it creates a transmission control block (tcb). the tcb contains the entire state that is maintained by the tcp entity for each tcp connection. during connection establishment, the tcb contains the local ip address, the remote ip address, the local port number, the remote port number, the current local sequence number, the last sequence number received from the remote entity. until the mid 1990s, tcp implementations had a limit on the number of tcp connections that could be in the syn rcvd state at a given time. many implementations set this limit to about 100 tcbs. this limit was considered sufﬁcient even for heavily load http servers given the small delay between the reception of a syn segment and the reception of the ack segment that terminates the establishment of the tcp connection. when the limit of 100 tcbs in the syn rcvd state is reached, the tcp entity discards all received tcp syn segments that do not correspond to an existing tcb. this limit of 100 tcbs in the syn rcvd state was chosen to protect the tcp entity from the risk of overloading its memory with too many tcbs in the syn rcvd state. however, it was also the reason for a new type of denial of service (dos) attack rfc 4987. a dos attack is deﬁned as an attack where an attacker can render a resource unavailable in the network. for example, an attacker may cause a dos attack on a 2 mbps link used by a company by sending more than 2 mbps of packets through this link. in this case, the dos attack was more subtle. as a tcp entity discards all received syn segments as soon as it has 100 tcbs in the syn rcvd state, an attacker simply had to send a few 100 syn segments every second to a server and never reply to the received syn+ack segments. to avoid being caught, attackers were of course sending these syn segments with a different address than their own ip address a. on most tcp implementations, once a tcb entered the syn rcvd state, it remained in this state for several seconds, waiting for a retransmission of the initial syn segment. this attack was later called a syn ﬂood attack and the servers of the isp named panix were among the ﬁrst to be affected by this attack. to avoid the syn ﬂood attacks, recent tcp implementations no longer enter the syn rcvd state upon reception of a syn segment. instead, they reply directly with a syn+ack segment and wait until the reception of a valid ack. this implementation trick is only possible if the tcp implementation is able to verify that the received ack segment acknowledges the syn+ack segment sent earlier without storing the initial sequence number of this syn+ack segment in a tcb. the solution to solve this problem, which is known as syn cookies is to compute the 32 bits of the isn as follows :
• the high order bits contain the low order bits of a counter that is incremented slowly • the low order bits contain a hash value computed over the local and remote ip addresses and ports and
the advantage of the syn cookies is that by using them, the server does not need to create a tcb upon reception of the syn segment and can still check the returned ack segment by recomputing the syn cookie.
retransmitting the ﬁrst syn segment as ip provides an unreliable connectionless service, the syn and syn+ack segments sent to open a tcp connection could be lost. current tcp implementations start a retransmission timer when they send the ﬁrst syn segment. this timer is often set to three seconds for the ﬁrst retransmission and then doubles after each retransmission rfc 2988. tcp implementations also enforce a maximum number of retransmissions for the initial syn segment.
as explained earlier, tcp segments may contain an optional header extension. in the syn and syn+ack segments, these options are used to negotiate some parameters and the utilisation of extensions to the basic tcp speciﬁcation. the ﬁrst parameter which is negotiated during the establishment of a tcp connection is the maximum segment size (mss). the mss is the size of the largest segment that a tcp entity is able to process. according to rfc 879, all tcp implementations must be able to receive tcp segments containing 536 bytes of payload. however, most tcp implementations are able to process larger segments. such tcp implementations use the tcp mss option in the syn/syn+ack segment to indicate the largest segment they are able to process. the mss value indicates the maximum size of the payload of the tcp segments. the client (resp. server) stores in its tcb the mss value announced by the server (resp. the client).
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
or permanent error in routing tables 7. consider for example the situation depicted in the ﬁgure below where destination d uses address 11.0.0.56. if s sends a packet towards this destination, the packet is forwarded to router b which forwards it to router c that forwards it back to router a, etc.
unfortunately, such loops can occur for two reasons in ip networks. first, if the network uses static routing, the loop can be caused by a simple conﬁguration error. second, if the network uses dynamic routing, such a loop can occur transiently, for example during the convergence of the routing protocol after a link or router failure. the ttl ﬁeld of the ipv4 header ensures that even if there are forwarding loops in the network, packets will not loop forever. hosts send their ipv4 packets with a positive ttl (usually 64 or more 8). when a router receives an ipv4 packet, it ﬁrst decrements the ttl by one. if the ttl becomes 0, the packet is discarded and a message is sent back to the packet’s source (see section icmp). otherwise, the router performs a lookup in its forwarding table to forward the packet. a second problem for ipv4 is the heterogeneity of the datalink layer. ipv4 is used above many very different datalink layers. each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterised by a maximum frame size. from ip’s point of view, a datalink layer interface is characterised by its maximum transmission unit (mtu). the mtu of an interface is the largest ipv4 packet (including header) that it can send. the table below provides some common mtu sizes 9.
although ipv4 can send 64 kbytes long packets, few datalink layer technologies that are used today are able to send a 64 kbytes ipv4 packet inside a frame. furthermore, as illustrated in the ﬁgure below, another problem is that a host may send a packet that would be too large for one of the datalink layers used by the intermediate routers.
7 the initial ip speciﬁcation in rfc 791 suggested that routers would decrement the ttl at least once every second. this would ensure that a packet would never remain for more than ttl seconds in the network. however, in practice most router implementations simply chose to decrement the ttl by one.
hot potato routing allows as1 to minimise the cost of forwarding packets towards as2. however, there are situations where this is not desirable. for example, assume that as1 and as2 are domains with routers on both the east and the west coast of the us. in these two domains, the high metric associated to links r6-r8 and r0-r2 correspond to the cost of forwarding a packet across the usa. if as2 is a customer that pays as1, it would prefer to receive the packets destined to 1.0.0.0/8 via the r2-r6 link instead of the r7-r3 link. this is the objective of cold potato routing. cold potato routing is implemented using the multi-exit discriminator (med) attribute. this attribute is an optional bgp attribute that may be set 37 by border routers when advertising a bgp route over an ebgp session. the med attribute is usually used to indicate over an ebgp session the cost to reach the bgp nexthop for the advertised route. the med attribute is set by the router that advertises a route over an ebgp session. in the example above, router r2 sends u(1.0.0.0/8,r2,as2,med=1) while r3 sends u(1.0.0.0/8,r3,as2,med=98). assume that the bgp session r7-3 is the ﬁrst to be established. r7 sends u(1.0.0.0/8,r3,as2,med=98) to both r8 and r6. at this point, all routers inside as1 send the packets towards 1.0.0.0/8 via r7-r3. then, the r6r2 bgp session is established and router r6 receives u(1.0.0.0/8,r2,as2,med=1). router r6 runs its decision process for destination 1.0.0.0/8 and selects the route via r2 as its chosen route to reach this preﬁx since this is the only route that it knows. r6 sends u(1.0.0.0/8,r2,as2,med=1) to routers r8 and r7. they both run their decision process and prefer the route advertised by r6, as it contains the smallest med. now, all routers inside as1 forward the packets to 1.0.0.0/8 via link r6-r2 as expected by as2. as router r7 no longer uses the bgp route learned via r3, it must stop advertising it over ibgp sessions and sends w(1.0.0.0/8) over its ibgp sessions with r6 and r8. however, router r7 still keeps the route learned from r3 inside its adj-rib-in. if the r6-r2 link fails, r6 sends w(1.0.0.0/8) over its ibgp sessions and router r7 responds by sending u(1.0.0.0/8,r3,as2,med=98) over its ibgp sessions. in practice, the ﬁfth step of the bgp decision process is slightly more complex, as the routes towards a given preﬁx can be learned from different ases. for example, assume that in ﬁgure hot and cold potato routing, 1.0.0.0/8 is also advertised by as3 (not shown in the ﬁgure) that has peering links with routers r6 and r8. if as3 advertises a route whose med attribute is set to 2 and another with a med set to 3, how should as1‘s router compare the four bgp routes towards 1.0.0.0/8 ? is a med value of 1 from as2 better than a med value of 2 from as3 ? the ﬁfth step of the bgp decision process solves this problem by only comparing the med attribute of the routes learned from the same neighbour as. additional details about the med attribute may be found in rfc 4451. it should be noted that using the med attribute may cause some problems in bgp networks as explained in [gw2002]. in practice, the med attribute is not used on ebgp sessions unless the two domains agree to enable it. the last step of the bgp decision allows the selection of a single route when a bgp router has received several routes that are considered as equal by the ﬁrst six steps of the decision process. this can happen for example in a dual-homed stub attached to two different providers. as shown in the ﬁgure below, router r1 receives two equally good bgp routes towards 1.0.0.0/8. to break the ties, each router is identiﬁed by a unique router-id which in practice is one of the ip addresses assigned to the router. on some routers, the lowest router id step in the bgp decision process is replaced by the selection of the oldest route rfc 5004. preferring the oldest route when breaking ties is used to prefer stable paths over unstable paths. however, a drawback of this approach is that the selection of the bgp routes depends on the arrival times of the corresponding messages. this makes the bgp selection process non-deterministic and can lead to problems that are difﬁcult to debug.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
organisation universite catholique de louvain katholiek universiteit leuven facultes universitaires notre-dame de la paix universite de liege universite libre de bruxelles
these universities are all connected to the internet exclusively via belnet. as each university has been allocated a different address block, the routers of belnet must announce one route for each university and all routers on the internet must maintain a route towards each university. in contrast, consider all the high schools and the government institutions that are connected to the internet via belnet. an address block was assigned to these institutions after the introduction of cidr in the 193.190.0.0/15 address block owned by belnet. with cidr, belnet can announce a single route towards 193.190.0.0/15 that covers all of these high schools. however, there is one difﬁculty with the aggregatable variable length subnets used by cidr. consider for example fedict, a government institution that uses the 193.191.244.0/23 address block. assume that in addition to being connected to the internet via belnet , fedict also wants to be connected to another internet service provider. the fedict network is then said to be multihomed. this is shown in the ﬁgure below.
with such a multihomed network, routers r1 and r2 would have two routes towards ipv4 address 193.191.245.88 : one route via belnet (193.190.0.0/15) and one direct route (193.191.244.0/23). both routes match ipv4 address 193.192.145.88. since rfc 1519 when a router knows several routes towards the same destination address, it must forward packets along the route having the longest preﬁx length. in the case of 193.191.245.88, this is the route 193.191.244.0/23 that is used to forward the packet. this forwarding rule is called the longest preﬁx match or the more speciﬁc match. all ipv4 routers implement this forwarding rule. to understand the longest preﬁx match forwarding, consider the ﬁgure below. with this rule, the route 0.0.0.0/0 plays a particular role. as this route has a preﬁx length of 0 bits, it matches all destination addresses. this route is often called the default route.
note: reliability of the connection-oriented service an important point to note about the connection-oriented service is its reliability. a connection-oriented service can only guarantee the correct delivery of all sdus provided that the connection has been released gracefully. this implies that while the connection is active, there is no guarantee for the actual delivery of the sdus exchanged as the connection may need to be released abruptly at any time.
given the growing complexity of computer networks, during the 1970s network researchers proposed various reference models to facilitate the description of network protocols and services. of these, the open systems interconnection (osi) model [zimmermann80] was probably the most inﬂuential. it served as the basis for the standardisation work performed within the iso to develop global computer network standards. the reference model that we use in this book can be considered as a simpliﬁed version of the osi reference model 4.
our reference model is divided into ﬁve layers, as shown in the ﬁgure below. starting from the bottom, the ﬁrst layer is the physical layer. two communicating devices are linked through a physical medium. this physical medium is used to transfer an electrical or optical signal between two directly connected devices. several types of physical mediums are used in practice :
• electrical cable. information can be transmitted over different types of electrical cables. the most common ones are the twisted pairs that are used in the telephone network, but also in enterprise networks and coaxial cables. coaxial cables are still used in cable tv networks, but are no longer used in enterprise networks. some networking technologies operate over the classical electrical cable.
• optical ﬁber. optical ﬁbers are frequently used in public and enterprise networks when the distance between the communication devices is larger than one kilometer. there are two main types of optical ﬁbers : multimode and monomode. multimode is much cheaper than monomode ﬁber because a led can be
sourceproviderdestinationtimedata.request("a")source -> destinationconnection closedconnection openedconnection openeddata.request("b")data.request("c")data.indication("a")data.indication("b")disconnect.req(graceful)disconnect.ind(graceful)data.indication("c")data.indication("d")data.request("d")disconnect.ind(graceful)disconnect.req(graceful)connection closedconnection closedsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
• snd.una : the earliest sequence number that has been sent but has not yet been acknowledged • snd.wnd : the current size of the sending window (in bytes) • rcv.nxt : the sequence number of the next byte that is expected to be received from the remote host • rcv.wnd : the current size of the receive window advertised by the remote host • sending buffer : a buffer used to store all unacknowledged data • receiving buffer : a buffer to store all data received from the remote host that has not yet been delivered to the user. data may be stored in the receiving buffer because either it was not received in sequence or because the user is too slow to process it
the original tcp speciﬁcation can be categorised as a transport protocol that provides a byte stream service and uses go-back-n. to send new data on an established connection, a tcp entity performs the following operations on the corresponding tcb. it ﬁrst checks that the sending buffer does not contain more data than the receive window advertised by the remote host (rcv.wnd). if the window is not full, up to mss bytes of data are placed in the payload of a tcp segment. the sequence number of this segment is the sequence number of the ﬁrst byte of the payload. it is set to the ﬁrst available sequence number : snd.nxt and snd.nxt is incremented by the length of the payload of the tcp segment. the acknowledgement number of this segment is set to the current value of rcv.nxt and the window ﬁeld of the tcp segment is computed based on the current occupancy of the receiving buffer. the data is kept in the sending buffer in case it needs to be retransmitted later. when a tcp segment with the ack ﬂag set is received, the following operations are performed. rcv.wnd is set to the value of the window ﬁeld of the received segment. the acknowledgement number is compared to snd.una. the newly acknowledged data is remove from the sending buffer and snd.una is updated. if the tcp segment contained data, the sequence number is compared to rcv.nxt. if they are equal, the segment was received in sequence and the data can be delivered to the user and rcv.nxt is updated. the contents of the receiving buffer is checked to see whether other data already present in this buffer can be delivered in sequence to the user. if so, rcv.nxt is updated again. otherwise, the segment’s payload is placed in the receiving buffer.
in a transport protocol such as tcp that offers a bytestream, a practical issue that was left as an implementation choice in rfc 793 is to decide when a new tcp segment containing data must be sent. there are two simple and extreme implementation choices. the ﬁrst implementation choice is to send a tcp segment as soon as the user has requested the transmission of some data. this allows tcp to provide a low delay service. however, if the user is sending data one byte at a time, tcp would place each user byte in a segment containing 20 bytes of tcp header 17. this is a huge overhead that is not acceptable in wide area networks. a second simple solution would be to only transmit a new tcp segment once the user has produced mss bytes of data. this solution reduces the overhead, but at the cost of a potentially very high delay. an elegant solution to this problem was proposed by john nagle in rfc 896. john nagle observed that the overhead caused by the tcp header was a problem in wide area connections, but less in local area connections where the available bandwidth is usually higher. he proposed the following rules to decide to send a new data segment when a new data has been produced by the user or a new ack segment has been received
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
network address translation (nat) was proposed in [te1993] and rfc 3022 as a short term solution to deal with the expected shortage of ipv4 addresses in the late 1980s - early 1990s. combined with cidr, nat helped to signiﬁcantly slow down the consumption of ipv4 addresses. a nat is a middlebox that interconnects two networks that are using ipv4 addresses from different addressing spaces. usually, one of these addressing spaces is the public internet while the other is using the private ipv4 addresses deﬁned in rfc 1918. a very common deployment of nat is in broadband access routers as shown in the ﬁgure below. the broadband access router interconnects a home network, either wifi or ethernet based, and the global internet via one isp over adsl or catv. a single ipv4 address is allocated to the broadband access router and network address translation allows all of the hosts attached to the home network to share a single public ipv4 address.
a second type of deployment is in enterprise networks as shown in the ﬁgure below. in this case, the nat functionality is installed on a border router of the enterprise. a private ipv4 address is assigned to each enterprise host while the border router manages a pool containing several public ipv4 addresses.
as the name implies, a nat is a device that “translates” ip addresses. a nat maintains a mapping table between the private ip addresses used in the internal network and the public ipv4 addresses. nat allows a large number of hosts to share a pool of ip addresses, as these hosts do not all access the global internet at the same time. the simplest nat is a middlebox that uses a one-to-one mapping between a private ip address and a public ip address. to understand its operation, let us assume that a nat, such as the one shown above, has just booted. when the nat receives the ﬁrst packet from source s in the internal network which is destined to the public internet, it creates a mapping between internal address s and the ﬁrst address of its pool of public addresses (p1). then, it translates the received packet so that it can be sent to the public internet. this translation is performed as followed :
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
provide an unreliable service (frames can be corrupted or lost) or a reliable service (in this case, the datalink layer includes retransmission mechanisms similar to the ones used in the transport layer). the unreliable service is frequently used above physical layers (e.g. optical ﬁber, twisted pairs) having a low bit error ratio while reliability mechanisms are often used in wireless networks to recover locally from transmission errors. the second type of datalink layer is the one used in local area networks (lan). conceptually, a lan is a set of communicating devices such that any two devices can directly exchange frames through the datalink layer. both endsystems and routers can be connected to a lan. some lans only connect a few devices, but there are lans that can connect hundreds or even thousands of devices.
in the next chapter, we describe the organisation and the operation of local area networks. an important difference between the point-to-point datalink layers and the datalink layers used in lans is that in a lan, each communicating device is identiﬁed by a unique datalink layer address. this address is usually embedded in the hardware of the device and different types of lans use different types of datalink layer addresses. a communicating device attached to a lan can send a datalink frame to any other communicating device that is attached to the same lan. most lans also support special broadcast and multicast datalink layer addresses. a frame sent to the broadcast address of the lan is delivered to all communicating devices that are attached to the lan. the multicast addresses are used to identify groups of communicating devices. when a frame is sent towards a multicast datalink layer address, it is delivered by the lan to all communicating devices that belong to the corresponding group. the third type of datalink layers are used in non-broadcast multi-access (nbma) networks. these networks are used to interconnect devices like a lan. all devices attached to an nbma network are identiﬁed by a unique datalink layer address. however, and this is the main difference between an nbma network and a traditional lan, the nbma service only supports unicast. the datalink layer service provided by an nbma network supports neither broadcast nor multicast. unfortunately no datalink layer is able to send frames of unlimited side. each datalink layer is characterised by a maximum frame size. there are more than a dozen different datalink layers and unfortunately most of them use a different maximum frame size. the network layer must cope with the heterogeneity of the datalink layer. the network layer itself relies on the following principles :
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
network address translation (nat) was proposed in [te1993] and rfc 3022 as a short term solution to deal with the expected shortage of ipv4 addresses in the late 1980s - early 1990s. combined with cidr, nat helped to signiﬁcantly slow down the consumption of ipv4 addresses. a nat is a middlebox that interconnects two networks that are using ipv4 addresses from different addressing spaces. usually, one of these addressing spaces is the public internet while the other is using the private ipv4 addresses deﬁned in rfc 1918. a very common deployment of nat is in broadband access routers as shown in the ﬁgure below. the broadband access router interconnects a home network, either wifi or ethernet based, and the global internet via one isp over adsl or catv. a single ipv4 address is allocated to the broadband access router and network address translation allows all of the hosts attached to the home network to share a single public ipv4 address.
a second type of deployment is in enterprise networks as shown in the ﬁgure below. in this case, the nat functionality is installed on a border router of the enterprise. a private ipv4 address is assigned to each enterprise host while the border router manages a pool containing several public ipv4 addresses.
as the name implies, a nat is a device that “translates” ip addresses. a nat maintains a mapping table between the private ip addresses used in the internal network and the public ipv4 addresses. nat allows a large number of hosts to share a pool of ip addresses, as these hosts do not all access the global internet at the same time. the simplest nat is a middlebox that uses a one-to-one mapping between a private ip address and a public ip address. to understand its operation, let us assume that a nat, such as the one shown above, has just booted. when the nat receives the ﬁrst packet from source s in the internal network which is destined to the public internet, it creates a mapping between internal address s and the ﬁrst address of its pool of public addresses (p1). then, it translates the received packet so that it can be sent to the public internet. this translation is performed as followed :
many protocols have been deﬁned for networked applications. in this section, we describe some of the important applications that are used on the internet. we ﬁrst explain the domain name system (dns) that enables hosts to be identiﬁed by human-friendly names instead of the ipv4 or ipv6 addresses that are used by the network. then, we describe the operation of electronic mail, one of the ﬁrst killer applications on the global internet, and the protocols used on world wide web.
in the early days of the internet, there were only a few number of hosts (mainly minicomputers) connected to the network. the most popular applications were remote login and ﬁle transfer. by 1983, there were already ﬁve hundred hosts attached to the internet. each of these hosts were identiﬁed by a unique ipv4 address. forcing human users to remember the ipv4 addresses of the remote hosts that they want to use was not user-friendly. human users prefer to remember names, and use them when needed. using names as aliases for addresses is a common technique in computer science. it simpliﬁes the development of applications and allows the developer to ignore the low level details. for example, by using a programming language instead of writing machine code, a developer can write software without knowing whether the variables that it uses are stored in memory or inside registers. because names are at a higher level than addresses, they allow (both in the example of programming above, and on the internet) to treat addresses as mere technical identiﬁers, which can change at will. only the names are stable. on today’s internet, where switching to another isp means changing your ip addresses, the user-friendliness of domain names is less important (they are not often typed by users) but their stability remains a very important, may be their most important property. the ﬁrst solution that allowed applications to use names was the hosts.txt ﬁle. this ﬁle is similar to the symbol table found in compiled code. it contains the mapping between the name of each internet host and its associated ip address 2. it was maintained by sri international that coordinated the network information center (nic). when a new host was connected to the network, the system administrator had to register its name and ip address at the nic. the nic updated the hosts.txt ﬁle on its server. all internet hosts regularly retrieved the updated hosts.txt ﬁle from the server maintained by sri. this ﬁle was stored at a well-known location on each internet host (see rfc 952) and networked applications could use it to ﬁnd the ip address corresponding to a name. a hosts.txt ﬁle can be used when there are up to a few hundred hosts on the network. however, it is clearly not suitable for a network containing thousands or millions of hosts. a key issue in a large network is to deﬁne a suitable naming scheme. the arpanet initially used a ﬂat naming space, i.e. each host was assigned a unique name. to limit collisions between names, these names usually contained the name of the institution and a sufﬁx to identify the host inside the institution (a kind of poor man’s hierarchical naming scheme). on the arpanet few institutions had several hosts connected to the network. however, the limitations of a ﬂat naming scheme became clear before the end of the arpanet and rfc 819 proposed a hierarchical naming scheme. while rfc 819 discussed the possibility of organising the names as a directed graph, the internet opted eventually for a tree structure capable of containing all names. in this tree, the top-level domains are those that are directly attached to the root. the ﬁrst top-level domain was .arpa 3. this top-level name was initially added as a sufﬁx to the names of the hosts attached to the arpanet and listed in the hosts.txt ﬁle. in 1984, the .gov, .edu, .com, .mil and .org generic top-level domain names were added and rfc 1032 proposed the utilisation of the two letter iso-3166 country codes as top-level domain names. since iso-3166 deﬁnes a two letter code for each country recognised by the united nations, this allowed all countries to automatically have a top-level domain. these domains include .be for belgium, .fr for france, .us for the usa, .ie for ireland or .tv for tuvalu, a group of small islands in the paciﬁc and .tm for turkmenistan. today, the set of top-level domain-names is managed by the internet corporation for assigned names and numbers (icann). recently, icann added a dozen of generic top-level domains that are not related to a country and the .cat top-level domain has been registered for the catalan language. there are ongoing discussions within icann to increase the number of top-level domains.
the physical layer allows thus two or more entities that are directly attached to the same transmission medium to exchange bits. being able to exchange bits is important as virtually any information can be encoded as a sequence of bits. electrical engineers are used to processing streams of bits, but computer scientists usually prefer to deal with higher level concepts. a similar issue arises with ﬁle storage. storage devices such as hard-disks also store streams of bits. there are hardware devices that process the bit stream produced by a hard-disk, but computer scientists have designed ﬁlesystems to allow applications to easily access such storage devices. these ﬁlesystems are typically divided into several layers as well. hard-disks store sectors of 512 bytes or more. unix ﬁlesystems group sectors in larger blocks that can contain data or inodes representing the structure of the ﬁlesystem. finally, applications manipulate ﬁles and directories that are translated in blocks, sectors and eventually bits by the operating system. computer networks use a similar approach. each layer provides a service that is built above the underlying layer and is closer to the needs of the applications. the datalink layer builds on the service provided by the underlying physical layer. the datalink layer allows two hosts that are directly connected through the physical layer to exchange information. the unit of information exchanged between two entities in the datalink layer is a frame. a frame is a ﬁnite sequence of bits. some datalink layers use variable-length frames while others only use ﬁxed-length frames. some datalink layers provide a connection-oriented service while others provide a connectionless service. some datalink layers provide reliable delivery while others do not guarantee the correct delivery of the information. an important point to note about the datalink layer is that although the ﬁgure below indicates that two entities of the datalink layer exchange frames directly, in reality this is slightly different. when the datalink layer entity on the left needs to transmit a frame, it issues as many data.request primitives to the underlying physical layer as there are bits in the frame. the physical layer will then convert the sequence of bits in an electromagnetic or optical signal that will be sent over the physical medium. the physical layer on the right hand side of the ﬁgure will decode the received signal, recover the bits and issue the corresponding data.indication primitives to its datalink layer entity. if there are no transmission errors, this entity will receive the frame sent earlier.
the datalink layer allows directly connected hosts to exchange information, but it is often necessary to exchange information between hosts that are not attached to the same physical medium. this is the task of the network layer. the network layer is built above the datalink layer. network layer entities exchange packets. a packet is a ﬁnite sequence of bytes that is transported by the datalink layer inside one or more frames. a packet usually
physical layerphysical layerbitsphysical transmission medium01010010100010101001010datalinkphysicalframesdatalinkphysicalsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
provide an unreliable service (frames can be corrupted or lost) or a reliable service (in this case, the datalink layer includes retransmission mechanisms similar to the ones used in the transport layer). the unreliable service is frequently used above physical layers (e.g. optical ﬁber, twisted pairs) having a low bit error ratio while reliability mechanisms are often used in wireless networks to recover locally from transmission errors. the second type of datalink layer is the one used in local area networks (lan). conceptually, a lan is a set of communicating devices such that any two devices can directly exchange frames through the datalink layer. both endsystems and routers can be connected to a lan. some lans only connect a few devices, but there are lans that can connect hundreds or even thousands of devices.
in the next chapter, we describe the organisation and the operation of local area networks. an important difference between the point-to-point datalink layers and the datalink layers used in lans is that in a lan, each communicating device is identiﬁed by a unique datalink layer address. this address is usually embedded in the hardware of the device and different types of lans use different types of datalink layer addresses. a communicating device attached to a lan can send a datalink frame to any other communicating device that is attached to the same lan. most lans also support special broadcast and multicast datalink layer addresses. a frame sent to the broadcast address of the lan is delivered to all communicating devices that are attached to the lan. the multicast addresses are used to identify groups of communicating devices. when a frame is sent towards a multicast datalink layer address, it is delivered by the lan to all communicating devices that belong to the corresponding group. the third type of datalink layers are used in non-broadcast multi-access (nbma) networks. these networks are used to interconnect devices like a lan. all devices attached to an nbma network are identiﬁed by a unique datalink layer address. however, and this is the main difference between an nbma network and a traditional lan, the nbma service only supports unicast. the datalink layer service provided by an nbma network supports neither broadcast nor multicast. unfortunately no datalink layer is able to send frames of unlimited side. each datalink layer is characterised by a maximum frame size. there are more than a dozen different datalink layers and unfortunately most of them use a different maximum frame size. the network layer must cope with the heterogeneity of the datalink layer. the network layer itself relies on the following principles :
the above pseudo-code is often called persistent csma [kt1975] as the terminal will continuously listen to the channel and transmit its frame as soon as the channel becomes free. another important variant of csma is the non-persistent csma [kt1975]. the main difference between persistent and non-persistent csma described in the pseudo-code below is that a non-persistent csma node does not continuously listen to the channel to determine when it becomes free. when a non-persistent csma terminal senses the transmission channel to be busy, it waits for a random time before sensing the channel again. this improves channel utilization compared to persistent csma. with persistent csma, when two terminals sense the channel to be busy, they will both transmit (and thus cause a collision) as soon as the channel becomes free. with non-persistent csma, this synchronisation does not occur, as the terminals wait a random time after having sensed the transmission channel. however, the higher channel utilization achieved by non-persistent csma comes at the expense of a slightly higher waiting time in the terminals when the network is lightly loaded.
[kt1975] analyzes in detail the performance of several csma variants. under some assumptions about the transmission channel and the trafﬁc, the analysis compares aloha, slotted aloha, persistent and non-persistent csma. under these assumptions, aloha achieves a channel utilization of only 18.4% of the channel capacity. slotted aloha is able to use 36.6% of this capacity. persistent csma improves the utilization by reaching 52.9% of the capacity while non-persistent csma achieves 81.5% of the channel capacity.
csma improves channel utilization compared to aloha. however, the performance can still be improved, especially in wired networks. consider the situation of two terminals that are connected to the same cable. this cable could, for example, be a coaxial cable as in the early days of ethernet [metcalfe1976]. it could also be built with twisted pairs. before extending csma, it is useful to understand more intuitively, how frames are transmitted in such a network and how collisions can occur. the ﬁgure below illustrates the physical transmission of a frame on such a cable. to transmit its frame, host a must send an electrical signal on the shared medium. the ﬁrst step is thus to begin the transmission of the electrical signal. this is point (1) in the ﬁgure below. this electrical signal will travel along the cable. although electrical signals travel fast, we know that information cannot travel faster than the speed of light (i.e. 300.000 kilometers/second). on a coaxial cable, an electrical signal is slightly slower
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
note: a note on timers the ﬁrst rip implementations sent their distance vector exactly every 30 seconds. this worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time [fj1994]. they collected packet traces in these networks and found that after some time the routers’ timers became synchronised, i.e. almost all routers were sending their distance vectors at almost the same time. this synchronisation of the transmission times of the distance vectors caused an overload on the routers’ cpu but also increased the convergence time of the protocol in some cases. this was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. sally floyd and van jacobson proposed in [fj1994] a simple solution to solve this synchronisation problem. instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval rfc 2080. this randomisation of the delays prevents the synchronisation that occurs with a ﬁxed delay and is now a recommended practice for protocol designers.
link-state routing protocols are used in ip networks. open shortest path first (ospf), deﬁned in rfc 2328, is the link state routing protocol that has been standardised by the ietf. the last version of ospf, which supports ipv6, is deﬁned in rfc 5340. ospf is frequently used in enterprise networks and in some isp networks. however, isp networks often use the is-is link-state routing protocol [iso10589] , which was developed for the iso clnp protocol but was adapted to be used in ip rfc 1195 networks before the ﬁnalisation of the standardisation of ospf. a detailed analysis of isis and ospf may be found in [bmo2006] and [perlman2000]. additional information about ospf may be found in [moy1998]. compared to the basics of link-state routing protocols that we discussed in section link state routing, there are some particularities of ospf that are worth discussing. first, in a large network, ﬂooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. a better approach would be to introduce hierarchical routing. hierarchical routing divides the network into regions. all the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. ospf supports a restricted variant of hierarchical routing. in ospf’s terminology, a region is called an area. ospf imposes restrictions on how a network can be divided into areas. an area is a set of routers and links that are grouped together. usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area 23 . an ospf area contains two types of routers rfc 2328:
• internal router : a router whose directly connected networks belong to the area • area border routers : a router that is attached to several areas.
for example, the network shown in the ﬁgure below has been divided into three areas : area 1, containing routers r1, r3, r4, r5 and ra, area 2 containing r7, r8, r9, r10, rb and rc. ospf areas are identiﬁed by a 32 bit integer, which is sometimes represented as an ip address. among the ospf areas, area 0, also called the backbone area has a special role. the backbone area groups all the area border routers (routers ra, rb and rc in the ﬁgure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router
note: reliability of the connection-oriented service an important point to note about the connection-oriented service is its reliability. a connection-oriented service can only guarantee the correct delivery of all sdus provided that the connection has been released gracefully. this implies that while the connection is active, there is no guarantee for the actual delivery of the sdus exchanged as the connection may need to be released abruptly at any time.
given the growing complexity of computer networks, during the 1970s network researchers proposed various reference models to facilitate the description of network protocols and services. of these, the open systems interconnection (osi) model [zimmermann80] was probably the most inﬂuential. it served as the basis for the standardisation work performed within the iso to develop global computer network standards. the reference model that we use in this book can be considered as a simpliﬁed version of the osi reference model 4.
our reference model is divided into ﬁve layers, as shown in the ﬁgure below. starting from the bottom, the ﬁrst layer is the physical layer. two communicating devices are linked through a physical medium. this physical medium is used to transfer an electrical or optical signal between two directly connected devices. several types of physical mediums are used in practice :
• electrical cable. information can be transmitted over different types of electrical cables. the most common ones are the twisted pairs that are used in the telephone network, but also in enterprise networks and coaxial cables. coaxial cables are still used in cable tv networks, but are no longer used in enterprise networks. some networking technologies operate over the classical electrical cable.
• optical ﬁber. optical ﬁbers are frequently used in public and enterprise networks when the distance between the communication devices is larger than one kilometer. there are two main types of optical ﬁbers : multimode and monomode. multimode is much cheaper than monomode ﬁber because a led can be
sourceproviderdestinationtimedata.request("a")source -> destinationconnection closedconnection openedconnection openeddata.request("b")data.request("c")data.indication("a")data.indication("b")disconnect.req(graceful)disconnect.ind(graceful)data.indication("c")data.indication("d")data.request("d")disconnect.ind(graceful)disconnect.req(graceful)connection closedconnection closedsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
is represented by a plain horizontal arrow, to which the name of the primitive is attached. the dashed lines are used to represent the possible relationship between two (or more) primitives. such a diagram provides information about the ordering of the different primitives, but the distance between two primitives does not represent a precise amount of time. the ﬁgure below provides a representation of the connectionless service as a time-sequence diagram. the user on the left, having address s, issues a data.request primitive containing sdu m that must be delivered by the service provider to destination d. the dashed line between the two primitives indicates that the data.indication primitive that is delivered to the user on the right corresponds to the data.request primitive sent by the user on the left.
there are several possible implementations of the connectionless service, which we will discuss later in this book. before studying these realisations, it is useful to discuss the possible characteristics of the connectionless service. a reliable connectionless service is a service where the service provider guarantees that all sdus submitted in data.requests by a user will eventually be delivered to their destination. such a service would be very useful for users, but guaranteeing perfect delivery is difﬁcult in practice. for this reason, computer networks usually support an unreliable connectionless service. an unreliable connectionless service may suffer from various types of problems compared to a reliable connectionless service. first of all, an unreliable connectionless service does not guarantee the delivery of all sdus. this can be expressed graphically by using the time-sequence diagram below. in practice, an unreliable connectionless service will usually deliver a large fraction of the sdus. however, since the delivery of sdus is not guaranteed, the user must be able to recover from the loss of any sdu. a second imperfection that may affect an unreliable connectionless service is that it may duplicate sdus. some unreliable connectionless service providers may deliver an sdu sent by a user twice or even more. this is illustrated by the time-sequence diagram below. finally, some unreliable connectionless service providers may deliver to a destination a different sdu than the one that was supplied in the data.request. this is illustrated in the ﬁgure below. when a user interacts with a service provider, it must precisely know the limitations of the underlying service to be able to overcome any problem that may arise. this requires a precise deﬁnition of the characteristics of the underlying service. another important characteristic of the connectionless service is whether it preserves the ordering of the sdus sent by one user. from the user’s viewpoint, this is often a desirable characteristic. this is illustrated in the ﬁgure below. however, many connectionless services, and in particular the unreliable services, do not guarantee that they will always preserve the ordering of the sdus sent by each user. this is illustrated in the ﬁgure below.
deﬁned and implemented. when isps started to upgrade their physical infrastructure to provide internet access over asymmetric digital subscriber lines (adsl), they tried to reuse their existing authentication (and billing) systems. to meet these requirements, the ietf developed speciﬁcations to allow ppp frames to be transported over other networks than the point-to-point links for which ppp was designed. nowadays, most adsl deployments use ppp over either atm rfc 2364 or ethernet rfc 2516.
ethernet was designed in the 1970s at the palo alto research center [metcalfe1976]. the ﬁrst prototype 4 used a coaxial cable as the shared medium and 3 mbps of bandwidth. ethernet was improved during the late 1970s and in the 1980s, digital equipment, intel and xerox published the ﬁrst ofﬁcial ethernet speciﬁcation [dix]. this speciﬁcation deﬁnes several important parameters for ethernet networks. the ﬁrst decision was to standardise the commercial ethernet at 10 mbps. the second decision was the duration of the slot time. in ethernet, a long slot time enables networks to span a long distance but forces the host to use a larger minimum frame size. the compromise was a slot time of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes. the third decision was the frame format. the experimental 3 mbps ethernet network built at xerox used short frames containing 8 bit source and destination addresses ﬁelds, a 16 bit type indication, up to 554 bytes of payload and a 16 bit crc. using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. although the initial ethernet speciﬁcation [dix] only allowed up to 1024 hosts on an ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. the ﬁrst change was to require each host attached to an ethernet network to have a globally unique datalink layer address. until then, datalink layer addresses were manually conﬁgured on each host. [dp1981] went against that state of the art and noted “suitable installation-speciﬁc administrative procedures are also needed for assigning numbers to hosts on a network. if a host is moved from one network to another it may be necessary to change its host number if its former number is in use on the new network. this is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). it is anticipated that in future ofﬁce environments, hosts locations will change as often as telephones are changed in present-day ofﬁces.” the second change introduced by ethernet was to encode each address as a 48 bits ﬁeld [dp1981]. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages [dp1981] including the ability to allocate large blocks of addresses to manufacturers. eventually, other lan technologies opted for 48 bits addresses as well [802]_ . the third change introduced by ethernet was the deﬁnition of broadcast and multicast addresses. the need for multicast ethernet was foreseen in [dp1981] and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer. the datalink layer addresses used in ethernet networks are often called mac addresses. they are structured as shown in the ﬁgure below. the ﬁrst bit of the address indicates whether the address identiﬁes a network adapter or a multicast group. the upper 24 bits are used to encode an organisation unique identiﬁer (oui). this oui identiﬁes a block of addresses that has been allocated by the secretariat 5 who is responsible for the uniqueness of ethernet addresses to a manufacturer. once a manufacturer has received an oui, it can build and sell products with one of the 16 million addresses in this block.
the original 10 mbps ethernet speciﬁcation [dix] deﬁned a simple frame format where each frame is composed of ﬁve ﬁelds. the ethernet frame starts with a preamble (not shown in the ﬁgure below) that is used by the physical layer of the receiver to synchronise its clock with the sender’s clock. the ﬁrst ﬁeld of the frame is the destination
4 additional information about the history of the ethernet technology may be found at http://ethernethistory.typepad.com/ 5 initially, the ouis were allocated by xerox [dp1981]. however, once ethernet became an ieee and later an iso standard, the allocation
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
contains information about its origin and its destination, and usually passes through several intermediate devices called routers on its way from its origin to its destination.
most realisations of the network layer, including the internet, do not provide a reliable service. however, many applications need to exchange information reliably and so using the network layer service directly would be very difﬁcult for them. ensuring the reliable delivery of the data produced by applications is the task of the transport layer. transport layer entities exchange segments. a segment is a ﬁnite sequence of bytes that are transported inside one or more packets. a transport layer entity issues segments (or sometimes part of segments) as data.request to the underlying network layer entity. there are different types of transport layers. the most widely used transport layers on the internet are tcp ,that provides a reliable connection-oriented bytestream transport service, and udp ,that provides an unreliable connection-less transport service.
the upper layer of our architecture is the application layer. this layer includes all the mechanisms and data structures that are necessary for the applications. we will use application data unit (adu) to indicate the data exchanged between two entities of the application layer.
in contrast with osi, the tcp/ip community did not spend a lot of effort deﬁning a detailed reference model; in fact, the goals of the internet architecture were only documented after tcp/ip had been deployed [clark88]. rfc 1122 , which deﬁnes the requirements for internet hosts, mentions four different layers. starting from the top, these are :
• an application layer • a transport layer • an internet layer which is equivalent to the network layer of our reference model • a link layer which combines the functionalities of the physical and datalink layers of our ﬁve-layer reference
physical layerdatalinknetworkphysical layerdatalinknetworkphysical layerdatalinknetworkpacketspacketsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportsegmentsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportaduapplicationapplicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
note: a note on timers the ﬁrst rip implementations sent their distance vector exactly every 30 seconds. this worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time [fj1994]. they collected packet traces in these networks and found that after some time the routers’ timers became synchronised, i.e. almost all routers were sending their distance vectors at almost the same time. this synchronisation of the transmission times of the distance vectors caused an overload on the routers’ cpu but also increased the convergence time of the protocol in some cases. this was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. sally floyd and van jacobson proposed in [fj1994] a simple solution to solve this synchronisation problem. instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval rfc 2080. this randomisation of the delays prevents the synchronisation that occurs with a ﬁxed delay and is now a recommended practice for protocol designers.
link-state routing protocols are used in ip networks. open shortest path first (ospf), deﬁned in rfc 2328, is the link state routing protocol that has been standardised by the ietf. the last version of ospf, which supports ipv6, is deﬁned in rfc 5340. ospf is frequently used in enterprise networks and in some isp networks. however, isp networks often use the is-is link-state routing protocol [iso10589] , which was developed for the iso clnp protocol but was adapted to be used in ip rfc 1195 networks before the ﬁnalisation of the standardisation of ospf. a detailed analysis of isis and ospf may be found in [bmo2006] and [perlman2000]. additional information about ospf may be found in [moy1998]. compared to the basics of link-state routing protocols that we discussed in section link state routing, there are some particularities of ospf that are worth discussing. first, in a large network, ﬂooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. a better approach would be to introduce hierarchical routing. hierarchical routing divides the network into regions. all the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. ospf supports a restricted variant of hierarchical routing. in ospf’s terminology, a region is called an area. ospf imposes restrictions on how a network can be divided into areas. an area is a set of routers and links that are grouped together. usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area 23 . an ospf area contains two types of routers rfc 2328:
• internal router : a router whose directly connected networks belong to the area • area border routers : a router that is attached to several areas.
for example, the network shown in the ﬁgure below has been divided into three areas : area 1, containing routers r1, r3, r4, r5 and ra, area 2 containing r7, r8, r9, r10, rb and rc. ospf areas are identiﬁed by a 32 bit integer, which is sometimes represented as an ip address. among the ospf areas, area 0, also called the backbone area has a special role. the backbone area groups all the area border routers (routers ra, rb and rc in the ﬁgure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
note: a note on timers the ﬁrst rip implementations sent their distance vector exactly every 30 seconds. this worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time [fj1994]. they collected packet traces in these networks and found that after some time the routers’ timers became synchronised, i.e. almost all routers were sending their distance vectors at almost the same time. this synchronisation of the transmission times of the distance vectors caused an overload on the routers’ cpu but also increased the convergence time of the protocol in some cases. this was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. sally floyd and van jacobson proposed in [fj1994] a simple solution to solve this synchronisation problem. instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval rfc 2080. this randomisation of the delays prevents the synchronisation that occurs with a ﬁxed delay and is now a recommended practice for protocol designers.
link-state routing protocols are used in ip networks. open shortest path first (ospf), deﬁned in rfc 2328, is the link state routing protocol that has been standardised by the ietf. the last version of ospf, which supports ipv6, is deﬁned in rfc 5340. ospf is frequently used in enterprise networks and in some isp networks. however, isp networks often use the is-is link-state routing protocol [iso10589] , which was developed for the iso clnp protocol but was adapted to be used in ip rfc 1195 networks before the ﬁnalisation of the standardisation of ospf. a detailed analysis of isis and ospf may be found in [bmo2006] and [perlman2000]. additional information about ospf may be found in [moy1998]. compared to the basics of link-state routing protocols that we discussed in section link state routing, there are some particularities of ospf that are worth discussing. first, in a large network, ﬂooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. a better approach would be to introduce hierarchical routing. hierarchical routing divides the network into regions. all the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. ospf supports a restricted variant of hierarchical routing. in ospf’s terminology, a region is called an area. ospf imposes restrictions on how a network can be divided into areas. an area is a set of routers and links that are grouped together. usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area 23 . an ospf area contains two types of routers rfc 2328:
• internal router : a router whose directly connected networks belong to the area • area border routers : a router that is attached to several areas.
for example, the network shown in the ﬁgure below has been divided into three areas : area 1, containing routers r1, r3, r4, r5 and ra, area 2 containing r7, r8, r9, r10, rb and rc. ospf areas are identiﬁed by a 32 bit integer, which is sometimes represented as an ip address. among the ospf areas, area 0, also called the backbone area has a special role. the backbone area groups all the area border routers (routers ra, rb and rc in the ﬁgure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router
rd in the ﬁgure below). an important restriction imposed by ospf is that the path between two routers that belong to two different areas (e.g. r1 and r8 in the ﬁgure below) must pass through the backbone area.
inside each non-backbone area, routers distribute the topology of the area by exchanging link state packets with the other routers in the area. the internal routers do not know the topology of other areas, but each router knows how to reach the backbone area. inside an area, the routers only exchange link-state packets for all destinations that are reachable inside the area. in ospf, the inter-area routing is done by exchanging distance vectors. this is illustrated by the network topology shown below. let us ﬁrst consider ospf routing inside area 2. all routers in the area learn a route towards 192.168.1.0/24 and 192.168.10.0/24. the two area border routers, rb and rc, create network summary advertisements. assuming that all links have a unit link metric, these would be:
• rb advertises 192.168.1.0/24 at a distance of 2 and 192.168.10.0/24 at a distance of 3 • rc advertises 192.168.1.0/24 at a distance of 3 and 192.168.10.0/24 at a distance of 2
these summary advertisements are ﬂooded through the backbone area attached to routers rb and rc. in its routing table, router ra selects the summary advertised by rb to reach 192.168.1.0/24 and the summary advertised by rc to reach 192.168.10.0/24. inside area 1, router ra advertises a summary indicating that 192.168.1.0/24 and 192.168.10.0/24 are both at a distance of 3 from itself. on the other hand, consider the preﬁxes 10.0.0.0/24 and 10.0.1.0/24 that are inside area 1. router ra is the only area border router that is attached to this area. this router can create two different network summary advertisements :
the ﬁrst summary advertisement provides precise information about the distance used to reach each preﬁx. however, all routers in the network have to maintain a route towards 10.0.0.0/24 and a route towards 10.0.1.0/24 that are both via router ra. the second advertisement would improve the scalability of ospf by reducing the number of routes that are advertised across area boundaries. however, in practice this requires manual conﬁguration on the border routers. the second ospf particularity that is worth discussing is the support of local area networks (lan). as shown in the example below, several routers may be attached to the same lan.
deﬁned and implemented. when isps started to upgrade their physical infrastructure to provide internet access over asymmetric digital subscriber lines (adsl), they tried to reuse their existing authentication (and billing) systems. to meet these requirements, the ietf developed speciﬁcations to allow ppp frames to be transported over other networks than the point-to-point links for which ppp was designed. nowadays, most adsl deployments use ppp over either atm rfc 2364 or ethernet rfc 2516.
ethernet was designed in the 1970s at the palo alto research center [metcalfe1976]. the ﬁrst prototype 4 used a coaxial cable as the shared medium and 3 mbps of bandwidth. ethernet was improved during the late 1970s and in the 1980s, digital equipment, intel and xerox published the ﬁrst ofﬁcial ethernet speciﬁcation [dix]. this speciﬁcation deﬁnes several important parameters for ethernet networks. the ﬁrst decision was to standardise the commercial ethernet at 10 mbps. the second decision was the duration of the slot time. in ethernet, a long slot time enables networks to span a long distance but forces the host to use a larger minimum frame size. the compromise was a slot time of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes. the third decision was the frame format. the experimental 3 mbps ethernet network built at xerox used short frames containing 8 bit source and destination addresses ﬁelds, a 16 bit type indication, up to 554 bytes of payload and a 16 bit crc. using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. although the initial ethernet speciﬁcation [dix] only allowed up to 1024 hosts on an ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. the ﬁrst change was to require each host attached to an ethernet network to have a globally unique datalink layer address. until then, datalink layer addresses were manually conﬁgured on each host. [dp1981] went against that state of the art and noted “suitable installation-speciﬁc administrative procedures are also needed for assigning numbers to hosts on a network. if a host is moved from one network to another it may be necessary to change its host number if its former number is in use on the new network. this is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). it is anticipated that in future ofﬁce environments, hosts locations will change as often as telephones are changed in present-day ofﬁces.” the second change introduced by ethernet was to encode each address as a 48 bits ﬁeld [dp1981]. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages [dp1981] including the ability to allocate large blocks of addresses to manufacturers. eventually, other lan technologies opted for 48 bits addresses as well [802]_ . the third change introduced by ethernet was the deﬁnition of broadcast and multicast addresses. the need for multicast ethernet was foreseen in [dp1981] and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer. the datalink layer addresses used in ethernet networks are often called mac addresses. they are structured as shown in the ﬁgure below. the ﬁrst bit of the address indicates whether the address identiﬁes a network adapter or a multicast group. the upper 24 bits are used to encode an organisation unique identiﬁer (oui). this oui identiﬁes a block of addresses that has been allocated by the secretariat 5 who is responsible for the uniqueness of ethernet addresses to a manufacturer. once a manufacturer has received an oui, it can build and sell products with one of the 16 million addresses in this block.
the original 10 mbps ethernet speciﬁcation [dix] deﬁned a simple frame format where each frame is composed of ﬁve ﬁelds. the ethernet frame starts with a preamble (not shown in the ﬁgure below) that is used by the physical layer of the receiver to synchronise its clock with the sender’s clock. the ﬁrst ﬁeld of the frame is the destination
4 additional information about the history of the ethernet technology may be found at http://ethernethistory.typepad.com/ 5 initially, the ouis were allocated by xerox [dp1981]. however, once ethernet became an ieee and later an iso standard, the allocation
the physical layer allows thus two or more entities that are directly attached to the same transmission medium to exchange bits. being able to exchange bits is important as virtually any information can be encoded as a sequence of bits. electrical engineers are used to processing streams of bits, but computer scientists usually prefer to deal with higher level concepts. a similar issue arises with ﬁle storage. storage devices such as hard-disks also store streams of bits. there are hardware devices that process the bit stream produced by a hard-disk, but computer scientists have designed ﬁlesystems to allow applications to easily access such storage devices. these ﬁlesystems are typically divided into several layers as well. hard-disks store sectors of 512 bytes or more. unix ﬁlesystems group sectors in larger blocks that can contain data or inodes representing the structure of the ﬁlesystem. finally, applications manipulate ﬁles and directories that are translated in blocks, sectors and eventually bits by the operating system. computer networks use a similar approach. each layer provides a service that is built above the underlying layer and is closer to the needs of the applications. the datalink layer builds on the service provided by the underlying physical layer. the datalink layer allows two hosts that are directly connected through the physical layer to exchange information. the unit of information exchanged between two entities in the datalink layer is a frame. a frame is a ﬁnite sequence of bits. some datalink layers use variable-length frames while others only use ﬁxed-length frames. some datalink layers provide a connection-oriented service while others provide a connectionless service. some datalink layers provide reliable delivery while others do not guarantee the correct delivery of the information. an important point to note about the datalink layer is that although the ﬁgure below indicates that two entities of the datalink layer exchange frames directly, in reality this is slightly different. when the datalink layer entity on the left needs to transmit a frame, it issues as many data.request primitives to the underlying physical layer as there are bits in the frame. the physical layer will then convert the sequence of bits in an electromagnetic or optical signal that will be sent over the physical medium. the physical layer on the right hand side of the ﬁgure will decode the received signal, recover the bits and issue the corresponding data.indication primitives to its datalink layer entity. if there are no transmission errors, this entity will receive the frame sent earlier.
the datalink layer allows directly connected hosts to exchange information, but it is often necessary to exchange information between hosts that are not attached to the same physical medium. this is the task of the network layer. the network layer is built above the datalink layer. network layer entities exchange packets. a packet is a ﬁnite sequence of bytes that is transported by the datalink layer inside one or more frames. a packet usually
physical layerphysical layerbitsphysical transmission medium01010010100010101001010datalinkphysicalframesdatalinkphysicalsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
occur. in optical networks, a variant of fdm called wavelength division multiplexing (wdm) can be used. an optical ﬁber can transport light at different wavelengths without interference. with wdm, a different wavelength is allocated to each of the devices that share the same optical ﬁber. time division multiplexing (tdm) is a static bandwidth allocation method that was initially deﬁned for the telephone network. in the ﬁxed telephone network, a voice conversation is usually transmitted as a 64 kbps signal. thus, a telephone conservation generates 8 kbytes per second or one byte every 125 microsecond. telephone conversations often need to be multiplexed together on a single line. for example, in europe, thirty 64 kbps voice signals are multiplexed over a single 2 mbps (e1) line. this is done by using time division multiplexing (tdm). tdm divides the transmission opportunities into slots. in the telephone network, a slot corresponds to 125 microseconds. a position inside each slot is reserved for each voice signal. the ﬁgure below illustrates tdm on a link that is used to carry four voice conversations. the vertical lines represent the slot boundaries and the letters the different voice conversations. one byte from each voice conversation is sent during each 125 microsecond slot. the byte corresponding to a given conversation is always sent at the same position in each slot.
tdm as shown above can be completely static, i.e. the same conversations always share the link, or dynamic. in the latter case, the two endpoints of the link must exchange messages specifying which conversation uses which byte inside each slot. thanks to these signalling messages, it is possible to dynamically add and remove voice conversations from a given link. tdm and fdm are widely used in telephone networks to support ﬁxed bandwidth conversations. using them in local area networks that support computers would probably be inefﬁcient. computers usually do not send information at a ﬁxed rate. instead, they often have an on-off behaviour. during the on period, the computer tries to send at the highest possible rate, e.g. to transfer a ﬁle. during the off period, which is often much longer than the on period, the computer does not transmit any packet. using a static allocation scheme for computers attached to a lan would lead to huge inefﬁciencies, as they would only be able to transmit at 1 n of the total bandwidth during their on period, despite the fact that the other computers are in their off period and thus do not need to transmit any information. the dynamic mac algorithms discussed in the remainder of this chapter aim solve this problem.
in the 1960s, computers were mainly mainframes with a few dozen terminals attached to them. these terminals were usually in the same building as the mainframe and were directly connected to it. in some cases, the terminals were installed in remote locations and connected through a modem attached to a dial-up line. the university of hawaii chose a different organisation. instead of using telephone lines to connect the distant terminals, they developed the ﬁrst packet radio technology [abramson1970]. until then, computer networks were built on top of either the telephone network or physical cables. alohanet showed that it was possible to use radio signals to interconnect computers. the ﬁrst version of alohanet, described in [abramson1970], operated as follows: first, the terminals and the mainframe exchanged ﬁxed-length frames composed of 704 bits. each frame contained 80 8-bit characters, some control bits and parity information to detect transmission errors. two channels in the 400 mhz range were reserved for the operation of alohanet. the ﬁrst channel was used by the mainframe to send frames to all terminals. the second channel was shared among all terminals to send frames to the mainframe. as all terminals share the same transmission channel, there is a risk of collision. to deal with this problem as well as transmission errors, the mainframe veriﬁed the parity bits of the received frame and sent an acknowledgement on its channel for each correctly received frame. the terminals on the other hand had to retransmit the unacknowledged frames. as for tcp, retransmitting these frames immediately upon expiration of a ﬁxed timeout is not a good approach as several terminals may retransmit their frames at the same time leading to a network collapse. a better approach, but still far from perfect, is for each terminal to wait a random amount of time after the expiration of its retransmission timeout. this avoids synchronisation among multiple retransmitting terminals.
the ﬁrst rule ensures that a tcp connection used for bulk data transfer always sends full tcp segments. the second rule sends one partially ﬁlled tcp segment every round-trip-time. this algorithm, called the nagle algorithm, takes a few lines of code in all tcp implementations. these lines of code have a huge impact on the packets that are exchanged in tcp/ip networks. researchers have analysed the distribution of the packet sizes by capturing and analysing all the packets passing through a given link. these studies have shown several important results :
• in tcp/ipv4 networks, most of the bytes are exchanged in long packets, usually packets containing up to 1460 bytes of payload which is the default mss for hosts attached to an ethernet network, the most popular type of lan
the ﬁgure below provides a distribution of the packet sizes measured on a link. it shows a three-modal distribution of the packet size. 50% of the packets contain pure tcp acknowledgements and occupy 40 bytes. about 20% of the packets contain about 500 bytes 18 of user data and 12% of the packets contain 1460 bytes of user data. however, most of the user data is transported in large packets. this packet size distribution has implications on the design of routers as we discuss in the next chapter.
recent measurements indicate that these packet size distributions are still valid in today’s internet, although the packet distribution tends to become bimodal with small packets corresponding to tcp pure acks (40-64 bytes depending on the utilisation of tcp options) and large 1460-bytes packets carrying most of the user data.
from a performance point of view, one of the main limitations of the original tcp speciﬁcation is the 16 bits window ﬁeld in the tcp header. as this ﬁeld indicates the current size of the receive window in bytes, it limits the tcp receive window at 65535 bytes. this limitation was not a severe problem when tcp was designed since at that time high-speed wide area networks offered a maximum bandwidth of 56 kbps. however, in today’s network, this limitation is not acceptable anymore. the table below provides the rough 19 maximum throughput that can be achieved by a tcp connection with a 64 kbytes window in function of the connection’s round-trip-time
to solve this problem, a backward compatible extension that allows tcp to use larger receive windows was proposed in rfc 1323. today, most tcp implementations support this option. the basic idea is that instead of
18 when these measurements were taken, some hosts had a default mss of 552 bytes (e.g. bsd unix derivatives) or 536 bytes (the default mss speciﬁed in rfc 793). today, most tcp implementation derive the mss from the maximum packet size of the lan interface they use (ethernet in most cases).
another very useful debugging tool is traceroute(8). the traceroute man page describes this tool as “print the route packets take to network host”. traceroute uses the ttl exceeded icmp messages to discover the intermediate routers on the path towards a destination. the principle behind traceroute is very simple. when a router receives an ip packet whose ttl is set to 1 it decrements the ttl and is forced to return to the sending host a ttl exceeded icmp message containing the header and the ﬁrst bytes of the discarded ip packet. to discover all routers on a network path, a simple solution is to ﬁrst send a packet whose ttl is set to 1, then a packet whose ttl is set to 2, etc. a sample traceroute output is shown below.
cshalles3.sri.ucl.ac.be (192.168.251.230) cthalles.sri.ucl.ac.be (192.168.251.229) ctpythagore.sri.ucl.ac.be (130.104.254.230) fe.m20.access.lln.belnet.net (193.191.11.9) 10ge.cr2.brueve.belnet.net (193.191.16.22) 212.3.237.13 (212.3.237.13) 5.347 ms ae-11-11.car1.brussels1.level3.net (4.69.136.249) ae-6-6.ebr1.london1.level3.net (4.69.136.246) ae-100-100.ebr2.london1.level3.net (4.69.141.166)
ae-41-41.ebr1.newyork1.level3.net (4.69.137.66) ae-43-43.ebr1.newyork1.level3.net (4.69.137.74) ae-42-42.ebr1.newyork1.level3.net (4.69.137.70) ae-2-2.ebr1.newark1.level3.net (4.69.132.98) ae-14-51.car4.newark1.level3.net (4.68.99.8) ex1-tg2-0.eqnwnj.sbcglobal.net (151.164.89.249) 151.164.95.190 (151.164.95.190) ded-p10-0.pltn13.sbcglobal.net (151.164.191.243) ams-1152322.cust-rtr.swbell.net (75.61.192.10) mail.ietf.org (64.170.98.32) 158.427 ms
the above traceroute(8) output shows a 17 hops path between a host at uclouvain and one of the main ietf servers. for each hop, traceroute provides the ipv4 address of the router that sent the icmp message and the measured round-trip-time between the source and this router. traceroute sends three probes with each ttl value. in some cases, such as at the 10th hop above, the icmp messages may be received from different addresses. this is usually because different packets from the same source have followed different paths 11 in the network. another important utilisation of icmp messages is to discover the maximum mtu that can be used to reach a destination without fragmentation. as explained earlier, when an ipv4 router receives a packet that is larger than the mtu of the outgoing link, it must fragment the packet. unfortunately, fragmentation is a complex operation and routers cannot perform it at line rate [km1995]. furthermore, when a tcp segment is transported in an ip packet that is fragmented in the network, the loss of a single fragment forces tcp to retransmit the entire segment (and thus all the fragments). if tcp was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. in addition, ip reassembly causes several challenges at high speed as discussed in rfc 4963. using ip fragmentation to allow udp applications to exchange large messages raises several security issues [kps2003]. icmp, combined with the don’t fragment (df) ipv4 ﬂag, is used by tcp implementations to discover the largest mtu size that is allowed to reach a destination host without causing network fragmentation. this is the path mtu discovery mechanism deﬁned in rfc 1191. a tcp implementation that includes path mtu discovery (most do) requests the ipv4 layer to send all segments inside ipv4 packets having the df ﬂag set. this prohibits intermediate routers from fragmenting these packets. if a router needs to forward an unfragmentable packet over a link with a smaller mtu, it returns a fragmentation needed icmp message to the source, indicating the mtu of its outgoing link. this icmp message contains in the mtu of the router’s outgoing link in its data ﬁeld. upon reception of this icmp message, the source tcp implementation adjusts its maximum segment size (mss) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
libraries 1 used to write networked applications contain functions to convert multi-byte ﬁelds from memory to the network byte order and vice versa. besides 16 and 32 bit words, some applications need to exchange data structures containing bit ﬁelds of various lengths. for example, a message may be composed of a 16 bits ﬁeld followed by eight, one bit ﬂags, a 24 bits ﬁeld and two 8 bits bytes. internet protocol speciﬁcations will deﬁne such a message by using a representation such as the one below. in this representation, each line corresponds to 32 bits and the vertical lines are used to delineate ﬁelds. the numbers above the lines indicate the bit positions in the 32-bits word, with the high order bit at position 0.
the message mentioned above will be transmitted starting from the upper 32-bits word in network byte order. the ﬁrst ﬁeld is encoded in 16 bits. it is followed by eight one bit ﬂags (a-h), a 24 bits ﬁeld whose high order byte is shown in the ﬁrst line and the two low order bytes appear in the second line followed by two one byte ﬁelds. this ascii representation is frequently used when deﬁning binary protocols. we will use it for all the binary protocols that are discussed in this book. we will discuss several examples of application-level protocols in this chapter.
the peer-to-peer model emerged during the last ten years as another possible architecture for networked applications. in the traditional client-server model, hosts act either as servers or as clients and a server serves a large number of clients. in the peer-to-peer model, all hosts act as both servers and clients and they play both roles. the peer-to-peer model has been used to develop various networked applications, ranging from internet telephony to ﬁle sharing or internet-wide ﬁlesystems. a detailed description of peer-to-peer applications may be found in [byl2008]. surveys of peer-to-peer protocols and applications may be found in [as2004] and [lcp2005].
networked applications are built on top of the transport service. as explained in the previous chapter, there are two main types of transport services :
the connectionless service allows applications to easily exchange messages or service data units. on the internet, this service is provided by the udp protocol that will be explained in the next chapter. the connectionless transport service on the internet is unreliable, but is able to detect transmission errors. this implies that an application will not receive an sdu that has been corrupted due to transmission errors. the connectionless transport service allows networked application to exchange messages. several networked applications may be running at the same time on a single host. each of these applications must be able to exchange sdus with remote applications. to enable these exchanges of sdus, each networked application running on a host is identiﬁed by the following information :
1 for example, the htonl(3) (resp. ntohl(3)) function the standard c library converts a 32-bits unsigned integer from the byte order used by the cpu to the network byte order (resp. from the network byte order to the cpu byte order). similar functions exist in other programming languages.
explicitly the sender of the reception of d(2,c) and the sender could retransmit this segment although it has already been received. a possible solution to improve the performance of selective repeat is to provide additional information about the received segments in the acknowledgements that are returned by the receiver. for example, the receiver could add in the returned acknowledgement the list of the sequence numbers of all segments that have already been received. such acknowledgements are sometimes called selective acknowledgements. this is illustrated in the ﬁgure below. in the ﬁgure above, when the sender receives c(ok,0,[2]), it knows that all segments up to and including d(0,...) have been correctly received. it also knows that segment d(2,...) has been received and can cancel the retransmission timer associated to this segment. however, this segment should not be removed from the sending buffer before the reception of a cumulative acknowledgement (c(ok,2) in the ﬁgure above) that covers this segment.
note: maximum window size with go-back-n and selective repeat a transport protocol that uses n bits to encode its sequence number can send up to 2n different segments. however, to ensure a reliable delivery of the segments, go-back-n and selective repeat cannot use a sending window of 2n segments. consider ﬁrst go-back-n and assume that a sender sends 2n segments. these segments are received in-sequence by the destination, but all the returned acknowledgements are lost. the sender will retransmit all segments and they will all be accepted by the receiver and delivered a second time to the user. it is easy to see that this problem can be avoided if the maximum size of the sending window is 2n − 1 segments. a similar problem occurs with selective repeat. however, as the receiver accepts out-of-sequence segments, a sending window of 2n − 1 segments is not sufﬁcient to ensure a reliable delivery of all segments. it can be easily shown that to avoid this problem, a selective repeat sender cannot use a window that is larger than 2n
go-back-n or selective repeat are used by transport protocols to provide a reliable data transfer above an unreliable network layer service. until now, we have assumed that the size of the sliding window was ﬁxed for the entire lifetime of the connection. in practice a transport layer entity is usually implemented in the operating system and shares memory with other parts of the system. furthermore, a transport layer entity must support several (possibly hundreds or thousands) of transport connections at the same time. this implies that the memory which can be used to support the sending or the receiving buffer of a transport connection may change during the lifetime of the connection 4 . thus, a transport protocol must allow the sender and the receiver to adjust their window sizes. to deal with this issue, transport protocols allow the receiver to advertise the current size of its receiving window in all the acknowledgements that it sends. the receiving window advertised by the receiver bounds the size of the sending buffer used by the sender. in practice, the sender maintains two state variables : swin, the size of its sending window (that may be adjusted by the system) and rwin, the size of the receiving window advertised by the receiver. at any time, the number of unacknowledged segments cannot be larger than min(swin,rwin) 5 . the utilisation of dynamic windows is illustrated in the ﬁgure below. the receiver may adjust its advertised receive window based on its current memory consumption, but also to limit the bandwidth used by the sender. in practice, the receive buffer can also shrink as the application may not able to process the received data quickly enough. in this case, the receive buffer may be completely full and the advertised receive window may shrink to 0. when the sender receives an acknowledgement with a receive window set to 0, it is blocked until it receives an acknowledgement with a positive receive window. unfortunately, as shown in the ﬁgure below, the loss of this acknowledgement could cause a deadlock as the sender waits for an acknowledgement while the receiver is waiting for a data segment. to solve this problem, transport protocols rely on a special timer : the persistence timer. this timer is started by the sender whenever it receives an acknowledgement advertising a receive window set to 0. when the timer expires, the sender retransmits an old segment in order to force the receiver to send a new acknowledgement, and hence send the current receive window size. to conclude our description of the basic mechanisms found in transport protocols, we still need to discuss the impact of segments arriving in the wrong order. if two consecutive segments are reordered, the receiver relies on their sequence numbers to reorder them in its receive buffer. unfortunately, as transport protocols reuse the same sequence number for different segments, if a segment is delayed for a prolonged period of time, it might still be accepted by the receiver. this is illustrated in the ﬁgure below where segment d(1,b) is delayed.
4 for a discussion on how the sending buffer can change, see e.g. [smm1998] 5 note that if the receive window shrinks, it might happen that the sender has already sent a segment that is not anymore inside its window.
the pseudo-code below shows the operation of an alohanet terminal. we use this python syntax for all medium access control algorithms described in this chapter. the algorithm is applied to each new frame that needs to be transmitted. it attempts to transmit a frame at most max times (while loop). each transmission attempt is performed as follows: first, the frame is sent. each frame is protected by a timeout. then, the terminal waits for either a valid acknowledgement frame or the expiration of its timeout. if the terminal receives an acknowledgement, the frame has been delivered correctly and the algorithm terminates. otherwise, the terminal waits for a random time and attempts to retransmit the frame.
[abramson1970] analysed the performance of alohanet under particular assumptions and found that alohanet worked well when the channel was lightly loaded. in this case, the frames are rarely retransmitted and the channel trafﬁc, i.e. the total number of (correct and retransmitted) frames transmitted per unit of time is close to the channel utilization, i.e. the number of correctly transmitted frames per unit of time. unfortunately, the analysis 2×e = 0.186 times the channel bandwidth. at also reveals that the channel utilization reaches its maximum at higher utilization, alohanet becomes unstable and the network collapses due to collided retransmissions.
note: amateur packet radio packet radio technologies have evolved in various directions since the ﬁrst experiments performed at the university of hawaii. the amateur packet radio service developed by amateur radio operators is one of the descendants alohanet. many amateur radio operators are very interested in new technologies and they often spend countless hours developing new antennas or transceivers. when the ﬁrst personal computers appeared, several amateur radio operators designed radio modems and their own datalink layer protocols [kpd1985] [bnt1997]. this network grew and it was possible to connect to servers in several european countries by only using packet radio relays. some amateur radio operators also developed tcp/ip protocol stacks that were used over the packet radio service. some parts of the amateur packet radio network are connected to the global internet and use the 44.0.0.0/8 preﬁx.
many improvements to alohanet have been proposed since the publication of [abramson1970], and this technique, or some of its variants, are still found in wireless networks today. the slotted technique proposed in [roberts1975] is important because it shows that a simple modiﬁcation can signiﬁcantly improve channel utilization. instead of allowing all terminals to transmit at any time, [roberts1975] proposed to divide time into slots and allow terminals to transmit only at the beginning of each slot. each slot corresponds to the time required to transmit one ﬁxed size frame. in practice, these slots can be imposed by a single clock that is received by all terminals. in alohanet, it could have been located on the central mainframe. the analysis in [roberts1975] reveals that this simple modiﬁcation improves the channel utilization by a factor of two.
aloha and slotted aloha can easily be implemented, but unfortunately, they can only be used in networks that are very lightly loaded. designing a network for a very low utilisation is possible, but it clearly increases the cost of the network. to overcome the problems of aloha, many medium access control mechanisms have been proposed which improve channel utilization. carrier sense multiple access (csma) is a signiﬁcant improvement compared to aloha. csma requires all nodes to listen to the transmission channel to verify that it is free before transmitting a frame [kt1975]. when a node senses the channel to be busy, it defers its transmission until the channel becomes free again. the pseudo-code below provides a more detailed description of the operation of csma.
the physical layer allows thus two or more entities that are directly attached to the same transmission medium to exchange bits. being able to exchange bits is important as virtually any information can be encoded as a sequence of bits. electrical engineers are used to processing streams of bits, but computer scientists usually prefer to deal with higher level concepts. a similar issue arises with ﬁle storage. storage devices such as hard-disks also store streams of bits. there are hardware devices that process the bit stream produced by a hard-disk, but computer scientists have designed ﬁlesystems to allow applications to easily access such storage devices. these ﬁlesystems are typically divided into several layers as well. hard-disks store sectors of 512 bytes or more. unix ﬁlesystems group sectors in larger blocks that can contain data or inodes representing the structure of the ﬁlesystem. finally, applications manipulate ﬁles and directories that are translated in blocks, sectors and eventually bits by the operating system. computer networks use a similar approach. each layer provides a service that is built above the underlying layer and is closer to the needs of the applications. the datalink layer builds on the service provided by the underlying physical layer. the datalink layer allows two hosts that are directly connected through the physical layer to exchange information. the unit of information exchanged between two entities in the datalink layer is a frame. a frame is a ﬁnite sequence of bits. some datalink layers use variable-length frames while others only use ﬁxed-length frames. some datalink layers provide a connection-oriented service while others provide a connectionless service. some datalink layers provide reliable delivery while others do not guarantee the correct delivery of the information. an important point to note about the datalink layer is that although the ﬁgure below indicates that two entities of the datalink layer exchange frames directly, in reality this is slightly different. when the datalink layer entity on the left needs to transmit a frame, it issues as many data.request primitives to the underlying physical layer as there are bits in the frame. the physical layer will then convert the sequence of bits in an electromagnetic or optical signal that will be sent over the physical medium. the physical layer on the right hand side of the ﬁgure will decode the received signal, recover the bits and issue the corresponding data.indication primitives to its datalink layer entity. if there are no transmission errors, this entity will receive the frame sent earlier.
the datalink layer allows directly connected hosts to exchange information, but it is often necessary to exchange information between hosts that are not attached to the same physical medium. this is the task of the network layer. the network layer is built above the datalink layer. network layer entities exchange packets. a packet is a ﬁnite sequence of bytes that is transported by the datalink layer inside one or more frames. a packet usually
physical layerphysical layerbitsphysical transmission medium01010010100010101001010datalinkphysicalframesdatalinkphysicalsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
to deal with this problem, transport protocols combine two solutions. first, they use 32 bits or more to encode the sequence number in the segment header. this increases the overhead, but also increases the delay between the transmission of two different segments having the same sequence number. second, transport protocols require the network layer to enforce a maximum segment lifetime (msl). the network layer must ensure that no packet remains in the network for more than msl seconds. in the internet the msl is assumed 6 to be 2 minutes rfc 793. note that this limits the maximum bandwidth of a transport protocol. if it uses n bits to encode its sequence numbers, then it cannot send more than 2n segments every msl seconds. transport protocols often need to send data in both directions. to reduce the overhead caused by the acknowledgements, most transport protocols use piggybacking. thanks to this technique, a transport entity can place inside the header of the data segments that it sends, the acknowledgements and the receive window that it advertises for the opposite direction of the data ﬂow. the main advantage of piggybacking is that it reduces the overhead as it is not necessary to send a complete segment to carry an acknowledgement. this is illustrated in the ﬁgure below where the acknowledgement number is underlined in the data segments. piggybacking is only used when data ﬂows in both directions. a receiver will generate a pure acknowledgement when it does not send data in the opposite direction as shown in the bottom of the ﬁgure.
6 as we will see in the next chapter, the internet does not strictly enforce this msl. however, it is reasonable to expect that most packets on the internet will not remain in the network during more than 2 minutes. there are a few exceptions to this rule, such as rfc 1149 whose implementation is described in http://www.blug.linux.no/rfc1149/ but there are few real links supporting rfc 1149 in the internet.
• source quench : a router was supposed to send this message when it had to discard packets due to congestion. however, sending icmp messages in case of congestion was not the best way to reduce congestion and since the inclusion of a congestion control scheme in tcp, this icmp message has been deprecated.
note: redirection attacks icmp redirect messages are useful when several routers are attached to the same lan as hosts. however, they should be used with care as they also create an important security risk. one of the most annoying attacks in an ip network is called the man in the middle attack. such an attack occurs if an attacker is able to receive, process, possibly modify and forward all the packets exchanged between a source and a destination. as the attacker receives all the packets it can easily collect passwords or credit card numbers or even inject fake information in an established tcp connection. icmp redirects unfortunately enable an attacker to easily perform such an attack. in the ﬁgure above, consider host h that is attached to the same lan as a and r1. if h sends to a an icmp redirect for preﬁx 138.48.0.0/16, a forwards to h all the packets that it wants to send to this preﬁx. h can then forward them to r2. to avoid these attacks, hosts should ignore the icmp redirect messages that they receive.
ping(8) is often used by network operators to verify that a given ip address is reachable. each host is supposed 10 to reply with an icmp echo reply message when its receives an icmp echo request message. a sample usage of ping(8) is shown below.
ping 130.104.1.1 ping 130.104.1.1 (130.104.1.1): 56 data bytes 64 bytes from 130.104.1.1: icmp_seq=0 ttl=243 time=19.961 ms 64 bytes from 130.104.1.1: icmp_seq=1 ttl=243 time=22.072 ms 64 bytes from 130.104.1.1: icmp_seq=2 ttl=243 time=23.064 ms 64 bytes from 130.104.1.1: icmp_seq=3 ttl=243 time=20.026 ms 64 bytes from 130.104.1.1: icmp_seq=4 ttl=243 time=25.099 ms --- 130.104.1.1 ping statistics --5 packets transmitted, 5 packets received, 0% packet loss round-trip min/avg/max/stddev = 19.961/22.044/25.099/1.938 ms
• 2 : packet too big. the router that was to send the icmpv6 message received an ipv6 packet that is larger than the mtu of the outgoing link. the icmpv6 message contains the mtu of this link in bytes. this allows the sending host to implement path mtu discovery rfc 1981
• 3 : time exceeded. this error message can be sent either by a router or by a host. a router would set code to 0 to report the reception of a packet whose hop limit reached 0. a host would set code to 1 to report that it was unable to reassemble received ipv6 fragments.
• 4 : parameter problem. this icmpv6 message is used to report either the reception of an ipv6 packet with an erroneous header ﬁeld (type 0) or an unknown next header or ip option (types 1 and 2). in this case, the message body contains the erroneous ipv6 packet and the ﬁrst 32 bits of the message body contain a pointer to the error.
two types of informational icmpv6 messages are deﬁned in rfc 4443 : echo request and echo reply, which are used to test the reachability of a destination by using ping6(8). icmpv6 also allows the discovery of the path between a source and a destination by using traceroute6(8). the output below shows a traceroute between a host at uclouvain and one of the main ietf servers. note that this ipv6 path is different than the ipv4 path that was described earlier although the two traceroutes were performed at the same time.
2001:6a8:3080:2::1 13.821 ms 2001:6a8:3000:8000::1 0.651 ms 10ge.cr2.bruvil.belnet.net 3.402 ms 10ge.cr2.brueve.belnet.net 3.668 ms 10ge.cr2.brueve.belnet.net belnet.rt1.ams.nl.geant2.net 10.598 ms so-7-0-0.rt2.cop.dk.geant2.net kbn-ipv6-b1.ipv6.telia.net 21.078 ms s-ipv6-b1-link.ipv6.telia.net 31.312 ms s-ipv6-b1-link.ipv6.telia.net 61.986 ms
note: rate limitation of icmp messages high-end hardware based routers use special purpose chips on their interfaces to forward ipv6 packets at line rate. these chips are optimised to process correct ip packets. they are not able to create icmp messages at line rate. when such a chip receives an ip packet that triggers an icmp message, it interrupts the main cpu of the router and the software running on this cpu processes the packet. this cpu is much slower than the hardware acceleration found on the interfaces [gill2004]. it would be overloaded if it had to process ip packets at line rate and generate one icmp message for each received packet. to protect this cpu, high-end routers limit the rate at which the hardware can interrupt the main cpu and thus the rate at which icmp messages can be generated. this implies that not all erroneous ip packets cause the transmission of an icmp message. the risk of overloading the main cpu of the router is also the reason why using hop-by-hop ipv6 options, including the router alter option is discouraged 20.
must forward the entire delimiter to its downstream neighbour. it is only when it receives the fourth bit of the access control ﬁeld (i.e. the token bit) that the station knows whether the frame is a data frame or a token. if the token bit is reset, it indicates a data frame and the remaining bits of the data frame must be forwarded to the downstream station. otherwise (token bit is set), this is a token and the station can capture it by resetting the bit that is currently in its buffer. thanks to this modiﬁcation, the beginning of the token is now the beginning of a data frame and the station can switch to transmit mode and send its data frame starting at the ﬁfth bit of the access control ﬁeld. thus, the one-bit delay introduced by each token ring station plays a key role in enabling the stations to efﬁciently capture the token. after having transmitted its data frame, the station must remain in transmit mode until it has received the last bit of its own data frame. this ensures that the bits sent by a station do not remain in the network forever. a data frame sent by a station in a token ring network passes in front of all stations attached to the network. each station can detect the data frame and analyse the destination address to possibly capture the frame. the frame status ﬁeld that appears after the ending delimiter is used to provide acknowledgements without requiring special frames. the frame status contains two ﬂags : a and c. both ﬂags are reset when a station sends a data frame. these ﬂags can be modiﬁed by their recipients. when a station senses its address as the destination address of a frame, it can capture the frame, check its crc and place it in its own buffers. the destination of a frame must set the a bit (resp. c bit) of the frame status ﬁeld once it has seen (resp. copied) a data frame. by inspecting the frame status of the returning frame, the sender can verify whether its frame has been received correctly by its destination. the text above describes the basic operation of a token ring network when all stations work correctly. unfortunately, a real token ring network must be able to handle various types of anomalies and this increases the complexity of token ring stations. we brieﬂy list the problems and outline their solutions below. a detailed description of the operation of token ring stations may be found in [802.5]. the ﬁrst problem is when all the stations attached to the network start. one of them must bootstrap the network by sending the ﬁrst token. for this, all stations implement a distributed election mechanism that is used to select the monitor. any station can become a monitor. the monitor manages the token ring network and ensures that it operates correctly. its ﬁrst role is to introduce a delay of 24 bit transmission times to ensure that the token can travel smoothly on the ring. second, the monitor sends the ﬁrst token on the ring. it must also verify that the token passes regularly. according to the token ring standard [802.5], a station cannot retain the token to transmit data frames for a duration longer than the token holding time (tht) (slightly less than 10 milliseconds). on a network containing n stations, the monitor must receive the token at least every n × t ht seconds. if the monitor does not receive a token during such a period, it cuts the ring for some time and then reinitialises the ring and sends a token. several other anomalies may occur in a token ring network. for example, a station could capture a token and be powered off before having resent the token. another station could have captured the token, sent its data frame and be powered off before receiving all of its data frame. in this case, the bit string corresponding to the end of a frame would remain in the ring without being removed by its sender. several techniques are deﬁned in [802.5] to allow the monitor to handle all these problems. if unfortunately, the monitor fails, another station will be elected to become the new monitor.
in this section, we review the key characteristics of several datalink layer technologies. we discuss in more detail the technologies that are widely used today. a detailed survey of all datalink layer technologies would be outside the scope of this book.
many point-to-point datalink layers 2 have been developed, starting in the 1960s [mcfadyen1976]. in this section, we focus on the protocols that are often used to transport ip packets between hosts or routers that are directly connected by a point-to-point link. this link can be a dedicated physical cable, a leased line through the telephone network or a dial-up connection with modems on the two communicating hosts.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
in the example above, the mta running on mta.example.org opens a tcp connection to the smtp server on host smtp.example.com. the lines preﬁxed with s: (resp. c:) are the responses sent by the server (resp. the commands sent by the client). the server sends its greetings as soon as the tcp connection has been established. the client then sends the ehlo command with its fully qualiﬁed domain name. the server replies with reply-code 250 and sends its greetings. the smtp association can now be used to exchange an email. to send an email, the client must ﬁrst provide the address of the recipient with rcpt to:. then it uses the mail from: with the address of the sender. both the recipient and the sender are accepted by the server. the client can now issue the data command to start the transfer of the email message. after having received the 354 reply code, the client sends the headers and the body of its email message. the client indicates the end of the message by sending a line containing only the . (dot) character 15. the server conﬁrms that the email message has been queued for delivery or transmission with a reply code of 250. the client issues the quit command to close the session and the server conﬁrms with reply-code 221, before closing the tcp connection.
note: open smtp relays and spam since its creation in 1971, email has been a very useful tool that is used by many users to exchange lots of information. in the early days, all smtp servers were open and anyone could use them to forward emails towards their ﬁnal destination. unfortunately, over the years, some unscrupulous users have found ways to use email for marketing purposes or to send malware. the ﬁrst documented abuse of email for marketing purposes occurred in 1978 when a marketer who worked for a computer vendor sent a marketing email to many arpanet users. at that time, the arpanet could only be used for research purposes and this was an abuse of the acceptable use policy. unfortunately, given the extremely low cost of sending emails, the problem of unsolicited emails has not stopped. unsolicited emails are now called spam and a study carried out by enisa in 2009 reveals that 95% of email was spam and this number seems to continue to grow. this places a burden on the email infrastructure of internet service providers and large companies that need to process many useless messages. given the amount of spam messages, smtp servers are no longer open rfc 5068. several extensions to smtp have been developed in recent years to deal with this problem. for example, the smtp authentication scheme deﬁned in rfc 4954 can be used by an smtp server to authenticate a client. several techniques have also been proposed to allow smtp servers to authenticate the messages sent by their users rfc 4870 rfc 4871 .
when the ﬁrst versions of smtp were designed, the internet was composed of minicomputers that were used by an entire university department or research lab. these minicomputers were used by many users at the same time. email was mainly used to send messages from a user on a given host to another user on a remote host. at that time, smtp was the only protocol involved in the delivery of the emails as all hosts attached to the network were running an smtp server. on such hosts, an email destined to local users was delivered by placing the email in a special directory or ﬁle owned by the user. however, the introduction of personal computers in the 1980s, changed this environment. initially, users of these personal computers used applications such as telnet to open a remote session on the local minicomputer to read their email. this was not user-friendly. a better solution appeared with the development of user friendly email client applications on personal computers. several protocols were designed to allow these client applications to retrieve the email messages destined to a user from his/her server. two of these protocols became popular and are still used today. the post ofﬁce protocol (pop), deﬁned in rfc 1939, is the simplest one. it allows a client to download all the messages destined to a given user from his/her email server. we describe pop brieﬂy in this section. the second protocol is the internet message access protocol (imap), deﬁned in rfc 3501. imap is more powerful, but also more complex than pop. imap was designed to allow client applications to efﬁciently access in real-time to messages stored in various folders on servers. imap
must forward the entire delimiter to its downstream neighbour. it is only when it receives the fourth bit of the access control ﬁeld (i.e. the token bit) that the station knows whether the frame is a data frame or a token. if the token bit is reset, it indicates a data frame and the remaining bits of the data frame must be forwarded to the downstream station. otherwise (token bit is set), this is a token and the station can capture it by resetting the bit that is currently in its buffer. thanks to this modiﬁcation, the beginning of the token is now the beginning of a data frame and the station can switch to transmit mode and send its data frame starting at the ﬁfth bit of the access control ﬁeld. thus, the one-bit delay introduced by each token ring station plays a key role in enabling the stations to efﬁciently capture the token. after having transmitted its data frame, the station must remain in transmit mode until it has received the last bit of its own data frame. this ensures that the bits sent by a station do not remain in the network forever. a data frame sent by a station in a token ring network passes in front of all stations attached to the network. each station can detect the data frame and analyse the destination address to possibly capture the frame. the frame status ﬁeld that appears after the ending delimiter is used to provide acknowledgements without requiring special frames. the frame status contains two ﬂags : a and c. both ﬂags are reset when a station sends a data frame. these ﬂags can be modiﬁed by their recipients. when a station senses its address as the destination address of a frame, it can capture the frame, check its crc and place it in its own buffers. the destination of a frame must set the a bit (resp. c bit) of the frame status ﬁeld once it has seen (resp. copied) a data frame. by inspecting the frame status of the returning frame, the sender can verify whether its frame has been received correctly by its destination. the text above describes the basic operation of a token ring network when all stations work correctly. unfortunately, a real token ring network must be able to handle various types of anomalies and this increases the complexity of token ring stations. we brieﬂy list the problems and outline their solutions below. a detailed description of the operation of token ring stations may be found in [802.5]. the ﬁrst problem is when all the stations attached to the network start. one of them must bootstrap the network by sending the ﬁrst token. for this, all stations implement a distributed election mechanism that is used to select the monitor. any station can become a monitor. the monitor manages the token ring network and ensures that it operates correctly. its ﬁrst role is to introduce a delay of 24 bit transmission times to ensure that the token can travel smoothly on the ring. second, the monitor sends the ﬁrst token on the ring. it must also verify that the token passes regularly. according to the token ring standard [802.5], a station cannot retain the token to transmit data frames for a duration longer than the token holding time (tht) (slightly less than 10 milliseconds). on a network containing n stations, the monitor must receive the token at least every n × t ht seconds. if the monitor does not receive a token during such a period, it cuts the ring for some time and then reinitialises the ring and sends a token. several other anomalies may occur in a token ring network. for example, a station could capture a token and be powered off before having resent the token. another station could have captured the token, sent its data frame and be powered off before receiving all of its data frame. in this case, the bit string corresponding to the end of a frame would remain in the ring without being removed by its sender. several techniques are deﬁned in [802.5] to allow the monitor to handle all these problems. if unfortunately, the monitor fails, another station will be elected to become the new monitor.
in this section, we review the key characteristics of several datalink layer technologies. we discuss in more detail the technologies that are widely used today. a detailed survey of all datalink layer technologies would be outside the scope of this book.
many point-to-point datalink layers 2 have been developed, starting in the 1960s [mcfadyen1976]. in this section, we focus on the protocols that are often used to transport ip packets between hosts or routers that are directly connected by a point-to-point link. this link can be a dedicated physical cable, a leased line through the telephone network or a dial-up connection with modems on the two communicating hosts.
the longest preﬁx match can be implemented by using different data structures. one possibility is to use a trie. the ﬁgure below shows a trie that encodes six routes having different outgoing interfaces.
note: special ipv4 addresses most unicast ipv4 addresses can appear as source and destination addresses in packets on the global internet. however, it is worth noting that some blocks of ipv4 addresses have a special usage, as described in rfc 5735. these include :
in today’s deployments, interface identiﬁers are always 64 bits wide. this implies that while there are 2128 different ipv6 addresses, they must be grouped in 264 subnets. this could appear as a waste of resources, however using 64 bits for the host identiﬁer allows ipv6 addresses to be auto-conﬁgured and also provides some beneﬁts from a security point of view, as explained in section icmpv6
note: textual representation of ipv6 addresses it is sometimes necessary to write ipv6 addresses in text format, e.g. when manually conﬁguring addresses or for documentation purposes. the preferred format for writing ipv6 addresses is x:x:x:x:x:x:x:x, where the x ‘s are hexadecimal digits representing the eight 16-bit parts of the address. here are a few examples of ipv6 addresses :
ipv6 addresses often contain a long sequence of bits set to 0. in this case, a compact notation has been deﬁned. with this notation, :: is used to indicate one or more groups of 16 bits blocks containing only bits set to 0. for example,
• 2001:db8:0:0:8:800:200c:417a is represented as 2001:db8::8:800:200c:417a • ff01:0:0:0:0:0:0:101 is represented as ff01::101 • 0:0:0:0:0:0:0:1 is represented as ::1 • 0:0:0:0:0:0:0:0 is represented as ::
an ipv6 preﬁx can be represented as address/length, where length is the length of the preﬁx in bits. for example, the three notations below correspond to the same ipv6 preﬁx :
in practice, there are several types of ipv6 unicast address. most of the ipv6 unicast addresses are allocated in blocks under the responsibility of iana. the current ipv6 allocations are part of the 2000::/3 address block. regional internet registries (rir) such as ripe in europe, arin in north-america or afrinic in africa have each received a block of ipv6 addresses that they sub-allocate to internet service providers in their region. the isps then sub-allocate addresses to their customers. when considering the allocation of ipv6 addresses, two types of address allocations are often distinguished. the rirs allocate provider-independent (pi) addresses. pi addresses are usually allocated to internet service providers and large companies that are connected to at least two different isps [csp2009]. once a pi address block has been allocated to a company, this company can use its address block with the provider of its choice and change its provider at will. internet service providers allocate provider-aggregatable (pa) address blocks from their own pi address block to their customers. a company that is connected to only one isp should only use pa addresses.
in today’s deployments, interface identiﬁers are always 64 bits wide. this implies that while there are 2128 different ipv6 addresses, they must be grouped in 264 subnets. this could appear as a waste of resources, however using 64 bits for the host identiﬁer allows ipv6 addresses to be auto-conﬁgured and also provides some beneﬁts from a security point of view, as explained in section icmpv6
note: textual representation of ipv6 addresses it is sometimes necessary to write ipv6 addresses in text format, e.g. when manually conﬁguring addresses or for documentation purposes. the preferred format for writing ipv6 addresses is x:x:x:x:x:x:x:x, where the x ‘s are hexadecimal digits representing the eight 16-bit parts of the address. here are a few examples of ipv6 addresses :
ipv6 addresses often contain a long sequence of bits set to 0. in this case, a compact notation has been deﬁned. with this notation, :: is used to indicate one or more groups of 16 bits blocks containing only bits set to 0. for example,
• 2001:db8:0:0:8:800:200c:417a is represented as 2001:db8::8:800:200c:417a • ff01:0:0:0:0:0:0:101 is represented as ff01::101 • 0:0:0:0:0:0:0:1 is represented as ::1 • 0:0:0:0:0:0:0:0 is represented as ::
an ipv6 preﬁx can be represented as address/length, where length is the length of the preﬁx in bits. for example, the three notations below correspond to the same ipv6 preﬁx :
in practice, there are several types of ipv6 unicast address. most of the ipv6 unicast addresses are allocated in blocks under the responsibility of iana. the current ipv6 allocations are part of the 2000::/3 address block. regional internet registries (rir) such as ripe in europe, arin in north-america or afrinic in africa have each received a block of ipv6 addresses that they sub-allocate to internet service providers in their region. the isps then sub-allocate addresses to their customers. when considering the allocation of ipv6 addresses, two types of address allocations are often distinguished. the rirs allocate provider-independent (pi) addresses. pi addresses are usually allocated to internet service providers and large companies that are connected to at least two different isps [csp2009]. once a pi address block has been allocated to a company, this company can use its address block with the provider of its choice and change its provider at will. internet service providers allocate provider-aggregatable (pa) address blocks from their own pi address block to their customers. a company that is connected to only one isp should only use pa addresses.
to deal with this problem, transport protocols combine two solutions. first, they use 32 bits or more to encode the sequence number in the segment header. this increases the overhead, but also increases the delay between the transmission of two different segments having the same sequence number. second, transport protocols require the network layer to enforce a maximum segment lifetime (msl). the network layer must ensure that no packet remains in the network for more than msl seconds. in the internet the msl is assumed 6 to be 2 minutes rfc 793. note that this limits the maximum bandwidth of a transport protocol. if it uses n bits to encode its sequence numbers, then it cannot send more than 2n segments every msl seconds. transport protocols often need to send data in both directions. to reduce the overhead caused by the acknowledgements, most transport protocols use piggybacking. thanks to this technique, a transport entity can place inside the header of the data segments that it sends, the acknowledgements and the receive window that it advertises for the opposite direction of the data ﬂow. the main advantage of piggybacking is that it reduces the overhead as it is not necessary to send a complete segment to carry an acknowledgement. this is illustrated in the ﬁgure below where the acknowledgement number is underlined in the data segments. piggybacking is only used when data ﬂows in both directions. a receiver will generate a pure acknowledgement when it does not send data in the opposite direction as shown in the bottom of the ﬁgure.
6 as we will see in the next chapter, the internet does not strictly enforce this msl. however, it is reasonable to expect that most packets on the internet will not remain in the network during more than 2 minutes. there are a few exceptions to this rule, such as rfc 1149 whose implementation is described in http://www.blug.linux.no/rfc1149/ but there are few real links supporting rfc 1149 in the internet.
note: reliability of the connection-oriented service an important point to note about the connection-oriented service is its reliability. a connection-oriented service can only guarantee the correct delivery of all sdus provided that the connection has been released gracefully. this implies that while the connection is active, there is no guarantee for the actual delivery of the sdus exchanged as the connection may need to be released abruptly at any time.
given the growing complexity of computer networks, during the 1970s network researchers proposed various reference models to facilitate the description of network protocols and services. of these, the open systems interconnection (osi) model [zimmermann80] was probably the most inﬂuential. it served as the basis for the standardisation work performed within the iso to develop global computer network standards. the reference model that we use in this book can be considered as a simpliﬁed version of the osi reference model 4.
our reference model is divided into ﬁve layers, as shown in the ﬁgure below. starting from the bottom, the ﬁrst layer is the physical layer. two communicating devices are linked through a physical medium. this physical medium is used to transfer an electrical or optical signal between two directly connected devices. several types of physical mediums are used in practice :
• electrical cable. information can be transmitted over different types of electrical cables. the most common ones are the twisted pairs that are used in the telephone network, but also in enterprise networks and coaxial cables. coaxial cables are still used in cable tv networks, but are no longer used in enterprise networks. some networking technologies operate over the classical electrical cable.
• optical ﬁber. optical ﬁbers are frequently used in public and enterprise networks when the distance between the communication devices is larger than one kilometer. there are two main types of optical ﬁbers : multimode and monomode. multimode is much cheaper than monomode ﬁber because a led can be
sourceproviderdestinationtimedata.request("a")source -> destinationconnection closedconnection openedconnection openeddata.request("b")data.request("c")data.indication("a")data.indication("b")disconnect.req(graceful)disconnect.ind(graceful)data.indication("c")data.indication("d")data.request("d")disconnect.ind(graceful)disconnect.req(graceful)connection closedconnection closedsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
is represented by a plain horizontal arrow, to which the name of the primitive is attached. the dashed lines are used to represent the possible relationship between two (or more) primitives. such a diagram provides information about the ordering of the different primitives, but the distance between two primitives does not represent a precise amount of time. the ﬁgure below provides a representation of the connectionless service as a time-sequence diagram. the user on the left, having address s, issues a data.request primitive containing sdu m that must be delivered by the service provider to destination d. the dashed line between the two primitives indicates that the data.indication primitive that is delivered to the user on the right corresponds to the data.request primitive sent by the user on the left.
there are several possible implementations of the connectionless service, which we will discuss later in this book. before studying these realisations, it is useful to discuss the possible characteristics of the connectionless service. a reliable connectionless service is a service where the service provider guarantees that all sdus submitted in data.requests by a user will eventually be delivered to their destination. such a service would be very useful for users, but guaranteeing perfect delivery is difﬁcult in practice. for this reason, computer networks usually support an unreliable connectionless service. an unreliable connectionless service may suffer from various types of problems compared to a reliable connectionless service. first of all, an unreliable connectionless service does not guarantee the delivery of all sdus. this can be expressed graphically by using the time-sequence diagram below. in practice, an unreliable connectionless service will usually deliver a large fraction of the sdus. however, since the delivery of sdus is not guaranteed, the user must be able to recover from the loss of any sdu. a second imperfection that may affect an unreliable connectionless service is that it may duplicate sdus. some unreliable connectionless service providers may deliver an sdu sent by a user twice or even more. this is illustrated by the time-sequence diagram below. finally, some unreliable connectionless service providers may deliver to a destination a different sdu than the one that was supplied in the data.request. this is illustrated in the ﬁgure below. when a user interacts with a service provider, it must precisely know the limitations of the underlying service to be able to overcome any problem that may arise. this requires a precise deﬁnition of the characteristics of the underlying service. another important characteristic of the connectionless service is whether it preserves the ordering of the sdus sent by one user. from the user’s viewpoint, this is often a desirable characteristic. this is illustrated in the ﬁgure below. however, many connectionless services, and in particular the unreliable services, do not guarantee that they will always preserve the ordering of the sdus sent by each user. this is illustrated in the ﬁgure below.
another problem faced by wireless networks is often called the hidden station problem. in a wireless network, radio signals are not always propagated same way in all directions. for example, two devices separated by a wall may not be able to receive each other’s signal while they could both be receiving the signal produced by a third host. this is illustrated in the ﬁgure below, but it can happen in other environments. for example, two devices that are on different sides of a hill may not be able to receive each other’s signal while they are both able to receive the signal sent by a station at the top of the hill. furthermore, the radio propagation conditions may change with time. for example, a truck may temporarily block the communication between two nearby devices.
to avoid collisions in these situations, csma/ca allows devices to reserve the transmission channel for some time. this is done by using two control frames : request to send (rts) and clear to send (cts). both are very short frames to minimize the risk of collisions. to reserve the transmission channel, a device sends a rts frame to the intended recipient of the data frame. the rts frame contains the duration of the requested reservation. the recipient replies, after a sifs delay, with a cts frame which also contains the duration of the reservation. as the duration of the reservation has been sent in both rts and cts, all hosts that could collide with either the sender or the reception of the data frame are informed of the reservation. they can compute the total duration of the transmission and defer their access to the transmission channel until then. this is illustrated in the ﬁgure below where host a reserves the transmission channel to send a data frame to host b. host c notices the reservation and defers its transmission.
the utilization of the reservations with csma/ca is an optimisation that is useful when collisions are frequent. if there are few collisions, the time required to transmit the rts and cts frames can become signiﬁcant and in particular when short frames are exchanged. some devices only turn on rts/cts after transmission errors.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
many protocols have been deﬁned for networked applications. in this section, we describe some of the important applications that are used on the internet. we ﬁrst explain the domain name system (dns) that enables hosts to be identiﬁed by human-friendly names instead of the ipv4 or ipv6 addresses that are used by the network. then, we describe the operation of electronic mail, one of the ﬁrst killer applications on the global internet, and the protocols used on world wide web.
in the early days of the internet, there were only a few number of hosts (mainly minicomputers) connected to the network. the most popular applications were remote login and ﬁle transfer. by 1983, there were already ﬁve hundred hosts attached to the internet. each of these hosts were identiﬁed by a unique ipv4 address. forcing human users to remember the ipv4 addresses of the remote hosts that they want to use was not user-friendly. human users prefer to remember names, and use them when needed. using names as aliases for addresses is a common technique in computer science. it simpliﬁes the development of applications and allows the developer to ignore the low level details. for example, by using a programming language instead of writing machine code, a developer can write software without knowing whether the variables that it uses are stored in memory or inside registers. because names are at a higher level than addresses, they allow (both in the example of programming above, and on the internet) to treat addresses as mere technical identiﬁers, which can change at will. only the names are stable. on today’s internet, where switching to another isp means changing your ip addresses, the user-friendliness of domain names is less important (they are not often typed by users) but their stability remains a very important, may be their most important property. the ﬁrst solution that allowed applications to use names was the hosts.txt ﬁle. this ﬁle is similar to the symbol table found in compiled code. it contains the mapping between the name of each internet host and its associated ip address 2. it was maintained by sri international that coordinated the network information center (nic). when a new host was connected to the network, the system administrator had to register its name and ip address at the nic. the nic updated the hosts.txt ﬁle on its server. all internet hosts regularly retrieved the updated hosts.txt ﬁle from the server maintained by sri. this ﬁle was stored at a well-known location on each internet host (see rfc 952) and networked applications could use it to ﬁnd the ip address corresponding to a name. a hosts.txt ﬁle can be used when there are up to a few hundred hosts on the network. however, it is clearly not suitable for a network containing thousands or millions of hosts. a key issue in a large network is to deﬁne a suitable naming scheme. the arpanet initially used a ﬂat naming space, i.e. each host was assigned a unique name. to limit collisions between names, these names usually contained the name of the institution and a sufﬁx to identify the host inside the institution (a kind of poor man’s hierarchical naming scheme). on the arpanet few institutions had several hosts connected to the network. however, the limitations of a ﬂat naming scheme became clear before the end of the arpanet and rfc 819 proposed a hierarchical naming scheme. while rfc 819 discussed the possibility of organising the names as a directed graph, the internet opted eventually for a tree structure capable of containing all names. in this tree, the top-level domains are those that are directly attached to the root. the ﬁrst top-level domain was .arpa 3. this top-level name was initially added as a sufﬁx to the names of the hosts attached to the arpanet and listed in the hosts.txt ﬁle. in 1984, the .gov, .edu, .com, .mil and .org generic top-level domain names were added and rfc 1032 proposed the utilisation of the two letter iso-3166 country codes as top-level domain names. since iso-3166 deﬁnes a two letter code for each country recognised by the united nations, this allowed all countries to automatically have a top-level domain. these domains include .be for belgium, .fr for france, .us for the usa, .ie for ireland or .tv for tuvalu, a group of small islands in the paciﬁc and .tm for turkmenistan. today, the set of top-level domain-names is managed by the internet corporation for assigned names and numbers (icann). recently, icann added a dozen of generic top-level domains that are not related to a country and the .cat top-level domain has been registered for the catalan language. there are ongoing discussions within icann to increase the number of top-level domains.
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
each top-level domain is managed by an organisation that decides how sub-domain names can be registered. most top-level domain names use a ﬁrst-come ﬁrst served system, and allow anyone to register domain names, but there are some exceptions. for example, .gov is reserved for the us government, .int is reserved for international organisations and names in the .ca are mainly reserved for companies or users who are present in canada.
rfc 1035 recommended the following bnf for fully qualiﬁed domain names, to allow host names with a syntax which works with all applications (the domain names themselves have a much richer syntax).
this grammar speciﬁes that a host name is an ordered list of labels separated by the dot (.) character. each label can contain letters, numbers and the hyphen character (-) 4. fully qualiﬁed domain names are read from left to right. the ﬁrst label is a hostname or a domain name followed by the hierarchy of domains and ending with the root implicitly at the right. the top-level domain name must be one of the registered tlds 5. for example, in the above ﬁgure, www.whitehouse.gov corresponds to a host named www inside the whitehouse domain that belongs to the gov top-level domain. info.ucl.ac.be corresponds to the info domain inside the ucl domain that is included in the ac sub-domain of the be top-level domain. this hierarchical naming scheme is a key component of the domain name system (dns). the dns is a distributed database that contains mappings between fully qualiﬁed domain names and ip addresses. the dns uses the client-server model. the clients are hosts that need to retrieve the mapping for a given name. each nameserver stores part of the distributed database and answers the queries sent by clients. there is at least one nameserver that is responsible for each domain. in the ﬁgure below, domains are represented by circles and there are three hosts inside domain dom (h1, h2 and h3) and three hosts inside domain a.sdom1.dom. as shown in the ﬁgure below, a sub-domain may contain both host names and sub-domains.
chosen by the client. thanks to this identiﬁer, the client can match the received answer with the question that it sent. the qr ﬂag is set to 0 in dns queries and 1 in dns answers. the opcode is used to specify the type of query. for instance, a standard query is when a client sends a name and the server returns the corresponding data and an update request is when the client sends a name and new data and the server then updates its database. the aa bit is set when the server that sent the response has authority for the domain name found in the question section. in the original dns deployments, two types of servers were considered : authoritative servers and nonauthoritative servers. the authoritative servers are managed by the system administrators responsible for a given domain. they always store the most recent information about a domain. non-authoritative servers are servers or resolvers that store dns information about external domains without being managed by the owners of a domain. they may thus provide answers that are out of date. from a security point of view, the authoritative bit is not an absolute indication about the validity of an answer. securing the domain name system is a complex problem that was only addressed satisfactorily recently by the utilisation of cryptographic signatures in the dnssec extensions to dns described in rfc 4033. however, these extensions are outside the scope of this chapter. the rd (recursion desired) bit is set by a client when it sends a query to a resolver. such a query is said to be recursive because the resolver will recurse through the dns hierarchy to retrieve the answer on behalf of the client. in the past, all resolvers were conﬁgured to perform recursive queries on behalf of any internet host. however, this exposes the resolvers to several security risks. the simplest one is that the resolver could become overloaded by having too many recursive queries to process. as of this writing, most resolvers 10 only allow recursive queries from clients belonging to their company or network and discard all other recursive queries. the ra bit indicates whether the server supports recursion. the rcode is used to distinguish between different types of errors. see rfc 1035 for additional details. the last four ﬁelds indicate the size of the question, answer, authority and additional sections of the dns message. the last four sections of the dns message contain resource records (rr). all rrs have the same top level format shown in the ﬁgure below. in a resource record (rr), the name indicates the name of the node to which this resource record pertains. the two bytes type ﬁeld indicate the type of resource record. the class ﬁeld was used to support the utilisation of the dns in other environments than the internet. the ttl ﬁeld indicates the lifetime of the resource record in seconds. this ﬁeld is set by the server that returns an answer and indicates for how long a client or a resolver can store the resource record inside its cache. a long ttl indicates a stable rr. some companies use short ttl values for mobile hosts and also for popular servers.
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
ﬁeld of the rts frame indicates the duration of the entire reservation (i.e. the time required to transmit the cts, the data frame, the acknowledgements and the required sifs delays). the cts frame has the same format as the acknowledgement frame.
note: the 802.11 service despite the utilization of acknowledgements, the 802.11 layer only provides an unreliable connectionless service like ethernet networks that do not use acknowledgements. the 802.11 acknowledgements are used to minimize the probability of frame duplication. they do not guarantee that all frames will be correctly received by their recipients. like ethernet, 802.11 networks provide a high probability of successful delivery of the frames, not a guarantee. furthermore, it should be noted that 802.11 networks do not use acknowledgements for multicast and broadcast frames. this implies that in practice such frames are more likely to suffer from transmission errors than unicast frames.
in addition to the data and control frames that we have brieﬂy described above, 802.11 networks use several types of management frames. these management frames are used for various purposes. we brieﬂy describe some of these frames below. a detailed discussion may be found in [802.11] and [gast2002]. a ﬁrst type of management frames are the beacon frames. these frames are broadcasted regularly by access points. each beacon frame contains information about the capabilities of the access point (e.g. the supported 802.11 transmission rates) and a service set identity (ssid). the ssid is a null-terminated ascii string that can contain up to 32 characters. an access point may support several ssids and announce them in beacon frames. an access point may also choose to remain silent and not advertise beacon frames. in this case, wifi stations may send probe request frames to force the available access points to return a probe response frame.
note: ip over 802.11 two types of encapsulation schemes were deﬁned to support ip in ethernet networks : the original encapsulation scheme, built above the ethernet dix format is deﬁned in rfc 894 and a second encapsulation rfc 1042 scheme, built above the llc/snap protocol [802.2]. in 802.11 networks, the situation is simpler and only the rfc 1042 encapsulation is used. in practice, this encapsulation adds 6 bytes to the 802.11 header. the ﬁrst four bytes correspond to the llc/snap header. they are followed by the two bytes ethernet type ﬁeld (0x800 for ip and 0x806 for arp). the ﬁgure below shows an ip packet encapsulated in an 802.11 frame.
the second important utilisation of the management frames is to allow a wifi station to be associated with an access point. when a wifi station starts, it listens to beacon frames to ﬁnd the available ssids. to be allowed to
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
• the privileged port numbers (1 < port < 1024 ) • the ephemeral port numbers ( ofﬁcially 8 49152 <= port <= 65535 ) • the registered port numbers (ofﬁcially 1024 <= port < 49152)
in most unix variants, only processes having system administrator privileges can be bound to port numbers smaller than 1024. well-known servers such as dns, ntp or rpc use privileged port numbers. when a client needs to use udp, it usually does not require a speciﬁc port number. in this case, the udp implementation will allocate the ﬁrst available port number in the ephemeral range. the range of registered port numbers should be used by servers. in theory, developers of network servers should register their port number ofﬁcially through iana, but few developers do this.
• a pseudo header containing the source ip address, the destination ip address and a 32 bits bit ﬁeld containing the most signiﬁcant byte set to 0, the second set to 17 and the length of the udp segment in the lower two bytes
this pseudo-header allows the receiver to detect errors affecting the ip source or destination addresses placed in the ip layer below. this is a violation of the layering principle that dates from the time when udp and ip were elements of a single protocol. it should be noted that if the checksum algorithm computes value ‘0x0000’, then value ‘0xffff’ is transmitted. a udp segment whose checksum is set to ‘0x0000’ is a segment for which the transmitter did not compute a checksum upon transmission. some nfs servers chose to disable udp checksums for performance reasons, but this caused problems that were difﬁcult to diagnose. in practice, there are rarely good reasons to disable udp checksums. a detailed discussion of the implementation of the internet checksum may be found in rfc 1071
several types of applications rely on udp. as a rule of thumb, udp is used for applications where delay must be minimised or losses can be recovered by the application itself. a ﬁrst class of the udp-based applications are applications where the client sends a short request and expects a quick and short answer. the dns is an example of
we explained how a transport connection can be safely released. we then discussed the mechanisms that are used in tcp, the reliable transport protocol, used by most applications on the internet. most notably, we described the congestion control mechanism that has been included in tcp since the late 1980s and explained how the reliability mechanisms used by tcp have been tuned over the years.
this section is divided in two parts. the ﬁrst part contains exercises on the principles of transport protocols, including tcp. the second part contains programming challenges packet analysis tools to observe the behaviour of transport protocols.
1. consider the alternating bit protocol as described in this chapter • how does the protocol recover from the loss of a data segment ? • how does the protocol recovers from the loss of an acknowledgement ? 2. a student proposed to optimise the alternating bit protocol by adding a negative acknowledgment, i.e. the receiver sends a nak control segment when it receives a corrupted data segment. what kind of information should be placed in this control segment and how should the sender react when receiving such a nak ?
• the 16 bits or the 32 bits cyclical redundancy checks (crc) that are often used on disks, in zip archives and in datalink layer protocols. see http://docs.python.org/library/binascii.html for a python module that contains the 32 bits crc
5. checksums and crcs should not be confused with secure hash functions such as md5 deﬁned in rfc 1321 or sha-1 described in rfc 4634. secure hash functions are used to ensure that ﬁles or sometimes packets/segments have not been modiﬁed. secure hash functions aim at detecting malicious changes while checksums and crcs only detect random transmission errors. perform some experiments with hash functions such as those deﬁned in the http://docs.python.org/library/hashlib.html python hashlib module to verify that this is indeed the case.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
contains information about its origin and its destination, and usually passes through several intermediate devices called routers on its way from its origin to its destination.
most realisations of the network layer, including the internet, do not provide a reliable service. however, many applications need to exchange information reliably and so using the network layer service directly would be very difﬁcult for them. ensuring the reliable delivery of the data produced by applications is the task of the transport layer. transport layer entities exchange segments. a segment is a ﬁnite sequence of bytes that are transported inside one or more packets. a transport layer entity issues segments (or sometimes part of segments) as data.request to the underlying network layer entity. there are different types of transport layers. the most widely used transport layers on the internet are tcp ,that provides a reliable connection-oriented bytestream transport service, and udp ,that provides an unreliable connection-less transport service.
the upper layer of our architecture is the application layer. this layer includes all the mechanisms and data structures that are necessary for the applications. we will use application data unit (adu) to indicate the data exchanged between two entities of the application layer.
in contrast with osi, the tcp/ip community did not spend a lot of effort deﬁning a detailed reference model; in fact, the goals of the internet architecture were only documented after tcp/ip had been deployed [clark88]. rfc 1122 , which deﬁnes the requirements for internet hosts, mentions four different layers. starting from the top, these are :
• an application layer • a transport layer • an internet layer which is equivalent to the network layer of our reference model • a link layer which combines the functionalities of the physical and datalink layers of our ﬁve-layer reference
physical layerdatalinknetworkphysical layerdatalinknetworkphysical layerdatalinknetworkpacketspacketsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportsegmentsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportaduapplicationapplicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
destination (resp. source) port of the segments sent by the client (see ﬁgure utilization of the tcp source and destination ports). a tcp connection is always identiﬁed by ﬁve pieces of information :
• the sequence number (32 bits), acknowledgement number (32 bits) and window (16 bits) ﬁelds are used to provide a reliable data transfer, using a window-based protocol. in a tcp bytestream, each byte of the stream consumes one sequence number. their utilisation will be described in more detail in section tcp reliable data transfer
• the urgent pointer is used to indicate that some data should be considered as urgent in a tcp bytestream. however, it is rarely used in practice and will not be described here. additional details about the utilisation of this pointer may be found in rfc 793, rfc 1122 or [stevens1994]
– the syn ﬂag is used during connection establishment – the fin ﬂag is used during connection release – the rst is used in case of problems or when an invalid segment has been received – when the ack ﬂag is set, it indicates that the acknowledgment ﬁeld contains a valid number. other-
– the urg ﬂag is used together with the urgent pointer – the psh ﬂag is used as a notiﬁcation from the sender to indicate to the receiver that it should pass all the data it has received to the receiving process. however, in practice tcp implementations do not allow tcp users to indicate when the psh ﬂag should be set and thus there are few real utilizations of this ﬂag.
• the reserved ﬁeld was initially reserved for future utilization. it is now used by rfc 3168. • the tcp header length (thl) or data offset ﬁeld is a four bits ﬁeld that indicates the size of the tcp
• the optional header extension is used to add optional information to the tcp header. thanks to this header extension, it is possible to add new ﬁelds to the tcp header that were not planned in the original speciﬁcation. this allowed tcp to evolve since the early eighties. the details of the tcp header extension are explained in sections tcp connection establishment and tcp reliable data transfer.
the rest of this section is organised as follows. we ﬁrst explain the establishment and the release of a tcp connection, then we discuss the mechanisms that are used by tcp to provide a reliable bytestream service. we end the section with a discussion of network congestion and explain the mechanisms that tcp uses to avoid congestion collapse.
a tcp connection is established by using a three-way handshake. the connection establishment phase uses the sequence number, the acknowledgment number and the syn ﬂag. when a tcp connection is established, the two communicating hosts negotiate the initial sequence number to be used in both directions of the connection. for this, each tcp entity maintains a 32 bits counter, which is supposed to be incremented by one at least every 4
microseconds and after each connection establishment 11. when a client host wants to open a tcp connection with a server host, it creates a tcp segment with :
• the syn ﬂag set • the sequence number set to the current value of the 32 bits counter of the server host’s tcp entity • the ack ﬂag set • the acknowledgment number set to the sequence number of the received syn segment incremented by 1 ( mod 232). when a tcp entity sends a segment having x+1 as acknowledgment number, this indicates that it has received all data up to and including sequence number x and that it is expecting data having sequence number x+1. as the syn ﬂag was set in a segment having sequence number x, this implies that setting the syn ﬂag in a segment consumes one sequence number.
this segment is often called a syn+ack segment. the acknowledgment conﬁrms to the client that the server has correctly received the syn segment. the sequence number of the syn+ack segment is used by the server host to verify that the client has received the segment. upon reception of the syn+ack segment, the client host replies with a segment containing :
at this point, the tcp connection is open and both the client and the server are allowed to send tcp segments containing data. this is illustrated in the ﬁgure below. in the ﬁgure above, the connection is considered to be established by the client once it has received the syn+ack segment, while the server considers the connection to be established upon reception of the ack segment. the ﬁrst data segment sent by the client (server) has its sequence number set to x+1 (resp. y+1).
note: computing tcp’s initial sequence number in the original tcp speciﬁcation rfc 793, each tcp entity maintained a clock to compute the initial sequence number (isn) placed in the syn and syn+ack segments. this made the isn predictable and caused a security issue. the typical security problem was the following. consider a server that trusts a host based on its ip address
another utilisation of tcp options during connection establishment is to enable tcp extensions. for example, consider rfc 1323 (which is discussed in tcp reliable data transfer). rfc 1323 deﬁnes tcp extensions to support timestamps and larger windows. if the client supports rfc 1323, it adds a rfc 1323 option to its syn if the server understands this rfc 1323 option and wishes to use it, it replies with an rfc 1323 segment. option in the syn+ack segment and the extension deﬁned in rfc 1323 is used throughout the tcp connection. otherwise, if the server’s syn+ack does not contain the rfc 1323 option, the client is not allowed to use this extension and the corresponding tcp header options throughout the tcp connection. tcp’s option mechanism is ﬂexible and it allows the extension of tcp while maintaining compatibility with older implementations. the tcp options are encoded by using a type length value format where :
• the ﬁrst byte indicates the type of the option. • the second byte indicates the total length of the option (including the ﬁrst two bytes) in bytes • the last bytes are speciﬁc for each type of option
rfc 793 deﬁnes the maximum segment size (mss) tcp option that must be understood by all tcp implementations. this option (type 2) has a length of 4 bytes and contains a 16 bits word that indicates the mss supported by the sender of the syn segment. the mss option can only be used in tcp segments having the syn ﬂag set. rfc 793 also deﬁnes two special options that must be supported by all tcp implementations. the ﬁrst option is end of option. it is encoded as a single byte having value 0x00 and can be used to ensure that the tcp header extension ends on a 32 bits boundary. the no-operation option, encoded as a single byte having value 0x01, can be used when the tcp header extension contains several tcp options that should be aligned on 32 bit boundaries. all other options 14 are encoded by using the tlv format.
note: the robustness principle the handling of the tcp options by tcp implementations is one of the many applications of the robustness principle which is usually attributed to jon postel and is often quoted as “be liberal in what you accept, and conservative in what you send” rfc 1122 concerning the tcp options, the robustness principle implies that a tcp implementation should be able to accept tcp options that it does not understand, in particular in received syn segments, and that it should be able to parse any received segment without crashing, even if the segment contains an unknown tcp option. furthermore, a server should not send in the syn+ack segment or later, options that have not been proposed by the client in the syn segment.
• graceful connection release, where each tcp user can release its own direction of data transfer • abrupt connection release, where either one user closes both directions of data transfer or one tcp entity is forced to close the connection (e.g. because the remote host does not reply anymore or due to lack of resources)
the abrupt connection release mechanism is very simple and relies on a single segment having the rst bit set. a tcp segment containing the rst bit can be sent for the following reasons :
• a non-syn segment was received for a non-existing tcp connection rfc 793 • by extension, some implementations respond with an rst segment to a segment that is received on an existing connection but with an invalid header rfc 3360. this causes the corresponding connection to be closed and has caused security attacks rfc 4953
• by extension, some implementations send an rst segment when they need to close an existing tcp connection (e.g. because there are not enough resources to support this connection or because the remote host is considered to be unreachable). measurements have shown that this usage of tcp rst was widespread [aw05]
easiest and less costly method to send acknowledgements is to place them in the data segments sent in the other direction. however, few application layer protocols exchange data in both directions at the same time and thus this method rarely works. for an application that is sending data segments in one direction only, the remote tcp entity returns empty tcp segments whose only useful information is their acknowledgement number. this may cause a large overhead in wide area network if a pure ack segment is sent in response to each received data segment. most tcp implementations use a delayed acknowledgement strategy. this strategy ensures that piggybacking is used whenever possible, otherwise pure ack segments are sent for every second received data segments when there are no losses. when there are losses or reordering, ack segments are more important for the sender and they are sent immediately rfc 813 rfc 1122. this strategy relies on a new timer with a short delay (e.g. 50 milliseconds) and one additional ﬂag in the tcb. it can be implemented as follows
due to this delayed acknowledgement strategy, during a bulk transfer, a tcp implementation usually acknowledges every second tcp segment received. the default go-back-n retransmission strategy used by tcp has the advantage of being simple to implement, in particular on the receiver side, but when there are losses, a go-back-n strategy provides a lower performance than a selective repeat strategy. the tcp developers have designed several extensions to tcp to allow it to use a selective repeat strategy while maintaining backward compatibility with older tcp implementations. these tcp extensions assume that the receiver is able to buffer the segments that it receives out-of-sequence. the ﬁrst extension that was proposed is the fast retransmit heuristic. this extension can be implemented on tcp senders and thus does not require any change to the protocol. it only assumes that the tcp receiver is able to buffer out-of-sequence segments. from a performance point of view, one issue with tcp’s retransmission timeout is that when there are isolated segment losses, the tcp sender often remains idle waiting for the expiration of its retransmission timeouts. such isolated losses are frequent in the global internet [paxson99]. a heuristic to deal with isolated losses without waiting for the expiration of the retransmission timeout has been included in many tcp implementations since the early 1990s. to understand this heuristic, let us consider the ﬁgure below that shows the segments exchanged over a tcp connection when an isolated segment is lost. as shown above, when an isolated segment is lost the sender receives several duplicate acknowledgements since the tcp receiver immediately sends a pure acknowledgement when it receives an out-of-sequence segment. a duplicate acknowledgement is an acknowledgement that contains the same acknowledgement number as a previous segment. a single duplicate acknowledgement does not necessarily imply that a segment was lost, as a simple reordering of the segments may cause duplicate acknowledgements as well. measurements [paxson99] have shown that segment reordering is frequent in the internet. based on these observations, the fast retransmit heuristic has been included in most tcp implementations. it can be implemented as follows
address. as this address is placed at the beginning of the frame, an ethernet interface can quickly verify whether it is the frame recipient and if not, cancel the processing of the arriving frame. the second ﬁeld is the source address. while the destination address can be either a unicast or a multicast/broadcast address, the source address must always be a unicast address. the third ﬁeld is a 16 bits integer that indicates which type of network layer packet is carried inside the frame. this ﬁeld is often called the ethertype. frequently used ethertype values 6 include 0x0800 for ipv4, 0x86dd for ipv6 7 and 0x806 for the address resolution protocol (arp). the fourth part of the ethernet frame is the payload. the minimum length of the payload is 46 bytes to ensure a minimum frame size, including the header of 512 bits. the ethernet payload cannot be longer than 1500 bytes. this size was found reasonable when the ﬁrst ethernet speciﬁcation was written. at that time, xerox had been using its experimental 3 mbps ethernet that offered 554 bytes of payload and rfc 1122 required a minimum mtu of 572 bytes for ipv4. 1500 bytes was large enough to support these needs without forcing the network adapters to contain overly large memories. furthermore, simulations and measurement studies performed in ethernet networks revealed that csma/cd was able to achieve a very high utilization. this is illustrated in the ﬁgure below based on [sh1980], which shows the channel utilization achieved in ethernet networks containing different numbers of hosts that are sending frames of different sizes.
the last ﬁeld of the ethernet frame is a 32 bit cyclical redundancy check (crc). this crc is able to catch a much larger number of transmission errors than the internet checksum used by ip, udp and tcp [sgp98]. the format of the ethernet frame is shown below.
note: where should the crc be located in a frame ? the transport and datalink layers usually chose different strategies to place their crcs or checksums. transport layer protocols usually place their crcs or checksums in the segment header. datalink layer protocols sometimes place their crc in the frame header, but often in a trailer at the end of the frame. this choice reﬂects implementation assumptions, but also inﬂuences performance rfc 893. when the crc is placed in the trailer, as in ethernet, the datalink layer can compute it while transmitting the frame and insert it at the end of the transmission. all ethernet interfaces use this optimisation today. when the checksum is placed in the header, as in a tcp segment, it is impossible for the network interface to compute it while transmitting the segment. some network interfaces provide hardware assistance to compute the tcp checksum, but this is more complex than if the tcp checksum were placed in the trailer 8.
6 the ofﬁcial list of all assigned ethernet type values is available from http://standards.ieee.org/regauth/ethertype/eth.txt 7 the attentive reader may question the need for different ethertypes for ipv4 and ipv6 while the ip header already contains a version ﬁeld that can be used to distinguish between ipv4 and ipv6 packets. theoretically, ipv4 and ipv6 could have used the same ethertype. unfortunately, developers of the early ipv6 implementations found that some devices did not check the version ﬁeld of the ipv4 packets that they received and parsed frames whose ethertype was set to 0x0800 as ipv4 packets. sending ipv6 packets to such devices would have caused disruptions. to avoid this problem, the ietf decided to apply for a distinct ethertype value for ipv6.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
to deal with this problem, transport protocols combine two solutions. first, they use 32 bits or more to encode the sequence number in the segment header. this increases the overhead, but also increases the delay between the transmission of two different segments having the same sequence number. second, transport protocols require the network layer to enforce a maximum segment lifetime (msl). the network layer must ensure that no packet remains in the network for more than msl seconds. in the internet the msl is assumed 6 to be 2 minutes rfc 793. note that this limits the maximum bandwidth of a transport protocol. if it uses n bits to encode its sequence numbers, then it cannot send more than 2n segments every msl seconds. transport protocols often need to send data in both directions. to reduce the overhead caused by the acknowledgements, most transport protocols use piggybacking. thanks to this technique, a transport entity can place inside the header of the data segments that it sends, the acknowledgements and the receive window that it advertises for the opposite direction of the data ﬂow. the main advantage of piggybacking is that it reduces the overhead as it is not necessary to send a complete segment to carry an acknowledgement. this is illustrated in the ﬁgure below where the acknowledgement number is underlined in the data segments. piggybacking is only used when data ﬂows in both directions. a receiver will generate a pure acknowledgement when it does not send data in the opposite direction as shown in the bottom of the ﬁgure.
6 as we will see in the next chapter, the internet does not strictly enforce this msl. however, it is reasonable to expect that most packets on the internet will not remain in the network during more than 2 minutes. there are a few exceptions to this rule, such as rfc 1149 whose implementation is described in http://www.blug.linux.no/rfc1149/ but there are few real links supporting rfc 1149 in the internet.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
when the ﬁrst computers were built during the second world war, they were expensive and isolated. however, after about twenty years, as their prices gradually decreased, the ﬁrst experiments began to connect computers together. in the early 1960s, researchers including paul baran, donald davies or joseph licklider independently published the ﬁrst papers describing the idea of building computer networks [baran] [licklider1963] . given in the us, the arpanet the cost of computers, sharing them over a long distance was an interesting idea. started in 1969 and continued until the mid 1980s [lccd09]. in france, louis pouzin developed the cyclades network [pouzin1975]. many other research networks were built during the 1970s [moore]. at the same time, the telecommunication and computer industries became interested in computer networks. the telecommunication industry bet on the x25. the computer industry took a completely different approach by designing local area networks (lan). many lan technologies such as ethernet or token ring were designed at that time. during the 1980s, the need to interconnect more and more computers led most computer vendors to develop their own suite of networking protocols. xerox developed [xns] , dec chose decnet [malamud1991] , ibm developed sna [mcfadyen1976] , microsoft introduced netbios [winston2003] , apple bet on appletalk [sao1990] . in the research community, arpanet was decommissioned and replaced by tcp/ip [lccd09] and the reference implementation was developed inside bsd unix [mckusick1999]. universities who were already running unix could thus adopt tcp/ip easily and vendors of unix workstations such as sun or silicon graphics included tcp/ip in their variant of unix. in parallel, the iso, with support from the governments, worked on developing an open 1 suite of networking protocols. in the end, tcp/ip became the de facto standard that is not only used within the research community. during the 1990s and the early 2000s, the growth of the usage of tcp/ip continued, and today proprietary protocols are seldom used. as shown by the ﬁgure below, that provides the estimation of the number of hosts attached to the internet, the internet has sustained large growth throughout the last 20+ years.
1 open in iso terms was in contrast with the proprietary protocol suites whose speciﬁcation was not always publicly available. the us government even mandated the usage of the osi protocols (see rfc 1169), but this was not sufﬁcient to encourage all users to switch to the osi protocol suite that was considered by many as too complex compared to other protocol suites.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
another very useful debugging tool is traceroute(8). the traceroute man page describes this tool as “print the route packets take to network host”. traceroute uses the ttl exceeded icmp messages to discover the intermediate routers on the path towards a destination. the principle behind traceroute is very simple. when a router receives an ip packet whose ttl is set to 1 it decrements the ttl and is forced to return to the sending host a ttl exceeded icmp message containing the header and the ﬁrst bytes of the discarded ip packet. to discover all routers on a network path, a simple solution is to ﬁrst send a packet whose ttl is set to 1, then a packet whose ttl is set to 2, etc. a sample traceroute output is shown below.
cshalles3.sri.ucl.ac.be (192.168.251.230) cthalles.sri.ucl.ac.be (192.168.251.229) ctpythagore.sri.ucl.ac.be (130.104.254.230) fe.m20.access.lln.belnet.net (193.191.11.9) 10ge.cr2.brueve.belnet.net (193.191.16.22) 212.3.237.13 (212.3.237.13) 5.347 ms ae-11-11.car1.brussels1.level3.net (4.69.136.249) ae-6-6.ebr1.london1.level3.net (4.69.136.246) ae-100-100.ebr2.london1.level3.net (4.69.141.166)
ae-41-41.ebr1.newyork1.level3.net (4.69.137.66) ae-43-43.ebr1.newyork1.level3.net (4.69.137.74) ae-42-42.ebr1.newyork1.level3.net (4.69.137.70) ae-2-2.ebr1.newark1.level3.net (4.69.132.98) ae-14-51.car4.newark1.level3.net (4.68.99.8) ex1-tg2-0.eqnwnj.sbcglobal.net (151.164.89.249) 151.164.95.190 (151.164.95.190) ded-p10-0.pltn13.sbcglobal.net (151.164.191.243) ams-1152322.cust-rtr.swbell.net (75.61.192.10) mail.ietf.org (64.170.98.32) 158.427 ms
the above traceroute(8) output shows a 17 hops path between a host at uclouvain and one of the main ietf servers. for each hop, traceroute provides the ipv4 address of the router that sent the icmp message and the measured round-trip-time between the source and this router. traceroute sends three probes with each ttl value. in some cases, such as at the 10th hop above, the icmp messages may be received from different addresses. this is usually because different packets from the same source have followed different paths 11 in the network. another important utilisation of icmp messages is to discover the maximum mtu that can be used to reach a destination without fragmentation. as explained earlier, when an ipv4 router receives a packet that is larger than the mtu of the outgoing link, it must fragment the packet. unfortunately, fragmentation is a complex operation and routers cannot perform it at line rate [km1995]. furthermore, when a tcp segment is transported in an ip packet that is fragmented in the network, the loss of a single fragment forces tcp to retransmit the entire segment (and thus all the fragments). if tcp was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. in addition, ip reassembly causes several challenges at high speed as discussed in rfc 4963. using ip fragmentation to allow udp applications to exchange large messages raises several security issues [kps2003]. icmp, combined with the don’t fragment (df) ipv4 ﬂag, is used by tcp implementations to discover the largest mtu size that is allowed to reach a destination host without causing network fragmentation. this is the path mtu discovery mechanism deﬁned in rfc 1191. a tcp implementation that includes path mtu discovery (most do) requests the ipv4 layer to send all segments inside ipv4 packets having the df ﬂag set. this prohibits intermediate routers from fragmenting these packets. if a router needs to forward an unfragmentable packet over a link with a smaller mtu, it returns a fragmentation needed icmp message to the source, indicating the mtu of its outgoing link. this icmp message contains in the mtu of the router’s outgoing link in its data ﬁeld. upon reception of this icmp message, the source tcp implementation adjusts its maximum segment size (mss) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
note: a note on timers the ﬁrst rip implementations sent their distance vector exactly every 30 seconds. this worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time [fj1994]. they collected packet traces in these networks and found that after some time the routers’ timers became synchronised, i.e. almost all routers were sending their distance vectors at almost the same time. this synchronisation of the transmission times of the distance vectors caused an overload on the routers’ cpu but also increased the convergence time of the protocol in some cases. this was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. sally floyd and van jacobson proposed in [fj1994] a simple solution to solve this synchronisation problem. instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval rfc 2080. this randomisation of the delays prevents the synchronisation that occurs with a ﬁxed delay and is now a recommended practice for protocol designers.
link-state routing protocols are used in ip networks. open shortest path first (ospf), deﬁned in rfc 2328, is the link state routing protocol that has been standardised by the ietf. the last version of ospf, which supports ipv6, is deﬁned in rfc 5340. ospf is frequently used in enterprise networks and in some isp networks. however, isp networks often use the is-is link-state routing protocol [iso10589] , which was developed for the iso clnp protocol but was adapted to be used in ip rfc 1195 networks before the ﬁnalisation of the standardisation of ospf. a detailed analysis of isis and ospf may be found in [bmo2006] and [perlman2000]. additional information about ospf may be found in [moy1998]. compared to the basics of link-state routing protocols that we discussed in section link state routing, there are some particularities of ospf that are worth discussing. first, in a large network, ﬂooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. a better approach would be to introduce hierarchical routing. hierarchical routing divides the network into regions. all the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. ospf supports a restricted variant of hierarchical routing. in ospf’s terminology, a region is called an area. ospf imposes restrictions on how a network can be divided into areas. an area is a set of routers and links that are grouped together. usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area 23 . an ospf area contains two types of routers rfc 2328:
• internal router : a router whose directly connected networks belong to the area • area border routers : a router that is attached to several areas.
for example, the network shown in the ﬁgure below has been divided into three areas : area 1, containing routers r1, r3, r4, r5 and ra, area 2 containing r7, r8, r9, r10, rb and rc. ospf areas are identiﬁed by a 32 bit integer, which is sometimes represented as an ip address. among the ospf areas, area 0, also called the backbone area has a special role. the backbone area groups all the area border routers (routers ra, rb and rc in the ﬁgure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
and allows the system administrator to login from this host without giving a password 12. consider now an attacker who knows this particular conﬁguration and is able to send ip packets having the client’s address as source. he can send fake tcp segments to the server, but does not receive the server’s answers. if he can predict the isn that is chosen by the server, he can send a fake syn segment and shortly after the fake ack segment conﬁrming the reception of the syn+ack segment sent by the server. once the tcp connection is open, he can use it to send any command to the server. to counter this attack, current tcp implementations add randomness to the isn. one of the solutions, proposed in rfc 1948 is to compute the isn as
where m is the current value of the tcp clock and h‘is a cryptographic hash function. ‘localhost and remotehost (resp. localport and remoteport ) are the ip addresses (port numbers) of the local and remote host and secret is a random number only known by the server. this method allows the server to use different isns for different clients at the same time. measurements performed with the ﬁrst implementations of this technique showed that it was difﬁcult to implement it correctly, but today’s tcp implementation now generate good isns.
a server could, of course, refuse to open a tcp connection upon reception of a syn segment. this refusal may be due to various reasons. there may be no server process that is listening on the destination port of the syn segment. the server could always refuse connection establishments from this particular client (e.g. due to security reasons) or the server may not have enough resources to accept a new tcp connection at that time. in this case, the server would reply with a tcp segment having its rst ﬂag set and containing the sequence number of the received syn segment as its acknowledgment number. this is illustrated in the ﬁgure below. we discuss the other utilizations of the tcp rst ﬂag later (see tcp connection release).
tcp connection establishment can be described as the four state finite state machine shown below. in this fsm, !x (resp. ?y) indicates the transmission of segment x (resp. reception of segment y) during the corresponding transition. init is the initial state. a client host starts in the init state. it then sends a syn segment and enters the syn sent state where it waits for a syn+ack segment. then, it replies with an ack segment and enters the established state where data can
12 on many departmental networks containing unix workstations, it was common to allow users on one of the hosts to use rlogin rfc 1258 to run commands on any of the workstations of the network without giving any password. in this case, the remote workstation “authenticated” the client host based on its ip address. this was a bad practice from a security viewpoint.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
we explained how a transport connection can be safely released. we then discussed the mechanisms that are used in tcp, the reliable transport protocol, used by most applications on the internet. most notably, we described the congestion control mechanism that has been included in tcp since the late 1980s and explained how the reliability mechanisms used by tcp have been tuned over the years.
this section is divided in two parts. the ﬁrst part contains exercises on the principles of transport protocols, including tcp. the second part contains programming challenges packet analysis tools to observe the behaviour of transport protocols.
1. consider the alternating bit protocol as described in this chapter • how does the protocol recover from the loss of a data segment ? • how does the protocol recovers from the loss of an acknowledgement ? 2. a student proposed to optimise the alternating bit protocol by adding a negative acknowledgment, i.e. the receiver sends a nak control segment when it receives a corrupted data segment. what kind of information should be placed in this control segment and how should the sender react when receiving such a nak ?
• the 16 bits or the 32 bits cyclical redundancy checks (crc) that are often used on disks, in zip archives and in datalink layer protocols. see http://docs.python.org/library/binascii.html for a python module that contains the 32 bits crc
5. checksums and crcs should not be confused with secure hash functions such as md5 deﬁned in rfc 1321 or sha-1 described in rfc 4634. secure hash functions are used to ensure that ﬁles or sometimes packets/segments have not been modiﬁed. secure hash functions aim at detecting malicious changes while checksums and crcs only detect random transmission errors. perform some experiments with hash functions such as those deﬁned in the http://docs.python.org/library/hashlib.html python hashlib module to verify that this is indeed the case.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
another utilisation of tcp options during connection establishment is to enable tcp extensions. for example, consider rfc 1323 (which is discussed in tcp reliable data transfer). rfc 1323 deﬁnes tcp extensions to support timestamps and larger windows. if the client supports rfc 1323, it adds a rfc 1323 option to its syn if the server understands this rfc 1323 option and wishes to use it, it replies with an rfc 1323 segment. option in the syn+ack segment and the extension deﬁned in rfc 1323 is used throughout the tcp connection. otherwise, if the server’s syn+ack does not contain the rfc 1323 option, the client is not allowed to use this extension and the corresponding tcp header options throughout the tcp connection. tcp’s option mechanism is ﬂexible and it allows the extension of tcp while maintaining compatibility with older implementations. the tcp options are encoded by using a type length value format where :
• the ﬁrst byte indicates the type of the option. • the second byte indicates the total length of the option (including the ﬁrst two bytes) in bytes • the last bytes are speciﬁc for each type of option
rfc 793 deﬁnes the maximum segment size (mss) tcp option that must be understood by all tcp implementations. this option (type 2) has a length of 4 bytes and contains a 16 bits word that indicates the mss supported by the sender of the syn segment. the mss option can only be used in tcp segments having the syn ﬂag set. rfc 793 also deﬁnes two special options that must be supported by all tcp implementations. the ﬁrst option is end of option. it is encoded as a single byte having value 0x00 and can be used to ensure that the tcp header extension ends on a 32 bits boundary. the no-operation option, encoded as a single byte having value 0x01, can be used when the tcp header extension contains several tcp options that should be aligned on 32 bit boundaries. all other options 14 are encoded by using the tlv format.
note: the robustness principle the handling of the tcp options by tcp implementations is one of the many applications of the robustness principle which is usually attributed to jon postel and is often quoted as “be liberal in what you accept, and conservative in what you send” rfc 1122 concerning the tcp options, the robustness principle implies that a tcp implementation should be able to accept tcp options that it does not understand, in particular in received syn segments, and that it should be able to parse any received segment without crashing, even if the segment contains an unknown tcp option. furthermore, a server should not send in the syn+ack segment or later, options that have not been proposed by the client in the syn segment.
• graceful connection release, where each tcp user can release its own direction of data transfer • abrupt connection release, where either one user closes both directions of data transfer or one tcp entity is forced to close the connection (e.g. because the remote host does not reply anymore or due to lack of resources)
the abrupt connection release mechanism is very simple and relies on a single segment having the rst bit set. a tcp segment containing the rst bit can be sent for the following reasons :
• a non-syn segment was received for a non-existing tcp connection rfc 793 • by extension, some implementations respond with an rst segment to a segment that is received on an existing connection but with an invalid header rfc 3360. this causes the corresponding connection to be closed and has caused security attacks rfc 4953
• by extension, some implementations send an rst segment when they need to close an existing tcp connection (e.g. because there are not enough resources to support this connection or because the remote host is considered to be unreachable). measurements have shown that this usage of tcp rst was widespread [aw05]
the ﬁrst rule ensures that a tcp connection used for bulk data transfer always sends full tcp segments. the second rule sends one partially ﬁlled tcp segment every round-trip-time. this algorithm, called the nagle algorithm, takes a few lines of code in all tcp implementations. these lines of code have a huge impact on the packets that are exchanged in tcp/ip networks. researchers have analysed the distribution of the packet sizes by capturing and analysing all the packets passing through a given link. these studies have shown several important results :
• in tcp/ipv4 networks, most of the bytes are exchanged in long packets, usually packets containing up to 1460 bytes of payload which is the default mss for hosts attached to an ethernet network, the most popular type of lan
the ﬁgure below provides a distribution of the packet sizes measured on a link. it shows a three-modal distribution of the packet size. 50% of the packets contain pure tcp acknowledgements and occupy 40 bytes. about 20% of the packets contain about 500 bytes 18 of user data and 12% of the packets contain 1460 bytes of user data. however, most of the user data is transported in large packets. this packet size distribution has implications on the design of routers as we discuss in the next chapter.
recent measurements indicate that these packet size distributions are still valid in today’s internet, although the packet distribution tends to become bimodal with small packets corresponding to tcp pure acks (40-64 bytes depending on the utilisation of tcp options) and large 1460-bytes packets carrying most of the user data.
from a performance point of view, one of the main limitations of the original tcp speciﬁcation is the 16 bits window ﬁeld in the tcp header. as this ﬁeld indicates the current size of the receive window in bytes, it limits the tcp receive window at 65535 bytes. this limitation was not a severe problem when tcp was designed since at that time high-speed wide area networks offered a maximum bandwidth of 56 kbps. however, in today’s network, this limitation is not acceptable anymore. the table below provides the rough 19 maximum throughput that can be achieved by a tcp connection with a 64 kbytes window in function of the connection’s round-trip-time
to solve this problem, a backward compatible extension that allows tcp to use larger receive windows was proposed in rfc 1323. today, most tcp implementations support this option. the basic idea is that instead of
18 when these measurements were taken, some hosts had a default mss of 552 bytes (e.g. bsd unix derivatives) or 536 bytes (the default mss speciﬁed in rfc 793). today, most tcp implementation derive the mss from the maximum packet size of the lan interface they use (ethernet in most cases).
however, when a data segment is lost, as illustrated in the bottom part of the ﬁgure, the measurement is ambiguous as the sender cannot determine whether the received acknowledgement was triggered by the ﬁrst transmission of segment 123 or its retransmission. using incorrect round-trip-time estimations could lead to incorrect values of the retransmission timeout. for this reason, phil karn and craig partridge proposed, in [kp91], to ignore the round-trip-time measurements performed during retransmissions. to avoid this ambiguity in the estimation of the round-trip-time when segments are retransmitted, recent tcp implementations rely on the timestamp option deﬁned in rfc 1323. this option allows a tcp sender to place two 32 bit timestamps in each tcp segment that it sends. the ﬁrst timestamp, ts value (tsval) is chosen by the sender of the segment. it could for example be the current value of its real-time clock 22. the second value, ts echo reply (tsecr), is the last tsval that was received from the remote host and stored in the tcb. the ﬁgure below shows how the utilization of this timestamp option allows for the disambiguation of the round-trip-time measurement when there are retransmissions.
once the round-trip-time measurements have been collected for a given tcp connection, the tcp entity must compute the retransmission timeout. as the round-trip-time measurements may change during the lifetime of a connection, the retransmission timeout may also change. at the beginning of a connection 23 , the tcp entity that sends a syn segment does not know the round-trip-time to reach the remote host and the initial retransmission timeout is usually set to 3 seconds rfc 2988. the original tcp speciﬁcation proposed in rfc 793 to include two additional variables in the tcb :
• srtt : the smoothed round-trip-time computed as srrt = (α × srtt) + ((1 − α) × rtt) where rtt is the round-trip-time measured according to the above procedure and α a smoothing factor (e.g. 0.8 or 0.9)
23 as a tcp client often establishes several parallel or successive connections with the same server, rfc 2140 has proposed to reuse for a new connection some information that was collected in the tcb of a previous connection, such as the measured rtt. however, this solution has not been widely implemented.
negotiated during the establishment of a tcp connection. if both tcp hosts support the option, sack blocks can be attached by the receiver to the segments that it sends. sack blocks allow a tcp receiver to indicate the blocks of data that it has received correctly but out of sequence. the ﬁgure below illustrates the utilisation of the sack blocks.
an sack option contains one or more blocks. a block corresponds to all the sequence numbers between the left edge and the right edge of the block. the two edges of the block are encoded as 32 bit numbers (the same size as the tcp sequence number) in an sack option. as the sack option contains one byte to encode its type and one byte for its length, a sack option containing b blocks is encoded as a sequence of 2 + 8 × b bytes. in practice, the size of the sack option can be problematic as the optional tcp header extension cannot be longer than 44 bytes. as the sack option is usually combined with the rfc 1323 timestamp extension, this implies that a tcp segment cannot usually contain more than three sack blocks. this limitation implies that a tcp receiver cannot always place in the sack option that it sends, information about all the received blocks. to deal with the limited size of the sack option, a tcp receiver currently having more than 3 blocks inside its receiving buffer must select the blocks to place in the sack option. a good heuristic is to put in the sack option the blocks that have most recently changed, as the sender is likely to be already aware of the older blocks. when a sender receives an sack option indicating a new block and thus a new possible segment loss, it usually does not retransmit the missing segment(s immediately. to deal with reordering, a tcp sender can use a heuristic similar to fast retransmit by retransmitting a gap only once it has received three sack options indicating this gap. it should be noted that the sack option does not supersede the acknowledgement number of the tcp header. a tcp sender can only remove data from its sending buffer once they have been acknowledged by tcp’s cumulative acknowledgements. this design was chosen for two reasons. first, it allows the receiver to discard parts of its receiving buffer when it is running out of memory without loosing data. second, as the sack option is not transmitted reliably, the cumulative acknowledgements are still required to deal with losses of ack segments carrying only sack information. thus, the sack option only serves as a hint to allow the sender to optimise its retransmissions.
in the previous sections, we have explained the mechanisms that tcp uses to deal with transmission errors and segment losses. in a heterogeneous network such as the internet or enterprise ip networks, endsystems have very different levels of performance. some endsystems are high-end servers attached to 10 gbps links while others are mobile devices attached to a very low bandwidth wireless link. despite these huge differences in performance, a mobile device should be able to efﬁciently exchange segments with a high-end server. to understand this problem better, let us consider the scenario shown in the ﬁgure below, where a server (a)
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
17. consider a go-back-n sender and a go-back receiver that are directly connected with a 10 mbps link that has a propagation delay of 100 milliseconds. assume that the retransmission timer is set to three seconds. if the window has a length of 4 segments, draw a time-sequence diagram showing the transmission of 10 segments (each segment contains 10000 bits):
• when there are no losses • when the third and seventh segments are lost • when the second, fourth, sixth, eighth, ... acknowledgements are lost • when the third and fourth data segments are reordered (i.e. the fourth arrives before the third)
19. consider two high-end servers connected back-to-back by using a 10 gbps interface. if the delay between the two servers is one millisecond, what is the throughput that can be achieved by a transport protocol that is using 10,000 bits segments and a window of
20. consider two servers are directly connected by using a b bits per second link with a round-trip-time of r seconds. the two servers are using a transport protocol that sends segments containing s bytes and acknowledgements composed of a bytes. can you derive a formula that computes the smallest window (measured in segments) that is required to ensure that the servers will be able to completely utilise the link ?
21. same question as above if the two servers are connected through an asymmetrical link that transmits bu bits per second in the direction used to send data segments and bd bits per second in the direction used to send acknowledgements.
22. the trivial file transfer protocol is a very simple ﬁle transfer protocol that is often used by disk-less hosts when booting from a server. read the tftp speciﬁcation in rfc 1350 and explain how tftp recovers from transmission errors and losses.
23. is it possible for a go-back-n receiver to inter-operate with a selective-repeat sender ? justify your answer. 24. is it possible for a selective-repeat receiver to inter-operate with a go-back-n sender ? justify your answer. 25. the go-back-n and selective repeat mechanisms that are described in the book exclusively rely on cumulative acknowledgements. this implies that a receiver always returns to the sender information about the last segment that was received in-sequence. if there are frequent losses or reordering, a selective repeat receiver could return several times the same cumulative acknowledgment. can you think of other types of acknowledgements that could be used by a selective repeat receiver to provide additional information about the out-of-sequence segments that it has received. design such acknowledgements and explain how the sender should react upon reception of this information.
26. the goodput achieved by a transport protocol is usually deﬁned as the number of application layer bytes that are exchanged per unit of time. what are the factors that can inﬂuence the goodput achieved by a given transport protocol ?
27. when used with ipv4, transmission control protocol (tcp) attaches 40 bytes of control information to each segment sent. assuming an inﬁnite window and no losses nor transmission errors, derive a formula that computes the maximum tcp goodput in function of the size of the segments that are sent.
29. consider the following situation. a go-back-n receiver has sent a full window of data segments. all the segments have been received correctly and in-order by the receiver, but all the returned acknowledgements have been lost. show by using a time sequence diagram (e.g. by considering a window of four segments) what happens in this case. can you ﬁx the problem on the go-back-n sender ?
subnet 130.100.0.0/16 130.101.0.0/16 university of akron, usa 130.102.0.0/16 130.103.0.0/16 130.104.0.0/16 universite catholique de louvain, belgium 130.105.0.0/16 open software foundation, usa
however, the internet was a victim of its own success and in the late 1980s, many organisations were requesting blocks of ipv4 addresses and started connecting to the internet. most of these organisations requested class b address blocks, as class a address blocks were too large and in limited supply while class c address blocks were considered to be too small. unfortunately, there were only 16,384 different class b address blocks and this address space was being consumed quickly. as a consequence, the routing tables maintained by the routers were growing quickly and some routers had difﬁculties maintaining all these routes in their limited memory 5.
faced with these two problems, the internet engineering task force decided to develop the classless interdomain routing (cidr) architecture rfc 1518. this architecture aims at allowing ip routing to scale better than the class-based architecture. cidr contains three important modiﬁcations compared to rfc 791.
1. ip address classes are deprecated. all ip equipment must use and support variable-length subnets. 2. ip address blocks are no longer allocated on a ﬁrst-come-ﬁrst-served basis. instead, cidr introduces a
the last two modiﬁcations were introduced to improve the scalability of the ip routing system. the main drawback of the ﬁrst-come-ﬁrst-served address block allocation scheme was that neighbouring address blocks were allocated to very different organisations and conversely, very different address blocks were allocated to similar organisations. with cidr, address blocks are allocated by regional ip registries (rir) in an aggregatable manner. a rir is responsible for a large block of addresses and a region. for example, ripe is the rir that is responsible for europe. a rir allocates smaller address blocks from its large block to internet service providers rfc 2050. internet service providers then allocate smaller address blocks to their customers. when an organisation requests an address block, it must prove that it already has or expects to have in the near future, a number of hosts or customers that is equivalent to the size of the requested address block. the main advantage of this hierarchical address block allocation scheme is that it allows the routers to maintain fewer routes. for example, consider the address blocks that were allocated to some of the belgian universities as shown in the table below.
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
however, these three classes of addresses were not ﬂexible enough. a class a subnet was too large for most organisations and a class c subnet was too small. flexibility was added by the introduction of variable-length subnets in rfc 1519. with variable-length subnets, the subnet identiﬁer can be any size, from 1 to 31 bits. variable-length subnets allow the network operators to use a subnet that better matches the number of hosts that are placed inside the subnet. a subnet identiﬁer or ipv4 preﬁx is usually 3 represented as a.b.c.d/p where a.b.c.d is the network address obtained by concatenating the subnet identiﬁer with a host identiﬁer containing only 0 and p is the length of the subnet identiﬁer in bits. the table below provides examples of ip subnets.
the ﬁgure below provides a simple example of the utilisation of ipv4 subnets in an enterprise network. the length of the subnet identiﬁer assigned to a lan usually depends on the expected number of hosts attached to the lan. for point-to-point links, many deployments have used /30 preﬁxes, but recent routers are now using /31 subnets on point-to-point links rfc 3021 or do not even use ipv4 addresses on such links 4.
a second issue concerning the addresses of the network layer is the allocation scheme that is used to allocate blocks of addresses to organisations. the ﬁrst allocation scheme was based on the different classes of addresses. the pool of ipv4 addresses was managed by a secretariat who allocated address blocks on a ﬁrst-come ﬁrst served basis. large organisations such as ibm, bbn, as well as stanford or the mit were able to obtain a class a address block. most organisations requested a class b address block containing 65536 addresses, which was suitable for most enterprises and universities. the table below provides examples of some ipv4 address blocks in the class b space.
3 another way of representing ip subnets is to use netmasks. a netmask is a 32 bits ﬁeld whose p high order bits are set to 1 and the low order bits are set to 0. the number of high order bits set 1 indicates the length of the subnet identiﬁer. netmasks are usually represented in the same dotted decimal format as ipv4 addresses. for example 10.0.0.0/8 would be represented as 10.0.0.0 255.0.0.0 while 192.168.1.0/24 would be represented as 192.168.1.0 255.255.255.0. in some cases, the netmask can be represented in hexadecimal.
organisation universite catholique de louvain katholiek universiteit leuven facultes universitaires notre-dame de la paix universite de liege universite libre de bruxelles
these universities are all connected to the internet exclusively via belnet. as each university has been allocated a different address block, the routers of belnet must announce one route for each university and all routers on the internet must maintain a route towards each university. in contrast, consider all the high schools and the government institutions that are connected to the internet via belnet. an address block was assigned to these institutions after the introduction of cidr in the 193.190.0.0/15 address block owned by belnet. with cidr, belnet can announce a single route towards 193.190.0.0/15 that covers all of these high schools. however, there is one difﬁculty with the aggregatable variable length subnets used by cidr. consider for example fedict, a government institution that uses the 193.191.244.0/23 address block. assume that in addition to being connected to the internet via belnet , fedict also wants to be connected to another internet service provider. the fedict network is then said to be multihomed. this is shown in the ﬁgure below.
with such a multihomed network, routers r1 and r2 would have two routes towards ipv4 address 193.191.245.88 : one route via belnet (193.190.0.0/15) and one direct route (193.191.244.0/23). both routes match ipv4 address 193.192.145.88. since rfc 1519 when a router knows several routes towards the same destination address, it must forward packets along the route having the longest preﬁx length. in the case of 193.191.245.88, this is the route 193.191.244.0/23 that is used to forward the packet. this forwarding rule is called the longest preﬁx match or the more speciﬁc match. all ipv4 routers implement this forwarding rule. to understand the longest preﬁx match forwarding, consider the ﬁgure below. with this rule, the route 0.0.0.0/0 plays a particular role. as this route has a preﬁx length of 0 bits, it matches all destination addresses. this route is often called the default route.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
the last transmission mode is the anycast transmission mode. in this transmission mode, a set of receivers is identiﬁed. when a source sends information towards this set of receivers, the network ensures that the information is delivered to one receiver that belongs to this set. usually, the receiver closest to the source is the one that receives the information sent by this particular source. the anycast transmission mode is useful to ensure redundancy, as when one of the receivers fails, the network will ensure that information will be delivered to another receiver belonging to the same group. however, in practice supporting the anycast transmission mode can be difﬁcult.
in the example above, the three hosts marked with * are part of the same anycast group. when host s sends information to this anycast group, the network ensures that it will reach one of the members of the anycast group. the dashed lines show a possible delivery via nodes 1, 2 and 4. a subsequent anycast transmission from host s to the same anycast group could reach the host attached to intermediate node 3 as shown by the plain line. an anycast transmission reaches a member of the anycast group that is chosen by the network in function of the current network conditions.
an important aspect to understand before studying computer networks is the difference between a service and a protocol. in order to understand the difference between the two, it is useful to start with real world examples. the traditional post provides a service where a postman delivers letters to recipients. the post deﬁnes precisely which types of letters (size, weight, etc) can be delivered by using the standard mail service. furthermore, the format of the envelope is speciﬁed (position of the sender and recipient addresses, position of the stamp). someone who wants to send a letter must either place the letter at a post ofﬁce or inside one of the dedicated mailboxes. the letter will then be collected and delivered to its ﬁnal recipient. note that for the regular service the post usually does not guarantee the delivery of each particular letter, some letters may be lost, and some letters are delivered to the wrong mailbox. if a letter is important, then the sender can use the registered service to ensure that the letter will be delivered to its recipient. some post services also provide an acknowledged service or an express mail service that is faster than the regular service. in computer networks, the notion of service is more formally deﬁned in [x200] . it can be better understood by considering a computer network, whatever its size or complexity, as a black box that provides a service to users , as shown in the ﬁgure below. these users could be human users or processes running on a computer system. many users can be attached to the same service provider. through this provider, each user must be able to exchange messages with any other user. to be able to deliver these messages, the service provider must be able to unambiguously identify each user. in computer networks, each user is identiﬁed by a unique address, we will discuss later how these addresses are built and used. at this point, and when considering unicast transmission, the main characteristic of these addresses is that they are unique. two different users attached to the network cannot use the same address.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
2 minutes, this implies that the maximum bandwidth to a given destination is limited to roughly 286 mbps. with a more realistic 1500 bytes mtu, that bandwidth drops to 6.4 mbps rfc 4963 if fragmentation must be possible 17. this is very low and is another reason why hosts are highly encouraged to avoid fragmentation. if; despite all of this, the mtu of the outgoing interface is smaller than the packet’s length, the packet is fragmented. finally, the packet’s checksum is computed before transmission. when a host receives an ipv4 packet destined to itself, there are several operations that it must perform. first, it must check the packet’s checksum. if the checksum is incorrect, the packet is discarded. then, it must check whether the packet has been fragmented. if yes, the packet is passed to the reassembly algorithm described earlier. otherwise, the packet must be passed to the upper layer. this is done by looking at the protocol ﬁeld (6 for tcp, 17 for udp). if the host does not implement the transport layer protocol corresponding to the received protocol ﬁeld, it sends a protocol unreachable icmp message to the sending host. if the received packet contains an icmp message (protocol ﬁeld set to 1), the processing is more complex. an echo-request icmp message triggers the transmission of an icmp echo-reply message. the other types of icmp messages indicate an error that was caused by a previously transmitted packet. these icmp messages are usually forwarded to the transport protocol that sent the erroneous packet. this can be done by inspecting the contents of the icmp message that includes the header and the ﬁrst 64 bits of the erroneous packet. if the ip packet did not contain options, which is the case for most ipv4 packets, the transport protocol can ﬁnd in the ﬁrst 32 bits of the transport header the source and destination ports to determine the affected transport ﬂow. this is important for path mtu discovery for example. when a router receives an ipv4 packet, it must ﬁrst check the packet’s checksum. if the checksum is invalid, it is discarded. otherwise, the router must check whether the destination address is one of the ipv4 addresses assigned to the router. if so, the router must behave as a host and process the packet as described above. although routers mainly forward ipv4 packets, they sometimes need to be accessed as hosts by network operators or network management software. if the packet is not addressed to the router, it must be forwarded on an outgoing interface according to the router’s routing table. the router ﬁrst decrements the packet’s ttl. if the ttl reaches 0, a ttl exceeded icmp message is sent back to the source. as the packet header has been modiﬁed, the checksum must be recomputed. fortunately, as ipv4 uses an arithmetic checksum, a router can incrementally update the packet’s checksum as described in rfc 1624. then, the router performs a longest preﬁx match for the packet’s destination address in its forwarding if no match is found, the router must return a destination unreachable icmp message to the source. table. otherwise, the lookup returns the interface over which the packet must be forwarded. before forwarding the packet over this interface, the router must ﬁrst compare the length of the packet with the mtu of the outgoing interface. if the packet is smaller than the mtu, it is forwarded. otherwise, a fragmentation needed icmp message is sent if the df ﬂag was sent or the packet is fragmented if the df was not set.
note: longest preﬁx match in ip routers performing the longest preﬁx match at line rate on routers requires highly tuned data structures and algorithms. consider for example an implementation of the longest match based on a radix tree on a router with a 10 gbps link. on such a link, a router can receive 31,250,000 40 bytes ipv4 packets every second. to forward the packets at line rate, the router must process one ipv4 packet every 32 nanoseconds. this cannot be achieved by a software implementation. for a hardware implementation, the main difﬁculty lies in the number of memory accesses that are necessary to perform the longest preﬁx match. 32 nanoseconds is very small compared to the memory accesses that are required by a naive longest preﬁx match implement. additional information about faster longest preﬁx match algorithms may be found in [varghese2005].
in the late 1980s and early 1990s the growth of the internet was causing several operational problems on routers. many of these routers had a single cpu and up to 1 mbyte of ram to store their operating system, packet buffers and routing tables. given the rate of allocation of ipv4 preﬁxes to companies and universities willing to join the internet, the routing tables where growing very quickly and some feared that all ipv4 preﬁxes would quickly be allocated. in 1987, a study cited in rfc 1752, estimated that there would be 100,000 networks in the near future. in august 1990, estimates indicated that the class b space would be exhausted by march 1994. two types of
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
the transport layer enables the applications to efﬁciently and reliably exchange data. transport layer entities expect to be able to send segment to any destination without having to understand anything about the underlying subnetwork technologies. many subnetwork technologies exist. most of them differ in subtle details (frame size, addressing, ...). the network layer is the glue between these subnetworks and the transport layer. it hides to the transport layer all the complexity of the underlying subnetworks and ensures that information can be exchanged between hosts connected to different types of subnetworks. in this chapter, we ﬁrst explain the principles of the network layer. these principles include the datagram and virtual circuit modes, the separation between the data plane and the control plane and the algorithms used by routing protocols. then, we explain, in more detail, the network layer in the internet, starting with ipv4 and ipv6 and then moving to the routing protocols (rip, ospf and bgp).
the main objective of the network layer is to allow endsystems, connected to different networks, to exchange information through intermediate systems called router. the unit of information in the network layer is called a packet.
before explaining the network layer in detail, it is useful to begin by analysing the service provided by the datalink layer. there are many variants of the datalink layer. some provide a connection-oriented service while others provide a connectionless service. in this section, we focus on connectionless datalink layer services as they are the most widely used. using a connection-oriented datalink layer causes some problems that are beyond the scope of this chapter. see rfc 3819 for a discussion on this topic. there are three main types of datalink layers. the simplest datalink layer is when there are only two communicating systems that are directly connected through the physical layer. such a datalink layer is used when there is a point-to-point link between the two communicating systems. the two systems can be endsystems or routers. ppp (point-to-point protocol), deﬁned in rfc 1661, is an example of such a point-to-point datalink layer. datalink layers exchange frames and a datalink frame sent by a datalink layer entity on the left is transmitted through the physical layer, so that it can reach the datalink layer entity on the right. point-to-point datalink layers can either
as mentioned in the ﬁrst section of this chapter, there are three main types of datalink layers : point-to-point links, lans supporting broadcast and multicast and nbma networks. there are two important issues to be addressed when using ipv4 in these types of networks. the ﬁrst issue is how an ipv4 device obtains its ipv4 address. the second issue is how ipv4 packets are exchanged over the datalink layer service. on a point-to-point link, the ipv4 addresses of the communicating devices can be conﬁgured manually or by using a simple protocol. ipv4 addresses are often conﬁgured manually on point-to-point links between routers. when point-to-point links are used to attach hosts to the network, automatic conﬁguration is often preferred in order to avoid problems with incorrect ipv4 addresses. for example, the ppp, speciﬁed in rfc 1661, includes an ip network control protocol that can be used by the router in the ﬁgure below to send the ipv4 address that the attached host must conﬁgure for its interface. the transmission of ipv4 packets on a point-to-point link will be discussed in chapter chap:lan.
using ipv4 in a lan introduces an additional problem. on a lan, each device is identiﬁed by its unique datalink layer address. the datalink layer service can be used by any host attached to the lan to send a frame to any other host attached to the same lan. for this, the sending host must know the datalink layer address of the destination host. for example, the ﬁgure below shows four hosts attached to the same lan conﬁgured with ipv4 addresses in the 10.0.1.0/24 subnet and datalink layer addresses represented as a single character 12. in this network, if host 10.0.1.22/24 wants to send an ipv4 packet to the host having address 10.0.1.8, it must know that the datalink layer address of this host is c.
in a simple network such as the one shown above, it could be possible to manually conﬁgure the mapping between the ipv4 addresses of the hosts and the corresponding datalink layer addresses. however, in a larger lan this is impossible. to ease the utilisation of lans, ipv4 hosts must be able to automatically obtain the datalink layer address corresponding to any ipv4 address on the same lan. this is the objective of the address resolution protocol (arp) deﬁned in rfc 826. arp is a datalink layer protocol that is used by ipv4. it relies on the ability of the datalink layer service to easily deliver a broadcast frame to all devices attached to the same lan.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
among these addresses, some are well known. for example, all endsystem automatically belong to the ff02::1 multicast group while all routers automatically belong to the ff02::2 multicast group. we discuss ipv6 multicast later.
the ipv6 packet format was heavily inspired by the packet format proposed for the sipp protocol in rfc 1710. the standard ipv6 header deﬁned in rfc 2460 occupies 40 bytes and contains 8 different ﬁelds, as shown in the ﬁgure below.
• version : a 4 bits ﬁeld set to 6 and intended to allow ip to evolve in the future if needed • trafﬁc class : this 8 bits ﬁeld plays a similar role as the ds byte in the ipv4 header • flow label : this ﬁeld was initially intended to be used to tag packets belonging to the same ﬂow. however,
• next header : this 8 bits ﬁeld indicates the type 19 of header that follows the ipv6 header. it can be a transport layer header (e.g. 6 for tcp or 17 for udp) or an ipv6 option. handling options as a next header allows simplifying the processing of ipv6 packets compared to ipv4.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
share information on the web. they were also extended by other developers who contributed to new features. for example, ncsa added support for images in their mosaic browser that was eventually used to create netscape communications.
the ﬁrst components of the world wide web are the uniform resource identiﬁers (uri), deﬁned in rfc 3986. a uri is a character string that unambiguously identiﬁes a resource on the world wide web. here is a subset of the bnf for uris
= scheme ":" "//" authority path [ "?" query ] [ "#" fragment ] = alpha *( alpha / digit / "+" / "-" / "." ) = [ userinfo "@" ] host [ ":" port ] = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" )
= unreserved / pct-encoded / sub-delims / ":" / "@" = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" ) = "%" hexdig hexdig = alpha / digit / "-" / "." / "_" / "~" = gen-delims / sub-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@" = "!" / "$" / "&" / "’" / "(" / ")" / "*" / "+" / "," / ";" / "="
the ﬁrst component of a uri is its scheme. a scheme can be seen as a selector, indicating the meaning of the ﬁelds after it. in practice, the scheme often identiﬁes the application-layer protocol that must be used by the client to retrieve the document, but it is not always the case. some schemes do not imply a protocol at all and some do not indicate a retrievable document 17. the most frequent scheme is http that will be described later. a uri scheme can be deﬁned for almost any application layer protocol [#furilist]_. the characters ‘: and // follow the scheme of any uri. the second part of the uri is the authority. with retrievable uri, this includes the dns name or the ip address of the server where the document can be retrieved using the protocol speciﬁed via the scheme. this name can be preceded by some information about the user (e.g. a user name) who is requesting the information. earlier deﬁnitions of the uri allowed the speciﬁcation of a user name and a password before the @ character ( rfc 1738), but this is now deprecated as placing a password inside a uri is insecure. the host name can be followed by the semicolon character and a port number. a default port number is deﬁned for some protocols and the port number should only be included in the uri if a non-default port number is used (for other protocols, techniques like service dns records are used). the third part of the uri is the path to the document. this path is structured as ﬁlenames on a unix host (but it does not imply that the ﬁles are indeed stored this way on the server). if the path is not speciﬁed, the server will return a default document. the last two optional parts of the uri are used to provide a query and indicate a speciﬁc part (e.g. a section in an article) of the requested document. sample uris are shown below.
http://tools.ietf.org/html/rfc3986.html mailto:infobot@example.com?subject=current-issue http://docs.python.org/library/basehttpserver.html?highlight=http#basehttpserver.basehttprequesthandler telnet://[2001:6a8:3080:3::2]:80/ ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
the ﬁrst uri corresponds to a document named rfc3986.html that is stored on the server named tools.ietf.org and can be accessed by using the http protocol on its default port. the second uri corresponds to an email message, with subject current-issue, that will be sent to user infobot in domain example.com. the mailto: uri scheme is deﬁned in rfc 6068. the third uri references the portion basehttpserver.basehttprequesthandler of the document basehttpserver.html that is stored in the library directory on server docs.python.org. this document can be retrieved by using the http protocol. the query highlight=http is associated to this uri. the fourth example is a server that operates the telnet protocol, uses ipv6 address 2001:6a8:3080:3::2 and is reachable on port 80. the last uri is somewhat special. most users will assume that it corresponds to a document stored on the cnn.example.com
17 an example of a non-retrievable uri is urn:isbn:0-380-81593-1 which is an unique identiﬁer for a book, through the urn scheme (see rfc 3187). of course, any uri can be make retrievable via a dedicated server or a new protocol but this one has no explicit protocol. same thing for the scheme tag (see rfc 4151), often used in web syndication (see rfc 4287 about the atom syndication format). even when the scheme is retrievable (for instance with http‘), it is often used only as an identiﬁer, not as a way to get a resource. see http://norman.walsh.name/2006/07/25/namesandaddresses for a good explanation.
the server replies with the requested style sheet and maintains the persistent connection. note that the server only accepts 99 remaining http requests over this persistent connection.
http/1.1 200 ok date: fri, 19 mar 2010 09:23:37 gmt server: apache/2.0.63 (freebsd) php/5.2.12 with suhosin-patch last-modified: mon, 10 apr 2006 05:06:39 gmt content-length: 2235 keep-alive: timeout=15, max=99 connection: keep-alive content-type: text/css
then the client automatically requests the web server’s icon 18 , that could be displayed by the browser. this server does not contain such uri and thus replies with a 404 http status. however, the underlying tcp connection is not closed immediately.
get /favicon.ico http/1.1 host: www.kame.net referer: http://www.kame.net/ user-agent: mozilla/5.0 (macintosh; u; intel mac os x 10_6_2; en-us) connection: keep-alive
http/1.1 404 not found date: fri, 19 mar 2010 09:23:40 gmt server: apache/2.0.63 (freebsd) php/5.2.12 with suhosin-patch content-length: 318 keep-alive: timeout=15, max=98 connection: keep-alive content-type: text/html; charset=iso-8859-1
as illustrated above, a client can send several http requests over the same persistent tcp connection. however, it is important to note that all of these http requests are considered to be independent by the server. each http request must be self-contained. this implies that each request must include all the header lines that are required by the server to understand the request. the independence of these requests is one of the important design choices of http. as a consequence of this design choice, when a server processes a http request, it doesn’t’ use any other information than what is contained in the request itself. this explains why the client adds its user-agent: header in all of the http requests it sends over the persistent tcp connection. however, in practice, some servers want to provide content tuned for each user. for example, some servers can provide information in several languages or other servers want to provide advertisements that are targeted to different types of users. to do this, servers need to maintain some information about the preferences of each user and use this information to produce content matching the user’s preferences. http contains several mechanisms that enable to solve this problem. we discuss three of them below. a ﬁrst solution is to force the users to be authenticated. this was the solution used by ftp to control the ﬁles that each user could access. initially, user names and passwords could be included inside uris rfc 1738. however, placing passwords in the clear in a potentially publicly visible uri is completely insecure and this usage has now been deprecated rfc 3986. http supports several extension headers rfc 2617 that can be used by a server to request the authentication of the client by providing his/her credentials. however, user names and passwords have not been popular on web servers as they force human users to remember one user name and one password per server. remembering a password is acceptable when a user needs to access protected content, but users will not accept the need for a user name and password only to receive targeted advertisements from the web sites that they visit. a second solution to allow servers to tune that content to the needs and capabilities of the user is to rely on the different types of accept-* http headers. for example, the accept-language: can be used by the client to
18 favorite icons are small icons that are used to represent web servers in the toolbar of internet browsers. microsoft added this feature in their browsers without taking into account the w3c standards. see http://www.w3.org/2005/10/howto-favicon for a discussion on how to cleanly support such favorite icons.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
2 minutes, this implies that the maximum bandwidth to a given destination is limited to roughly 286 mbps. with a more realistic 1500 bytes mtu, that bandwidth drops to 6.4 mbps rfc 4963 if fragmentation must be possible 17. this is very low and is another reason why hosts are highly encouraged to avoid fragmentation. if; despite all of this, the mtu of the outgoing interface is smaller than the packet’s length, the packet is fragmented. finally, the packet’s checksum is computed before transmission. when a host receives an ipv4 packet destined to itself, there are several operations that it must perform. first, it must check the packet’s checksum. if the checksum is incorrect, the packet is discarded. then, it must check whether the packet has been fragmented. if yes, the packet is passed to the reassembly algorithm described earlier. otherwise, the packet must be passed to the upper layer. this is done by looking at the protocol ﬁeld (6 for tcp, 17 for udp). if the host does not implement the transport layer protocol corresponding to the received protocol ﬁeld, it sends a protocol unreachable icmp message to the sending host. if the received packet contains an icmp message (protocol ﬁeld set to 1), the processing is more complex. an echo-request icmp message triggers the transmission of an icmp echo-reply message. the other types of icmp messages indicate an error that was caused by a previously transmitted packet. these icmp messages are usually forwarded to the transport protocol that sent the erroneous packet. this can be done by inspecting the contents of the icmp message that includes the header and the ﬁrst 64 bits of the erroneous packet. if the ip packet did not contain options, which is the case for most ipv4 packets, the transport protocol can ﬁnd in the ﬁrst 32 bits of the transport header the source and destination ports to determine the affected transport ﬂow. this is important for path mtu discovery for example. when a router receives an ipv4 packet, it must ﬁrst check the packet’s checksum. if the checksum is invalid, it is discarded. otherwise, the router must check whether the destination address is one of the ipv4 addresses assigned to the router. if so, the router must behave as a host and process the packet as described above. although routers mainly forward ipv4 packets, they sometimes need to be accessed as hosts by network operators or network management software. if the packet is not addressed to the router, it must be forwarded on an outgoing interface according to the router’s routing table. the router ﬁrst decrements the packet’s ttl. if the ttl reaches 0, a ttl exceeded icmp message is sent back to the source. as the packet header has been modiﬁed, the checksum must be recomputed. fortunately, as ipv4 uses an arithmetic checksum, a router can incrementally update the packet’s checksum as described in rfc 1624. then, the router performs a longest preﬁx match for the packet’s destination address in its forwarding if no match is found, the router must return a destination unreachable icmp message to the source. table. otherwise, the lookup returns the interface over which the packet must be forwarded. before forwarding the packet over this interface, the router must ﬁrst compare the length of the packet with the mtu of the outgoing interface. if the packet is smaller than the mtu, it is forwarded. otherwise, a fragmentation needed icmp message is sent if the df ﬂag was sent or the packet is fragmented if the df was not set.
note: longest preﬁx match in ip routers performing the longest preﬁx match at line rate on routers requires highly tuned data structures and algorithms. consider for example an implementation of the longest match based on a radix tree on a router with a 10 gbps link. on such a link, a router can receive 31,250,000 40 bytes ipv4 packets every second. to forward the packets at line rate, the router must process one ipv4 packet every 32 nanoseconds. this cannot be achieved by a software implementation. for a hardware implementation, the main difﬁculty lies in the number of memory accesses that are necessary to perform the longest preﬁx match. 32 nanoseconds is very small compared to the memory accesses that are required by a naive longest preﬁx match implement. additional information about faster longest preﬁx match algorithms may be found in [varghese2005].
in the late 1980s and early 1990s the growth of the internet was causing several operational problems on routers. many of these routers had a single cpu and up to 1 mbyte of ram to store their operating system, packet buffers and routing tables. given the rate of allocation of ipv4 preﬁxes to companies and universities willing to join the internet, the routing tables where growing very quickly and some feared that all ipv4 preﬁxes would quickly be allocated. in 1987, a study cited in rfc 1752, estimated that there would be 100,000 networks in the near future. in august 1990, estimates indicated that the class b space would be exhausted by march 1994. two types of
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
tcp uses the segment losses as an indication of congestion. when there are no losses, the network is assumed to be not congested. this implies that congestion is the main cause of packet losses. this is true in wired networks, but unfortunately not always true in wireless networks. another solution is to rely on explicit feedback. this is the solution proposed in the decbit congestion control scheme [rj1995] and used in frame relay and atm networks. this explicit feedback can be implemented in two ways. a ﬁrst solution would be to deﬁne a special message that could be sent by routers to hosts when they are congested. unfortunately, generating such messages may increase the amount of congestion in the network. such a congestion indication packet is thus discouraged rfc 1812. a better approach is to allow the intermediate routers to indicate, in the packets that they forward, their current congestion status. binary feedback can be encoded by using one bit in the packet header. with such a scheme, congested routers set a special bit in the packets that they forward while non-congested routers leave this bit unmodiﬁed. the destination host returns the congestion status of the network in the acknowledgements that it sends. details about such a solution in ip networks may be found in rfc 3168. unfortunately, as of this writing, this solution is still not deployed despite its potential beneﬁts.
the tcp congestion control scheme was initially proposed by van jacobson in [jacobson1988]. the current speciﬁcation may be found in rfc 5681. tcp relies on additive increase and multiplicative decrease (aimd). to implement aimd, a tcp host must be able to control its transmission rate. a ﬁrst approach would be to use timers and adjust their expiration times in function of the rate imposed by aimd. unfortunately, maintaining such timers for a large number of tcp connections can be difﬁcult. instead, van jacobson noted that the rate of tcp congestion can be artiﬁcially controlled by constraining its sending window. a tcp connection cannot send data rtt where window is the maximum between the host’s sending window and the window advertised faster than window by the receiver. tcp’s congestion control scheme is based on a congestion window. the current value of the congestion window (cwnd) is stored in the tcb of each tcp connection and the window that can be used by the sender is constrained by min(cwnd, rwin, swin) where swin is the current sending window and rwin the last received receive window. the additive increase part of the tcp congestion control increments the congestion window by mss bytes every round-trip-time. in the tcp literature, this phase is often called the congestion avoidance phase. the multiplicative decrease part of the tcp congestion control divides the current value of the congestion window once congestion has been detected. when a tcp connection begins, the sending host does not know whether the part of the network that it uses to reach the destination is congested or not. to avoid causing too much congestion, it must start with a small congestion window. [jacobson1988] recommends an initial window of mss bytes. as the additive increase part of the tcp congestion control scheme increments the congestion window by mss bytes every round-trip-time, the tcp connection may have to wait many round-trip-times before being able to efﬁciently use the available bandwidth. this is especially important in environments where the bandwidth × rtt product is high. to avoid waiting too many round-trip-times before reaching a congestion window that is large enough to efﬁciently utilise the network, the tcp congestion control scheme includes the slow-start algorithm. the objective of the tcp slow-start is to quickly reach an acceptable value for the cwnd. during slow-start, the congestion window is doubled every round-trip-time. the slow-start algorithm uses an additional variable in the tcb : sshtresh (slowstart threshold). the ssthresh is an estimation of the last value of the cwnd that did not cause congestion. it is initialised at the sending window and is updated after each congestion event. in practice, a tcp implementation considers the network to be congested once its needs to retransmit a segment. the tcp congestion control scheme distinguishes between two types of congestion :
• mild congestion. tcp considers that the network is lightly congested if it receives three duplicate acknowledgements and performs a fast retransmit. if the fast retransmit is successful, this implies that only one segment has been lost. in this case, tcp performs multiplicative decrease and the congestion window is divided by 2. the slow-start threshold is set to the new value of the congestion window.
• severe congestion. tcp considers that the network is severely congested when its retransmission timer expires. in this case, tcp retransmits the ﬁrst segment, sets the slow-start threshold to 50% of the congestion window. the congestion window is reset to its initial value and tcp performs a slow-start.
the ﬁgure below illustrates the evolution of the congestion window when there is severe congestion. at the beginning of the connection, the sender performs slow-start until the ﬁrst segments are lost and the retransmission timer expires. at this time, the ssthresh is set to half of the current congestion window and the congestion window is reset at one segment. the lost segments are retransmitted as the sender again performs slow-start until the
however, these three classes of addresses were not ﬂexible enough. a class a subnet was too large for most organisations and a class c subnet was too small. flexibility was added by the introduction of variable-length subnets in rfc 1519. with variable-length subnets, the subnet identiﬁer can be any size, from 1 to 31 bits. variable-length subnets allow the network operators to use a subnet that better matches the number of hosts that are placed inside the subnet. a subnet identiﬁer or ipv4 preﬁx is usually 3 represented as a.b.c.d/p where a.b.c.d is the network address obtained by concatenating the subnet identiﬁer with a host identiﬁer containing only 0 and p is the length of the subnet identiﬁer in bits. the table below provides examples of ip subnets.
the ﬁgure below provides a simple example of the utilisation of ipv4 subnets in an enterprise network. the length of the subnet identiﬁer assigned to a lan usually depends on the expected number of hosts attached to the lan. for point-to-point links, many deployments have used /30 preﬁxes, but recent routers are now using /31 subnets on point-to-point links rfc 3021 or do not even use ipv4 addresses on such links 4.
a second issue concerning the addresses of the network layer is the allocation scheme that is used to allocate blocks of addresses to organisations. the ﬁrst allocation scheme was based on the different classes of addresses. the pool of ipv4 addresses was managed by a secretariat who allocated address blocks on a ﬁrst-come ﬁrst served basis. large organisations such as ibm, bbn, as well as stanford or the mit were able to obtain a class a address block. most organisations requested a class b address block containing 65536 addresses, which was suitable for most enterprises and universities. the table below provides examples of some ipv4 address blocks in the class b space.
3 another way of representing ip subnets is to use netmasks. a netmask is a 32 bits ﬁeld whose p high order bits are set to 1 and the low order bits are set to 0. the number of high order bits set 1 indicates the length of the subnet identiﬁer. netmasks are usually represented in the same dotted decimal format as ipv4 addresses. for example 10.0.0.0/8 would be represented as 10.0.0.0 255.0.0.0 while 192.168.1.0/24 would be represented as 192.168.1.0 255.255.255.0. in some cases, the netmask can be represented in hexadecimal.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
• 127.0.0.0/8, which is reserved for loopback addresses. each host implementing ipv4 must have a loopback interface (that is not attached to a datalink layer). by convention, ipv4 address 127.0.0.1 is assigned to this interface. this allows processes running on a host to use tcp/ip to contact other processes running on the same host. this can be very useful for testing purposes.
now that we have clariﬁed the allocation of ipv4 addresses and the utilisation of the longest preﬁx match to forward ipv4 packets, we can have a more detailed look at ipv4 by starting with the format of the ipv4 packets. the ipv4 packet format was deﬁned in rfc 791. apart from a few clariﬁcations and some backward compatible changes, the ipv4 packet format did not change signiﬁcantly since the publication of rfc 791. all ipv4 packets use the 20 bytes header shown below. some ipv4 packets contain an optional header extension that is described later.
• a 4 bits ip header length (ihl) that indicates the length of the ip header in 32 bits words. this ﬁeld allows ipv4 to use options if required, but as it is encoded as a 4 bits ﬁeld, the ipv4 header cannot be longer than 64 bytes.
• an 8 bits ds ﬁeld that is used for quality of service and whose usage is described later. • an 8 bits protocol ﬁeld that indicates the transport layer protocol that must process the packet’s payload at
• a 32 bits source address ﬁeld that contains the ipv4 address of the source host • a 32 bits destination address ﬁeld that contains the ipv4 address of the destination host • a 16 bits checksum that protects only the ipv4 header against transmission errors
the other ﬁelds of the ipv4 header are used for speciﬁc purposes. the ﬁrst is the 8 bits time to live (ttl) ﬁeld. this ﬁeld is used by ipv4 to avoid the risk of having an ipv4 packet caught in an inﬁnite loop due to a transient
the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
network address translation (nat) was proposed in [te1993] and rfc 3022 as a short term solution to deal with the expected shortage of ipv4 addresses in the late 1980s - early 1990s. combined with cidr, nat helped to signiﬁcantly slow down the consumption of ipv4 addresses. a nat is a middlebox that interconnects two networks that are using ipv4 addresses from different addressing spaces. usually, one of these addressing spaces is the public internet while the other is using the private ipv4 addresses deﬁned in rfc 1918. a very common deployment of nat is in broadband access routers as shown in the ﬁgure below. the broadband access router interconnects a home network, either wifi or ethernet based, and the global internet via one isp over adsl or catv. a single ipv4 address is allocated to the broadband access router and network address translation allows all of the hosts attached to the home network to share a single public ipv4 address.
a second type of deployment is in enterprise networks as shown in the ﬁgure below. in this case, the nat functionality is installed on a border router of the enterprise. a private ipv4 address is assigned to each enterprise host while the border router manages a pool containing several public ipv4 addresses.
as the name implies, a nat is a device that “translates” ip addresses. a nat maintains a mapping table between the private ip addresses used in the internal network and the public ipv4 addresses. nat allows a large number of hosts to share a pool of ip addresses, as these hosts do not all access the global internet at the same time. the simplest nat is a middlebox that uses a one-to-one mapping between a private ip address and a public ip address. to understand its operation, let us assume that a nat, such as the one shown above, has just booted. when the nat receives the ﬁrst packet from source s in the internal network which is destined to the public internet, it creates a mapping between internal address s and the ﬁrst address of its pool of public addresses (p1). then, it translates the received packet so that it can be sent to the public internet. this translation is performed as followed :
note: the bogon ﬁlters another example of frequently used import ﬁlters are the ﬁlters that internet service providers use to ignore bogon routes. in the isp community, a bogon route is a route that should not be advertised on the global internet. typical examples include the private ipv4 preﬁxes deﬁned in rfc 1918, the loopback preﬁxes (127.0.0.1/8 and ::1/128) or the ip preﬁxes that have not yet been allocated by iana. a well managed bgp router should ensure that it never advertises bogons on the global internet. detailed information about these bogons may be found at http://www.team-cymru.org/services/bogons/
if this is an update if the import ﬁlter accepts the bgp message, the pseudo-code distinguishes two cases. message for preﬁx p, this can be a new route for this preﬁx or a modiﬁcation of the route’s attributes. the router ﬁrst retrieves from its rib the best route towards preﬁx p. then, the new route is inserted in the rib and the bgp decision process is run to ﬁnd whether the best route towards destination p changes. a bgp message only needs to be sent to the router’s peers if the best route has changed. for each peer, the router applies the export ﬁlter to verify whether the route can be advertised. if yes, the ﬁltered bgp message is sent. otherwise, a withdraw message is sent. when the router receives a withdraw message, it also veriﬁes whether the removal of the route from its rib caused its best route towards this preﬁx to change. it should be noted that, depending on the content of the rib and the export ﬁlters, a bgp router may need to send a withdraw message to a peer after having received an update message from another peer and conversely. let us now discuss in more detail the operation of bgp in an ipv4 network. for this, let us consider the simple network composed of three routers located in three different ases and shown in the ﬁgure below.
this network contains three routers : r1, r2 and r3. each router is attached to a local ipv4 subnet that it advertises using bgp. there are two bgp sessions, one between r1 and r2 and the second between r2 and r3. a /30 subnet is used on each interdomain link (195.100.0.0/30 on r1-r2 and 195.100.0.4/30 on r2-r3). the bgp sessions run above tcp connections established between the neighbouring routers (e.g. 195.100.0.1 - 195.100.0.2 for the r1-r2 session). let us assume that the r1-r2 bgp session is the ﬁrst to be established. a bgp update message sent on such a session contains three ﬁelds :
we use the notation u(preﬁx, nexthop, attributes) to represent such a bgp update message in this section. similarly, w(preﬁx) represents a bgp withdraw for the speciﬁed preﬁx. once the r1-r2 session has been established, r1 sends u(194.100.0.0/24,195.100.0.1,as10) to r2 and r2 sends u(194.100.2.0/23,195.100.0.2,as20). at this point, r1 can reach 194.100.2.0/23 via 195.100.0.2 and r2 can reach 194.100.0.0/24 via 195.100.0.1. once the r2-r3 has been established, r3 sends u(194.100.1.0/24,195.100.0.6,as30). r2 announces on the r2r3 session all the routes inside its rib. it thus sends to r3 : u(194.100.0.0/24,195.100.0.5,as20:as10) and u(194.100.2.0/23,195.100.0.5,as20). note that when r2 advertises the route that it learned from r1, it updates the bgp nexthop and adds its as number to the as-path. r2 also sends u(194.100.1.0/24,195.100.0.2,as20:as30) to r1 on the r1-r3 session. at this point, all bgp routes have been exchanged and all routers can reach 194.100.0.0/24, 194.100.2.0/23 and 194.100.1.0/24.
r1r2r3as10194.100.0.0/24195.100.0.1195.100.0.0/30195.100.0.2195.100.0.5195.100.0.6195.100.0.4/30as20as30194.100.1.0/24194.100.2.0/23as10as20as30bgpbgpbgpbgpsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
[rfc1071] braden, r., borman d. and partridge, c., computing the internet checksum, rfc 1071, sep. 1988 [rfc1122] braden, r., requirements for internet hosts - communication layers, rfc 1122, oct. 1989 [rfc1144] jacobson, v., compressing tcp/ip headers for low-speed serial links, rfc 1144, feb. 1990 [rfc1149] waitzman, d., standard for the transmission of ip datagrams on avian carriers, rfc 1149, apr.
[rfc1169] cerf, v. and mills, k., explaining the role of gosip, rfc 1169, aug. 1990 [rfc1191] mogul, j. and deering, s., path mtu discovery, rfc 1191, nov. 1990 [rfc1195] callon, r., use of osi is-is for routing in tcp/ip and dual environments, rfc 1195, dec. 1990 [rfc1258] kantor, b., bsd rlogin, rfc 1258, sept. 1991 [rfc1321] rivest, r., the md5 message-digest algorithm, rfc 1321, april 1992 [rfc1323] jacobson, v., braden r. and borman, d., tcp extensions for high performance, rfc 1323, may
[rfc1518] rekhter, y. and li, t., an architecture for ip address allocation with cidr, rfc 1518, sept. 1993 [rfc1519] fuller v., li t., yu j. and varadhan, k., classless inter-domain routing (cidr): an address assign-
[rfc1542] wimer, w., clariﬁcations and extensions for the bootstrap protocol, rfc 1542, oct. 1993 [rfc1548] simpson, w., the point-to-point protocol (ppp), rfc 1548, dec. 1993 [rfc1550] bradner, s. and mankin, a., ip: next generation (ipng) white paper solicitation, rfc 1550, dec.
[rfc1561] piscitello, d., use of iso clnp in tuba environments, rfc 1561, dec. 1993 [rfc1621] francis, p., pip near-term architecture, rfc 1621, may 1994 [rfc1624] risjsighani, a., computation of the internet checksum via incremental update, rfc 1624, may
[rfc1631] egevang k. and francis, p., the ip network address translator (nat), rfc 1631, may 1994 [rfc1661] simpson, w., the point-to-point protocol (ppp), rfc 1661, jul. 1994 [rfc1662] simpson, w., ppp in hdlc-like framing, rfc 1662, july 1994 [rfc1710] hinden, r., simple internet protocol plus white paper, rfc 1710, oct. 1994 [rfc1738] berners-lee, t., masinter, l., and mccahill m., uniform resource locators (url), rfc 1738, dec.
[rfc1812] baker, f., requirements for ip version 4 routers, rfc 1812, june 1995 [rfc1819] delgrossi, l., berger, l., internet stream protocol version 2 (st2) protocol speciﬁcation - version
[rfc1896] resnick p., walker a., the text/enriched mime content-type, rfc 1896, feb. 1996 [rfc1918] rekhter y., moskowitz b., karrenberg d., de groot g. and lear, e., address allocation for private
in the example above, the mta running on mta.example.org opens a tcp connection to the smtp server on host smtp.example.com. the lines preﬁxed with s: (resp. c:) are the responses sent by the server (resp. the commands sent by the client). the server sends its greetings as soon as the tcp connection has been established. the client then sends the ehlo command with its fully qualiﬁed domain name. the server replies with reply-code 250 and sends its greetings. the smtp association can now be used to exchange an email. to send an email, the client must ﬁrst provide the address of the recipient with rcpt to:. then it uses the mail from: with the address of the sender. both the recipient and the sender are accepted by the server. the client can now issue the data command to start the transfer of the email message. after having received the 354 reply code, the client sends the headers and the body of its email message. the client indicates the end of the message by sending a line containing only the . (dot) character 15. the server conﬁrms that the email message has been queued for delivery or transmission with a reply code of 250. the client issues the quit command to close the session and the server conﬁrms with reply-code 221, before closing the tcp connection.
note: open smtp relays and spam since its creation in 1971, email has been a very useful tool that is used by many users to exchange lots of information. in the early days, all smtp servers were open and anyone could use them to forward emails towards their ﬁnal destination. unfortunately, over the years, some unscrupulous users have found ways to use email for marketing purposes or to send malware. the ﬁrst documented abuse of email for marketing purposes occurred in 1978 when a marketer who worked for a computer vendor sent a marketing email to many arpanet users. at that time, the arpanet could only be used for research purposes and this was an abuse of the acceptable use policy. unfortunately, given the extremely low cost of sending emails, the problem of unsolicited emails has not stopped. unsolicited emails are now called spam and a study carried out by enisa in 2009 reveals that 95% of email was spam and this number seems to continue to grow. this places a burden on the email infrastructure of internet service providers and large companies that need to process many useless messages. given the amount of spam messages, smtp servers are no longer open rfc 5068. several extensions to smtp have been developed in recent years to deal with this problem. for example, the smtp authentication scheme deﬁned in rfc 4954 can be used by an smtp server to authenticate a client. several techniques have also been proposed to allow smtp servers to authenticate the messages sent by their users rfc 4870 rfc 4871 .
when the ﬁrst versions of smtp were designed, the internet was composed of minicomputers that were used by an entire university department or research lab. these minicomputers were used by many users at the same time. email was mainly used to send messages from a user on a given host to another user on a remote host. at that time, smtp was the only protocol involved in the delivery of the emails as all hosts attached to the network were running an smtp server. on such hosts, an email destined to local users was delivered by placing the email in a special directory or ﬁle owned by the user. however, the introduction of personal computers in the 1980s, changed this environment. initially, users of these personal computers used applications such as telnet to open a remote session on the local minicomputer to read their email. this was not user-friendly. a better solution appeared with the development of user friendly email client applications on personal computers. several protocols were designed to allow these client applications to retrieve the email messages destined to a user from his/her server. two of these protocols became popular and are still used today. the post ofﬁce protocol (pop), deﬁned in rfc 1939, is the simplest one. it allows a client to download all the messages destined to a given user from his/her email server. we describe pop brieﬂy in this section. the second protocol is the internet message access protocol (imap), deﬁned in rfc 3501. imap is more powerful, but also more complex than pop. imap was designed to allow client applications to efﬁciently access in real-time to messages stored in various folders on servers. imap
assumes that all the messages of a given user are stored on a server and provides the functions that are necessary to search, download, delete or ﬁlter messages. pop is another example of a simple line-based protocol. pop runs above the bytestream service. a pop server usually listens to port 110. a pop session is composed of three parts : an authorisation phase during which the server veriﬁes the client’s credential, a transaction phase during which the client downloads messages and an update phase that concludes the session. the client sends commands and the server replies are preﬁxed by +ok to indicate a successful command or by -err to indicate errors. when a client opens a transport connection with the pop server, the latter sends as banner an ascii-line starting with +ok. the pop session is at that time in the authorisation phase. in this phase, the client can send its username (resp. password) with the user (resp. pass) command. the server replies with +ok if the username (resp. password) is valid and -err otherwise. once the username and password have been validated, the pop session enters in the transaction phase. in this phase, the client can issue several commands. the stat command is used to retrieve the status of the server. upon reception of this command, the server replies with a line that contains +ok followed by the number of messages in the mailbox and the total size of the mailbox in bytes. the retr command, followed by a space and an integer, is used to retrieve the nth message of the mailbox. the dele command is used to mark for deletion the nth message of the mailbox. once the client has retrieved and possibly deleted the emails contained in the mailbox, it must issue the quit command. this command terminates the pop session and allows the server to delete all the messages that have been marked for deletion by using the dele command. the ﬁgure below provides a simple pop session. all lines preﬁxed with c: (resp. s:) are sent by the client (resp. server).
+ok pop3 server ready user alice +ok pass 12345pass +ok alice’s maildrop has 2 messages (620 octets) stat +ok 2 620 list +ok 2 messages (620 octets) 1 120 2 500 . retr 1 +ok 120 octets <the pop3 server sends message 1> . dele 1 +ok message 1 deleted quit +ok pop3 server signing off (1 message left)
in this example, a pop client contacts a pop server on behalf of the user named alice. note that in this example, alice’s password is sent in clear by the client. this implies that if someone is able to capture the packets sent by alice, he will know alice’s password 16. then alice’s client issues the stat command to know the number of messages that are stored in her mailbox. it then retrieves and deletes the ﬁrst message of the mailbox.
in the early days of the internet was mainly used for remote terminal access with telnet, email and ﬁle transfer. the default ﬁle transfer protocol, ftp, deﬁned in rfc 959 was widely used and ftp clients and servers are still included in most operating systems.
warning : do not try this on a random smtp server. the exercises proposed in this section should only be run on the smtp server dedicated for these exercises : cnp3.info.ucl.ac.be. if you try them on a production smtp server, the administrator of this server may become angry.
2. the minimum smtp session above allows to verify that the smtp is running. however, this does not always imply that mail can be delivered. for example, large smtp servers often use a database to store all the email addresses that they serve. to verify the correct operation of such a server, one possibility is to use the vrfy command. open a smtp session on the lab’s smtp server (cnp3.info.ucl.ac.be) and use this command to verify that your account is active.
3. now that you know the basics of opening and closing an smtp session, you can now send email manually by using the mail from:, rcpt to: and data commands. use these commands to manually send an email to ingi2141@cnp3.info.ucl.ac.be . do not forget to include the from:, to: and subject: lines in your header.
2. in the early days, email was read by using tools such as /bin/mail or more advanced text-based mail readers such as pine or elm . today, emails are stored on dedicated servers and retrieved by using protocols such as pop_ or imap. from the user’s viewpoint, can you list the advantages and drawbacks of these two protocols ?
3. the tcp protocol supports 65536 different ports numbers. many of these port numbers have been reserved for some applications. the ofﬁcial repository of the reserved port numbers is maintained by the internet assigned numbers authority (iana) on http://www.iana.org/assignments/port-numbers 28. using this information, what is the default port number for the pop3 protocol ? does it run on top of udp or tcp ?
4. the post ofﬁce protocol (pop) is a rather simple protocol described in rfc 1939. pop operates in three phases. the ﬁrst phase is the authorization phase where the client provides a username and a password. the second phase is the transaction phase where the client can retrieve emails. the last phase is the update phase where the client ﬁnalises the transaction. what are the main pop commands and their parameters ? when a pop server returns an answer, how can you easily determine whether the answer is positive or negative ? 5. on smartphones, users often want to avoid downloading large emails over a slow wireless connection. how
7. the lab’s pop server contains a script that runs every minute and sends two email messages to your account if your email folder is empty. use pop to retrieve these two emails and provide the secret message to your teaching assistant.
2. system administrators who are responsible for web servers often want to monitor these servers and check that they are running correctly. as a http server uses tcp on port 80, the simplest solution is to open a
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
• a status line , that indicates whether the request was successful or not • a header , that contains additional information about the response. the response header ends with an empty
• the get method is the most popular one. it is used to retrieve a document from a server. the get method is encoded as get followed by the path of the uri of the requested document and the version of http used by the client. for example, to retrieve the http://www.w3.org/markup/ uri, a client must open a tcp on port 80 with host www.w3.org and send a http request containing the following line get /markup/ http/1.0
– the head method is a variant of the get method that allows the retrieval of the header lines for a given uri without retrieving the entire document. it can be used by a client to verify if a document exists, for instance.
http clients and servers can include many different http headers in http requests and responses. each http header is encoded as a single ascii-line terminated by cr and lf. several of these headers are brieﬂy described below. a detailed discussion of all standard headers may be found in rfc 1945. the mime headers can appear in both http requests and http responses.
• the content-length: header is the mime header that indicates the length of the mime document in bytes. • the content-type: header is the mime header that indicates the type of the attached mime document.
• the server: header indicates the version of the web server that has generated the http response. some servers provide information about their software release and optional modules that they use. for security reasons, some system administrators disable these headers to avoid revealing too much information about their server to potential attackers.
• the date: header indicates when the http response has been produced by the server. • the last-modiﬁed: header indicates the date and time of the last modiﬁcation of the document attached to
• the user-agent: header provides information about the client that has generated the http request. some servers analyse this header line and return different headers and sometimes different documents for different user agents.
• the if-modiﬁed-since: header is followed by a date. it enables clients to cache in memory or on disk the recent or most frequently used documents. when a client needs to request a uri from a server, it ﬁrst checks whether the document is already in its cache. if it is, the client sends a http request with the if-modiﬁedsince: header indicating the date of the cached document. the server will only return the document attached to the http response if it is newer than the version stored in the client’s cache.
• the referrer: header is followed by a uri. it indicates the uri of the document that the client visited before sending this http request. thanks to this header, the server can know the uri of the document containing the hyperlink followed by the client, if any. this information is very useful to measure the impact of advertisements containing hyperlinks placed on websites.
note: the importance of the host: header line the ﬁrst version of http did not include the host: header line. this was a severe limitation for web hosting companies. for example consider a web hosting company that wants to serve both web.example.com and www.example.net on the same physical server. both web sites contain a /index.html document. when a client sends a request for either http://web.example.com/index.html or http://www.example.net/index.html, the http 1.0 request contains the following line :
by parsing this line, a server cannot determine which index.html ﬁle is requested. thanks to the host: is for http://web.example.com/index.html or http://www.dummy.net/index.html. without the host: header, this is impossible. the host: header line allowed web hosting companies to develop their business by supporting a large number of independent web servers on the same physical server.
the status line of the http response begins with the version of http used by the server (usually http/1.0 deﬁned in rfc 1945 or http/1.1 deﬁned in rfc 2616) followed by a three digit status code and additional information in english. http status codes have a similar structure as the reply codes used by smtp.
• all status codes starting with digit 3 indicate that the requested document is no longer available on the server. 301 moved permanently indicates that the requested document is no longer available on this server. a location: header containing the new uri of the requested document is inserted in the http response. 304 not modiﬁed is used in response to an http request containing the if-modiﬁed-since: header. this status line is used by the server if the document stored on the server is not more recent than the date indicated in the if-modiﬁed-since: header.
• all status codes starting with digit 4 indicate that the server has detected an error in the http request sent by the client. 400 bad request indicates a syntax error in the http request. 404 not found indicates that the requested document does not exist on the server.
warning : do not try this on a random smtp server. the exercises proposed in this section should only be run on the smtp server dedicated for these exercises : cnp3.info.ucl.ac.be. if you try them on a production smtp server, the administrator of this server may become angry.
2. the minimum smtp session above allows to verify that the smtp is running. however, this does not always imply that mail can be delivered. for example, large smtp servers often use a database to store all the email addresses that they serve. to verify the correct operation of such a server, one possibility is to use the vrfy command. open a smtp session on the lab’s smtp server (cnp3.info.ucl.ac.be) and use this command to verify that your account is active.
3. now that you know the basics of opening and closing an smtp session, you can now send email manually by using the mail from:, rcpt to: and data commands. use these commands to manually send an email to ingi2141@cnp3.info.ucl.ac.be . do not forget to include the from:, to: and subject: lines in your header.
2. in the early days, email was read by using tools such as /bin/mail or more advanced text-based mail readers such as pine or elm . today, emails are stored on dedicated servers and retrieved by using protocols such as pop_ or imap. from the user’s viewpoint, can you list the advantages and drawbacks of these two protocols ?
3. the tcp protocol supports 65536 different ports numbers. many of these port numbers have been reserved for some applications. the ofﬁcial repository of the reserved port numbers is maintained by the internet assigned numbers authority (iana) on http://www.iana.org/assignments/port-numbers 28. using this information, what is the default port number for the pop3 protocol ? does it run on top of udp or tcp ?
4. the post ofﬁce protocol (pop) is a rather simple protocol described in rfc 1939. pop operates in three phases. the ﬁrst phase is the authorization phase where the client provides a username and a password. the second phase is the transaction phase where the client can retrieve emails. the last phase is the update phase where the client ﬁnalises the transaction. what are the main pop commands and their parameters ? when a pop server returns an answer, how can you easily determine whether the answer is positive or negative ? 5. on smartphones, users often want to avoid downloading large emails over a slow wireless connection. how
7. the lab’s pop server contains a script that runs every minute and sends two email messages to your account if your email folder is empty. use pop to retrieve these two emails and provide the secret message to your teaching assistant.
2. system administrators who are responsible for web servers often want to monitor these servers and check that they are running correctly. as a http server uses tcp on port 80, the simplest solution is to open a
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
and allows the system administrator to login from this host without giving a password 12. consider now an attacker who knows this particular conﬁguration and is able to send ip packets having the client’s address as source. he can send fake tcp segments to the server, but does not receive the server’s answers. if he can predict the isn that is chosen by the server, he can send a fake syn segment and shortly after the fake ack segment conﬁrming the reception of the syn+ack segment sent by the server. once the tcp connection is open, he can use it to send any command to the server. to counter this attack, current tcp implementations add randomness to the isn. one of the solutions, proposed in rfc 1948 is to compute the isn as
where m is the current value of the tcp clock and h‘is a cryptographic hash function. ‘localhost and remotehost (resp. localport and remoteport ) are the ip addresses (port numbers) of the local and remote host and secret is a random number only known by the server. this method allows the server to use different isns for different clients at the same time. measurements performed with the ﬁrst implementations of this technique showed that it was difﬁcult to implement it correctly, but today’s tcp implementation now generate good isns.
a server could, of course, refuse to open a tcp connection upon reception of a syn segment. this refusal may be due to various reasons. there may be no server process that is listening on the destination port of the syn segment. the server could always refuse connection establishments from this particular client (e.g. due to security reasons) or the server may not have enough resources to accept a new tcp connection at that time. in this case, the server would reply with a tcp segment having its rst ﬂag set and containing the sequence number of the received syn segment as its acknowledgment number. this is illustrated in the ﬁgure below. we discuss the other utilizations of the tcp rst ﬂag later (see tcp connection release).
tcp connection establishment can be described as the four state finite state machine shown below. in this fsm, !x (resp. ?y) indicates the transmission of segment x (resp. reception of segment y) during the corresponding transition. init is the initial state. a client host starts in the init state. it then sends a syn segment and enters the syn sent state where it waits for a syn+ack segment. then, it replies with an ack segment and enters the established state where data can
12 on many departmental networks containing unix workstations, it was common to allow users on one of the hosts to use rlogin rfc 1258 to run commands on any of the workstations of the network without giving any password. in this case, the remote workstation “authenticated” the client host based on its ip address. this was a bad practice from a security viewpoint.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
in comparison with ipv4, the ipv6 packets are much simpler and easier to process by routers. a ﬁrst important difference is that there is no checksum inside the ipv6 header. this is mainly because all datalink layers and transport protocols include a checksum or a crc to protect their frames/segments against transmission errors. adding a checksum in the ipv6 header would have forced each router to recompute the checksum of all packets, with limited beneﬁt in detecting errors. in practice, an ip checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. however, this beneﬁt was found to be too small given the reliability of current memories and the cost of computing the checksum on each router. a second difference with ipv4 is that the ipv6 header does not support fragmentation and reassembly. experience with ipv4 has shown that fragmenting packets in routers was costly [km1995] and the developers of ipv6 have decided that routers would not fragment packets anymore. if a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an icmpv6 messages to inform the sender of the problem. the sender can then either fragment the packet or perform path mtu discovery. in ipv6, packet fragmentation is performed only by the source by using ipv6 options. the third difference are the ipv6 options, which are simpler and easier to process than the ipv4 options.
note: header compression on low bandwidth links given the size of the ipv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for voice over ip applications. in such environments, several techniques can be used to reduce the overhead. a ﬁrst solution is to use data compression in the datalink layer to compress all the information exchanged [thomborson1992]. these techniques are similar to the data compression algorithms used in tools such as compress(1) or gzip(1) rfc 1951. they compress streams of bits without taking advantage of the fact that these streams contain ip packets with a known structure. a second solution is to compress the ip and tcp header. these header compression techniques, such as the one deﬁned in rfc 2507 take advantage of the redundancy found in successive packets from the same ﬂow to signiﬁcantly reduce the size of the protocol headers. another solution is to deﬁne a compressed encoding of the ipv6 header that matches the capabilities of the underlying datalink layer rfc 4944.
in ipv6, each option is considered as one header containing a multiple of 8 bytes to ensure that ipv6 options in a packet are aligned on 64 bit boundaries. ipv6 deﬁnes several type of options :
• the hop-by-hop options are options that must be processed by the routers on the packet’s path • the type 0 routing header, which is similar to the ipv4 loose source routing option • the fragmentation option, which is used when fragmenting an ipv6 packet • the destination options • the security options that allow ipv6 hosts to exchange packets with cryptographic authentication (ah
rfc 2460 provides lots of detail on the encodings of the different types of options. in this section, we only discus some of them. the reader may consult rfc 2460 for more information about the other options. the ﬁrst point to note is that each option contains a next header ﬁeld, which indicates the type of header that follows the option. a second point to note is that in order to allow routers to efﬁciently parse ipv6 packets, the options that must be processed by routers (hop-by-hop options and type 0 routing header) must appear ﬁrst in the packet. this allows the router to process a packet without being forced to analyse all the packet’s options. a third point to note is that hop-by-hop and destination options are encoded using a type length value format. furthermore, the type ﬁeld contains bits that indicate whether a router that does not understand this option should ignore the option or discard the packet. this allows the introduction of new options into the network without forcing all devices to be upgraded to support them at the same time. two hop-by-hop options have been deﬁned. rfc 2675 speciﬁes the jumbogram that enables ipv6 to support packets containing a payload larger than 65535 bytes. these jumbo packets have their payload length set to 0 and
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
• 2 : packet too big. the router that was to send the icmpv6 message received an ipv6 packet that is larger than the mtu of the outgoing link. the icmpv6 message contains the mtu of this link in bytes. this allows the sending host to implement path mtu discovery rfc 1981
• 3 : time exceeded. this error message can be sent either by a router or by a host. a router would set code to 0 to report the reception of a packet whose hop limit reached 0. a host would set code to 1 to report that it was unable to reassemble received ipv6 fragments.
• 4 : parameter problem. this icmpv6 message is used to report either the reception of an ipv6 packet with an erroneous header ﬁeld (type 0) or an unknown next header or ip option (types 1 and 2). in this case, the message body contains the erroneous ipv6 packet and the ﬁrst 32 bits of the message body contain a pointer to the error.
two types of informational icmpv6 messages are deﬁned in rfc 4443 : echo request and echo reply, which are used to test the reachability of a destination by using ping6(8). icmpv6 also allows the discovery of the path between a source and a destination by using traceroute6(8). the output below shows a traceroute between a host at uclouvain and one of the main ietf servers. note that this ipv6 path is different than the ipv4 path that was described earlier although the two traceroutes were performed at the same time.
2001:6a8:3080:2::1 13.821 ms 2001:6a8:3000:8000::1 0.651 ms 10ge.cr2.bruvil.belnet.net 3.402 ms 10ge.cr2.brueve.belnet.net 3.668 ms 10ge.cr2.brueve.belnet.net belnet.rt1.ams.nl.geant2.net 10.598 ms so-7-0-0.rt2.cop.dk.geant2.net kbn-ipv6-b1.ipv6.telia.net 21.078 ms s-ipv6-b1-link.ipv6.telia.net 31.312 ms s-ipv6-b1-link.ipv6.telia.net 61.986 ms
note: rate limitation of icmp messages high-end hardware based routers use special purpose chips on their interfaces to forward ipv6 packets at line rate. these chips are optimised to process correct ip packets. they are not able to create icmp messages at line rate. when such a chip receives an ip packet that triggers an icmp message, it interrupts the main cpu of the router and the software running on this cpu processes the packet. this cpu is much slower than the hardware acceleration found on the interfaces [gill2004]. it would be overloaded if it had to process ip packets at line rate and generate one icmp message for each received packet. to protect this cpu, high-end routers limit the rate at which the hardware can interrupt the main cpu and thus the rate at which icmp messages can be generated. this implies that not all erroneous ip packets cause the transmission of an icmp message. the risk of overloading the main cpu of the router is also the reason why using hop-by-hop ipv6 options, including the router alter option is discouraged 20.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
networked applications do not exchange random messages. in order to ensure that the server is able to understand the queries sent by a client, and also that the client is able to understand the responses sent by the server, they must both agree on a set of syntactical and semantic rules. these rules deﬁne the format of the messages exchanged as well as their ordering. this set of rules is called an application-level protocol. an application-level protocol is similar to a structured conversation between humans. assume that alice wants to know the current time but does not have a watch. if bob passes close by, the following conversation could take place :
such a conversation succeeds if both alice and bob speak the same language. if alice meets tchang who only speaks chinese, she won’t be able to ask him the current time. a conversation between humans can be more complex. for example, assume that bob is a security guard whose duty is to only allow trusted secret agents to enter a meeting room. if all agents know a secret password, the conversation between bob and trudy could be as follows :
human conversations can be very formal, e.g. when soldiers communicate with their hierarchy, or informal such as when friends discuss. computers that communicate are more akin to soldiers and require well-deﬁned rules to ensure an successful exchange of information. there are two types of rules that deﬁne how information can be exchanged between computers :
• organisation of the information ﬂow. for many applications, the ﬂow of information must be structured and there are precedence relationships between the different types of information. in the time example above, alice must greet bob before asking for the current time. alice would not ask for the current time ﬁrst and greet bob afterwards. such precedence relationships exist in networked applications as well. for example, a server must receive a username and a valid password before accepting more complex commands from its clients.
let us ﬁrst discuss the syntactical rules. we will later explain how the information ﬂow can be organised by analysing real networked applications. application-layer protocols exchange two types of messages. some protocols such as those used to support electronic mail exchange messages expressed as strings or lines of characters. as the transport layer allows hosts to exchange bytes, they need to agree on a common representation of the characters. the ﬁrst and simplest method to encode characters is to use the ascii table. rfc 20 provides the ascii table that is used by many protocols on the internet. for example, the table deﬁnes the following binary representations :
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
31. consider a transport that supports window of one hundred 1250 bytes segments. what is the maximum bandwidth that this protocol can achieve if the round-trip-time is set to one second ? what happens if, instead of advertising a window of one hundred segments, the receiver decides to advertise a window of 10 segments ?
32. explain under which circumstances a transport entity could advertise a window of 0 segments ? 33. to understand the operation of the tcp congestion control mechanism, it is useful to draw some time sequence diagrams. let us consider a simple scenario of a web client connected to the internet that wishes to retrieve a simple web page from a remote web server. for simplicity, we will assume that the delay between the client and the server is 0.5 seconds and that the packet transmission times on the client and the servers are negligible (e.g. they are both connected to a 1 gbps network). we will also assume that the client and the server use 1 kbytes segments.
1. compute the time required to open a tcp connection, send an http request and retrieve a 16 kbytes web page. this page size is typical of the results returned by search engines like google_ or bing. an important factor in this delay is the initial size of the tcp congestion window on the server. assume ﬁrst that the initial window is set to 1 segment as deﬁned in rfc 2001, 4 kbytes (i.e. 4 segments in this case) as proposed in rfc 3390 or 16 kbytes as proposed in a recent paper.
3. same question as above but assume now that the 6th segment is lost. 4. same question as above, but consider now the loss of the second and seventh acknowledgements sent by the
5. does the analysis above changes if the initial window is set to 16 kbytes instead of one segment ? 34. several mbytes have been sent on a tcp connection and it becomes idle for several minutes. discuss which
35. to operate reliably, a transport protocol that uses go-back-n (resp. selective repeat) cannot use a window that is larger than 2n − 1 (resp. 2n−1) segments. does this limitation affects tcp ? explain your answer. 36. consider the simple network shown in the ﬁgure below. in this network, the router between the client and the server can only store on each outgoing interface one packet in addition to the packet that it is currently transmitting. it discards all the packets that arrive while its buffer is full. assuming that you can neglect the transmission time of acknowledgements and that the server uses an initial window of one segment and has a retransmission timer set to 500 milliseconds, what is the time required to transmit 10 segments from the client to the server. does the performance increases if the server uses an initial window of 16 segments instead ?
simplest encapsulation scheme to understand is in ip in ip deﬁned in rfc 2003. this encapsulation scheme places an ip packet (called the inner packet), including its payload, as the payload of a larger ip packet (called the outer packet). it can be used by border routers to forward packets via routers that do not maintain a bgp routing table. for example, in the ﬁgure above, if router r2 needs to forward a packet towards destination 12.0.0.1, it can add at the front of this packet an ipv4 header whose source address is set to one of its ipv4 addresses and whose destination address is one of the ipv4 addresses of r4. the protocol ﬁeld of the ip header is set to 4 to indicate that it contains an ipv4 packet. the packet is forwarded by r5 to r4 based on the forwarding table that it built thanks to its intradomain routing table. upon reception of the packet, r4 removes the outer header and consults its (bgp) forwarding table to forward the packet towards r3.
besides the import and export ﬁlters, a key difference between bgp and the intradomain routing protocols is that each domain can deﬁne is own ranking algorithm to determine which route is chosen to forward packets when several routes have been learned towards the same preﬁx. this ranking depends on several bgp attributes that can be attached to a bgp route. the ﬁrst bgp attribute that is used to rank bgp routes is the local-preference (local-pref) attribute. this attribute is an unsigned integer that is attached to each bgp route received over an ebgp session by the associated import ﬁlter. when comparing routes towards the same destination preﬁx, a bgp router always prefers the routes with the highest local-pref. if the bgp router knows several routes with the same local-pref, it prefers among the routes having this local-pref the ones with the shortest as-path. the local-pref attribute is often used to prefer some routes over others. this attribute is always present inside bgp updates exchanged over ibgp sessions, but never present in the messages exchanged over ebgp sessions. a common utilisation of local-pref is to support backup links. consider the situation depicted in the ﬁgure below. as1 would always like to use the high bandwidth link to send and receive packets via as2 and only use the backup link upon failure of the primary one. as bgp routers always prefer the routes with the highest local-pref attribute, this policy can be implemented using the following import ﬁlter on r1
with this import ﬁlter, all the bgp routes learned from rb over the high bandwidth links are preferred over the routes learned over the backup link. if the primary link fails, the corresponding routes are removed from r1‘s rib and r1 uses the route learned from ra. r1 reuses the routes via rb as soon as they are advertised by rb once the r1-rb link comes back.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.9ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
this heuristic requires an additional variable in the tcb (dupacks). most implementations set the default number of duplicate acknowledgements that trigger a retransmission to 3. it is now part of the standard tcp speciﬁcation rfc 2581. the fast retransmit heuristic improves the tcp performance provided that isolated segments are lost and the current window is large enough to allow the sender to send three duplicate acknowledgements. the ﬁgure below illustrates the operation of the fast retransmit heuristic.
when losses are not isolated or when the windows are small, the performance of the fast retransmit heuristic decreases. in such environments, it is necessary to allow a tcp sender to use a selective repeat strategy instead of the default go-back-n strategy. implementing selective-repeat requires a change to the tcp protocol as the receiver needs to be able to inform the sender of the out-of-order segments that it has already received. this can be done by using the selective acknowledgements (sack) option deﬁned in rfc 2018. this tcp option is
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
initially, email was used to exchange small messages of ascii text between computer scientists. however, with the growth of the internet, supporting only ascii text became a severe limitation for two reasons. first of all, non-english speakers wanted to write emails in their native language that often required more characters than those of the ascii character table. second, many users wanted to send other content than just ascii text by email such as binary ﬁles, images or sound. to solve this problem, the ietf developed the multipurpose internet mail extensions (mime). these extensions were carefully designed to allow internet email to carry non-ascii characters and binary ﬁles without breaking the email servers that were deployed at that time. this requirement for backward compatibility forced the mime designers to develop extensions to the existing email message format rfc 822 instead of deﬁning a completely new format that would have been better suited to support the new types of emails. rfc 2045 deﬁnes three new types of header lines to support mime :
• the mime-version: header indicates the version of the mime speciﬁcation that was used to encode the email message. the current version of mime is 1.0. other versions of mime may be deﬁned in the future. thanks to this header line, the software that processes email messages will be able to adapt to the mime version used to encode the message. messages that do not contain this header are supposed to be formatted according to the original rfc 822 speciﬁcation.
• the content-type: header line indicates the type of data that is carried inside the message (see below) • the content-transfer-encoding: header line is used to specify how the message has been encoded. when mime was designed, some email servers were only able to process messages containing characters encoded using the 7 bits ascii character set. mime allows the utilisation of other character encodings.
inside the email header, the content-type: header line indicates how the mime email message is structured. rfc 2046 deﬁnes the utilisation of this header line. the two most common structures for mime messages are :
• content-type: multipart/alternative. this header line indicates that the mime message contains several representations of the same information. for example, a multipart/alternative message may contain both a plain text and an html version of the same text.
to support these two types of mime messages, the recipient of a message must be able to extract the different parts from the message. in rfc 822, an empty line was used to separate the header lines from the body. using an empty line to separate the different parts of an email body would be difﬁcult as the body of email messages often contains one or more empty lines. another possible option would be to deﬁne a special line, e.g. *-last_line-* to mark the boundary between two parts of a mime message. unfortunately, this is not possible as some emails may contain this string in their body (e.g. emails sent to students to explain the format of mime messages). to solve this problem, the content-type: header line contains a second parameter that speciﬁes the string that has been used by the sender of the mime message to delineate the different parts. in practice, this string is often chosen randomly by the mail client. the email message below, copied from rfc 2046 shows a mime message containing two parts that are both in plain text and encoded using the ascii character set. the string simple boundary is deﬁned in the content-type: header as the marker for the boundary between two successive parts. another example of mime messages may be found in rfc 2046.
date: mon, 20 sep 1999 16:33:16 +0200 from: nathaniel borenstein <nsb@bellcore.com> to: ned freed <ned@innosoft.com> subject: test mime-version: 1.0 content-type: multipart/mixed; boundary="simple boundary"
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
is-is intermediate system- intermediate system. a link-state intradomain routing that was initially deﬁned for the iso clnp protocol but was extended to support ipv4 and ipv6. is-is is often used in isp networks. it is deﬁned in [iso10589]
iso the international standardization organisation is an agency of the united nations that is based in geneva and develop standards on various topics. within iso, country representatives vote to approve or reject standards. most of the work on the development of iso standards is done in expert working groups. additional information about iso may be obtained from http://www.iso.int
isp an internet service provider, i.e. a network that provides internet access to its clients. itu the international telecommunication union is a united nation’s agency whose purpose is to develop standards for the telecommunication industry. it was initially created to standardise the basic telephone system but expanded later towards data networks. the work within itu is mainly done by network specialists from the telecommunication industry (operators and vendors). see http://www.itu.int for more information
ixp internet exchange point. a location where routers belonging to different domains are attached to the same local area network to establish peering sessions and exchange packets. see http://www.euro-ix.net/ or http://en.wikipedia.org/wiki/list_of_internet_exchange_points_by_size for a partial list of ixps.
lan local area network leased line a telephone line that is permanently available between two endpoints. man metropolitan area network mime the multipurpose internet mail extensions (mime) deﬁned in rfc 2045 are a set of extensions to the format of email messages that allow to use non-ascii characters inside mail messages. a mime message can be composed of several different parts each having a different format.
modem a modem (modulator-demodulator) is a device that encodes (resp. decodes) digital information by modulating (resp. demodulating) an analog signal. modems are frequently used to transmit digital information over telephone lines and radio links. see http://en.wikipedia.org/wiki/modem for a survey of various types of modems
nameserver a server that implements the dns protocol and can answer queries for names inside its own domain. nat a network address translator is a middlebox that translates ip packets. nbma a non broadcast mode multiple access network is a subnetwork that supports multiple hosts/routers but does not provide an efﬁcient way of sending broadcast frames to all devices attached to the subnetwork. atm subnetworks are an example of nbma networks.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
initially, email was used to exchange small messages of ascii text between computer scientists. however, with the growth of the internet, supporting only ascii text became a severe limitation for two reasons. first of all, non-english speakers wanted to write emails in their native language that often required more characters than those of the ascii character table. second, many users wanted to send other content than just ascii text by email such as binary ﬁles, images or sound. to solve this problem, the ietf developed the multipurpose internet mail extensions (mime). these extensions were carefully designed to allow internet email to carry non-ascii characters and binary ﬁles without breaking the email servers that were deployed at that time. this requirement for backward compatibility forced the mime designers to develop extensions to the existing email message format rfc 822 instead of deﬁning a completely new format that would have been better suited to support the new types of emails. rfc 2045 deﬁnes three new types of header lines to support mime :
• the mime-version: header indicates the version of the mime speciﬁcation that was used to encode the email message. the current version of mime is 1.0. other versions of mime may be deﬁned in the future. thanks to this header line, the software that processes email messages will be able to adapt to the mime version used to encode the message. messages that do not contain this header are supposed to be formatted according to the original rfc 822 speciﬁcation.
• the content-type: header line indicates the type of data that is carried inside the message (see below) • the content-transfer-encoding: header line is used to specify how the message has been encoded. when mime was designed, some email servers were only able to process messages containing characters encoded using the 7 bits ascii character set. mime allows the utilisation of other character encodings.
inside the email header, the content-type: header line indicates how the mime email message is structured. rfc 2046 deﬁnes the utilisation of this header line. the two most common structures for mime messages are :
• content-type: multipart/alternative. this header line indicates that the mime message contains several representations of the same information. for example, a multipart/alternative message may contain both a plain text and an html version of the same text.
to support these two types of mime messages, the recipient of a message must be able to extract the different parts from the message. in rfc 822, an empty line was used to separate the header lines from the body. using an empty line to separate the different parts of an email body would be difﬁcult as the body of email messages often contains one or more empty lines. another possible option would be to deﬁne a special line, e.g. *-last_line-* to mark the boundary between two parts of a mime message. unfortunately, this is not possible as some emails may contain this string in their body (e.g. emails sent to students to explain the format of mime messages). to solve this problem, the content-type: header line contains a second parameter that speciﬁes the string that has been used by the sender of the mime message to delineate the different parts. in practice, this string is often chosen randomly by the mail client. the email message below, copied from rfc 2046 shows a mime message containing two parts that are both in plain text and encoded using the ascii character set. the string simple boundary is deﬁned in the content-type: header as the marker for the boundary between two successive parts. another example of mime messages may be found in rfc 2046.
date: mon, 20 sep 1999 16:33:16 +0200 from: nathaniel borenstein <nsb@bellcore.com> to: ned freed <ned@innosoft.com> subject: test mime-version: 1.0 content-type: multipart/mixed; boundary="simple boundary"
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
subnet 130.100.0.0/16 130.101.0.0/16 university of akron, usa 130.102.0.0/16 130.103.0.0/16 130.104.0.0/16 universite catholique de louvain, belgium 130.105.0.0/16 open software foundation, usa
however, the internet was a victim of its own success and in the late 1980s, many organisations were requesting blocks of ipv4 addresses and started connecting to the internet. most of these organisations requested class b address blocks, as class a address blocks were too large and in limited supply while class c address blocks were considered to be too small. unfortunately, there were only 16,384 different class b address blocks and this address space was being consumed quickly. as a consequence, the routing tables maintained by the routers were growing quickly and some routers had difﬁculties maintaining all these routes in their limited memory 5.
faced with these two problems, the internet engineering task force decided to develop the classless interdomain routing (cidr) architecture rfc 1518. this architecture aims at allowing ip routing to scale better than the class-based architecture. cidr contains three important modiﬁcations compared to rfc 791.
1. ip address classes are deprecated. all ip equipment must use and support variable-length subnets. 2. ip address blocks are no longer allocated on a ﬁrst-come-ﬁrst-served basis. instead, cidr introduces a
the last two modiﬁcations were introduced to improve the scalability of the ip routing system. the main drawback of the ﬁrst-come-ﬁrst-served address block allocation scheme was that neighbouring address blocks were allocated to very different organisations and conversely, very different address blocks were allocated to similar organisations. with cidr, address blocks are allocated by regional ip registries (rir) in an aggregatable manner. a rir is responsible for a large block of addresses and a region. for example, ripe is the rir that is responsible for europe. a rir allocates smaller address blocks from its large block to internet service providers rfc 2050. internet service providers then allocate smaller address blocks to their customers. when an organisation requests an address block, it must prove that it already has or expects to have in the near future, a number of hosts or customers that is equivalent to the size of the requested address block. the main advantage of this hierarchical address block allocation scheme is that it allows the routers to maintain fewer routes. for example, consider the address blocks that were allocated to some of the belgian universities as shown in the table below.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the routing information protocol (rip) is the simplest routing protocol that was standardised for the tcp/ip protocol suite. rip is deﬁned in rfc 2453. additional information about rip may be found in [malkin1999] rip routers periodically exchange rip messages. the format of these messages is shown below. a rip message is sent inside a udp segment whose destination port is set to 521. a rip message contains several ﬁelds. the cmd ﬁeld indicates whether the rip message is a request or a response. routers send one of more rip response messages every 30 seconds. these messages contain the distance vectors that summarize the router’s routing table. the rip request messages can be used by routers or hosts to query other routers about the content of their routing table. a typical usage is when a router boots and quickly wants to receive the rip responses from its neighbours to compute its own routing table. the current version of rip is version 2 deﬁned in rfc 2453 for ipv4 and rfc 2080 for ipv6.
the rip header contains an authentication ﬁeld. this authentication can be used by network administrators to ensure that only the rip messages sent by the routers that they manage are used to build the routing tables. rfc 2453 only supports a basic authentication scheme where all routers are conﬁgured with the same password and include this password in all rip messages. this is not very secure since an attacker can know the password by capturing a single rip message. however, this password can protect against conﬁguration errors. stronger authentication schemes are described in rfc 2082 and rfc 4822, but the details of these mechanisms are outside the scope of this section. each rip message contains a set of route entries. each route entry is encoded as a 20 bytes ﬁeld whose format is shown below. rip was initially designed to be suitable for different network layer protocols. some implementations of rip were used in xns or ipx networks. the ﬁrst ﬁeld of the rip route entry is the address family identiﬁer (afi). this identiﬁer indicates the type of address found in the route entry 22. ipv4 uses afi=1. the other important ﬁelds of the route entry are the ipv4 preﬁx, the netmask that indicates the length of the subnet identiﬁer and is encoded as a 32 bits netmask and the metric. although the metric is encoded as a 32 bits ﬁeld, the maximum rip metric is 15 (for rip, 16 = ∞)
with a 20 bytes route entry, it was difﬁcult to use the same format as above to support ipv6. instead of deﬁning a variable length route entry format, the designers of rfc 2080 deﬁned a new format that does not include an afi ﬁeld. the format of the route entries used by rfc 2080 is shown below. plen is the length of the subnet identiﬁer in bits and the metric is encoded as one byte. the maximum metric is still 15.
note: a note on timers the ﬁrst rip implementations sent their distance vector exactly every 30 seconds. this worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time [fj1994]. they collected packet traces in these networks and found that after some time the routers’ timers became synchronised, i.e. almost all routers were sending their distance vectors at almost the same time. this synchronisation of the transmission times of the distance vectors caused an overload on the routers’ cpu but also increased the convergence time of the protocol in some cases. this was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. sally floyd and van jacobson proposed in [fj1994] a simple solution to solve this synchronisation problem. instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval rfc 2080. this randomisation of the delays prevents the synchronisation that occurs with a ﬁxed delay and is now a recommended practice for protocol designers.
link-state routing protocols are used in ip networks. open shortest path first (ospf), deﬁned in rfc 2328, is the link state routing protocol that has been standardised by the ietf. the last version of ospf, which supports ipv6, is deﬁned in rfc 5340. ospf is frequently used in enterprise networks and in some isp networks. however, isp networks often use the is-is link-state routing protocol [iso10589] , which was developed for the iso clnp protocol but was adapted to be used in ip rfc 1195 networks before the ﬁnalisation of the standardisation of ospf. a detailed analysis of isis and ospf may be found in [bmo2006] and [perlman2000]. additional information about ospf may be found in [moy1998]. compared to the basics of link-state routing protocols that we discussed in section link state routing, there are some particularities of ospf that are worth discussing. first, in a large network, ﬂooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. a better approach would be to introduce hierarchical routing. hierarchical routing divides the network into regions. all the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. ospf supports a restricted variant of hierarchical routing. in ospf’s terminology, a region is called an area. ospf imposes restrictions on how a network can be divided into areas. an area is a set of routers and links that are grouped together. usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area 23 . an ospf area contains two types of routers rfc 2328:
• internal router : a router whose directly connected networks belong to the area • area border routers : a router that is attached to several areas.
for example, the network shown in the ﬁgure below has been divided into three areas : area 1, containing routers r1, r3, r4, r5 and ra, area 2 containing r7, r8, r9, r10, rb and rc. ospf areas are identiﬁed by a 32 bit integer, which is sometimes represented as an ip address. among the ospf areas, area 0, also called the backbone area has a special role. the backbone area groups all the area border routers (routers ra, rb and rc in the ﬁgure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the routing information protocol (rip) is the simplest routing protocol that was standardised for the tcp/ip protocol suite. rip is deﬁned in rfc 2453. additional information about rip may be found in [malkin1999] rip routers periodically exchange rip messages. the format of these messages is shown below. a rip message is sent inside a udp segment whose destination port is set to 521. a rip message contains several ﬁelds. the cmd ﬁeld indicates whether the rip message is a request or a response. routers send one of more rip response messages every 30 seconds. these messages contain the distance vectors that summarize the router’s routing table. the rip request messages can be used by routers or hosts to query other routers about the content of their routing table. a typical usage is when a router boots and quickly wants to receive the rip responses from its neighbours to compute its own routing table. the current version of rip is version 2 deﬁned in rfc 2453 for ipv4 and rfc 2080 for ipv6.
the rip header contains an authentication ﬁeld. this authentication can be used by network administrators to ensure that only the rip messages sent by the routers that they manage are used to build the routing tables. rfc 2453 only supports a basic authentication scheme where all routers are conﬁgured with the same password and include this password in all rip messages. this is not very secure since an attacker can know the password by capturing a single rip message. however, this password can protect against conﬁguration errors. stronger authentication schemes are described in rfc 2082 and rfc 4822, but the details of these mechanisms are outside the scope of this section. each rip message contains a set of route entries. each route entry is encoded as a 20 bytes ﬁeld whose format is shown below. rip was initially designed to be suitable for different network layer protocols. some implementations of rip were used in xns or ipx networks. the ﬁrst ﬁeld of the rip route entry is the address family identiﬁer (afi). this identiﬁer indicates the type of address found in the route entry 22. ipv4 uses afi=1. the other important ﬁelds of the route entry are the ipv4 preﬁx, the netmask that indicates the length of the subnet identiﬁer and is encoded as a 32 bits netmask and the metric. although the metric is encoded as a 32 bits ﬁeld, the maximum rip metric is 15 (for rip, 16 = ∞)
with a 20 bytes route entry, it was difﬁcult to use the same format as above to support ipv6. instead of deﬁning a variable length route entry format, the designers of rfc 2080 deﬁned a new format that does not include an afi ﬁeld. the format of the route entries used by rfc 2080 is shown below. plen is the length of the subnet identiﬁer in bits and the metric is encoded as one byte. the maximum metric is still 15.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
to ease the attachment of hosts to subnets, most networks now support the dynamic host conﬁguration protocol (dhcp) rfc 2131. dhcp allows a host to automatically retrieve its assigned ipv4 address. a dhcp server is associated to each subnet 15. each dhcp server manages a pool of ipv4 addresses assigned to the subnet. when a host is ﬁrst attached to the subnet, it sends a dhcp request message in a udp segment (the dhcp server listens on port 67). as the host knows neither its ipv4 address nor the ipv4 address of the dhcp server, this udp segment is sent inside an ipv4 packet whose source and destination addresses are respectively 0.0.0.0 and 255.255.255.255. the dhcp request may contain various options such as the name of the host, its datalink layer address, etc. the server captures the dhcp request and selects an unassigned address in its address pool. it then sends the assigned ipv4 address in a dhcp reply message which contains the datalink layer address of the host and additional information such as the subnet mask of the ipv4 address, the address of the default router or the address of the dns resolver. this dhcp reply message is sent in an ipv4 packet whose source and destination addresses are respectively the ipv4 address of the dhcp server and the 255.255.255.255 broadcast address. the dhcp reply also speciﬁes the lifetime of the address allocation. this forces the host to renew its address allocation once it expires. thanks to the limited lease time, ip addresses are automatically returned to the pool of addresses hosts are powered off. this reduces the waste of ipv4 addresses. in an nbma network, the interactions between ipv4 and the datalink layer are more complex as the arp protocol cannot be used as in a lan. such nbma networks use special servers that store the mappings between ip addresses and the corresponding datalink layer address. asynchronous transfer mode (atm) networks for example can use either the atmarp protocol deﬁned in rfc 2225 or the nexthop resolution protocol (nhrp) deﬁned in rfc 2332. atm networks are less frequently used today and we will not describe the detailed operation of these servers.
at this point of the description of ipv4, it is useful to have a detailed look at how an ipv4 implementation sends, receives and forwards ipv4 packets. the simplest case is when a host needs to send a segment in an ipv4 packet. the host performs two operations. first, it must decide on which interface the packet will be sent. second it must create the corresponding ip packet(s). to simplify the discussion in this section, we ignore the utilisation of ipv4 options. this is not a severe limitation as today ipv4 packets rarely contain options. details about the processing of the ipv4 options may be found in the relevant rfcs, such as rfc 791. furthermore, we also assume that only point-to-point links are used. we defer the explanation of the operation of ipv4 over local area networks until the next chapter. an ipv4 host having n datalink layer interfaces manages n + 1 ipv4 addresses :
• the 127.0.0.1/32 ipv4 address assigned by convention to its loopback address • one a.b.c.d/p ipv4 address assigned to each of its n datalink layer interfaces
such a host maintains a routing table containing one entry for its loopback address and one entry for each subnet identiﬁer assigned to its interfaces. furthermore, the host usually uses one of its interfaces as the default interface when sending packets that are not addressed to a directly connected destination. this is represented by the default route : 0.0.0.0/0 that is associated to one interface. when a transport protocol running on the host requests the transmission of a segment, it usually provides the ipv4 destination address to the ipv4 layer in addition to the segment 16. the ipv4 implementation ﬁrst performs a longest preﬁx match with the destination address in its routing table. the lookup returns the identiﬁcation of the interface that must be used to send the packet. the host can then create the ipv4 packet containing the segment. the source ipv4 address of the packet is the ipv4 address of the host on the interface returned by the longest preﬁx match. the protocol ﬁeld of the packet is set to the identiﬁcation of the local transport protocol which created the segment. the ttl ﬁeld of the packet is set to the default ttl used by the host. the host must now choose the packet’s identiﬁcation. this identiﬁcation is important if the packet becomes fragmented in the network, as it ensures that the destination is able to reassemble the received fragments. ideally, a sending host should never send a packet twice with the same identiﬁcation to the same destination host, in order to ensure that all fragments are correctly reassembled by the destination. unfortunately, with a 16 bits identiﬁcation ﬁeld and an expected msl of
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the corresponding tcb. after having sent the last ack segment, a tcp connection enters the time_wait and remains in this state for 2 ∗ m sl seconds. during this period, the tcb of the connection is maintained. this ensures that the tcp entity that sent the last ack maintains enough state to be able to retransmit this segment if this ack segment is lost and the remote host retransmits its last fin segment or another one. the delay of 2 ∗ m sl seconds ensures that any duplicate segments on the connection would be handled correctly without causing the transmission of an rst segment. without the time_wait state and the 2 ∗ m sl seconds delay, the connection release would not be graceful when the last ack segment is lost.
note: time_wait on busy tcp servers the 2 ∗ m sl seconds delay in the time_wait state is an important operational problem on servers having thousands of simultaneously opened tcp connections [fty99]. consider for example a busy web server that processes 10.000 tcp connections every second. if each of these connections remain in the time_wait state for 4 minutes, this implies that the server would have to maintain more than 2 million tcbs at any time. for this reason, some tcp implementations prefer to perform an abrupt connection release by sending a rst segment to close the connection [aw05] and immediately discard the corresponding tcb. however, if the rst segment is lost, the remote host continues to maintain a tcb for a connection no longer exists. this optimisation reduces the number of tcbs maintained by the host sending the rst segment but at the potential cost of increased processing on the remote host when the rst segment is lost.
the original tcp data transfer mechanisms were deﬁned in rfc 793. based on the experience of using tcp on the growing global internet, this part of the tcp speciﬁcation has been updated and improved several times, always while preserving the backward compatibility with older tcp implementations. in this section, we review the main data transfer mechanisms used by tcp. tcp is a window-based transport protocol that provides a bi-directional byte stream service. this has several implications on the ﬁelds of the tcp header and the mechanisms used by tcp. the three ﬁelds of the tcp header are :
• acknowledgement number. tcp uses cumulative positive acknowledgements. each tcp segment contains the sequence number of the next byte that the sender of the acknowledgement expects to receive from the remote host. in theory, the acknowledgement number is only valid if the ack ﬂag of the tcp header is set. in practice almost all 15 tcp segments have their ack ﬂag set.
note: the transmission control block for each established tcp connection, a tcp implementation must maintain a transmission control block (tcb). a tcb contains all the information required to send and receive segments on this connection rfc 793. this includes 16 :
• the local ip address • the remote ip address • the local tcp port number • the remote tcp port number • the current state of the tcp fsm • the maximum segment size (mss)
15 in practice, only the syn segment do not have their ack ﬂag set. 16 a complete tcp implementation contains additional information in its tcb, notably to support the urgent pointer. however, this part of
however, when a data segment is lost, as illustrated in the bottom part of the ﬁgure, the measurement is ambiguous as the sender cannot determine whether the received acknowledgement was triggered by the ﬁrst transmission of segment 123 or its retransmission. using incorrect round-trip-time estimations could lead to incorrect values of the retransmission timeout. for this reason, phil karn and craig partridge proposed, in [kp91], to ignore the round-trip-time measurements performed during retransmissions. to avoid this ambiguity in the estimation of the round-trip-time when segments are retransmitted, recent tcp implementations rely on the timestamp option deﬁned in rfc 1323. this option allows a tcp sender to place two 32 bit timestamps in each tcp segment that it sends. the ﬁrst timestamp, ts value (tsval) is chosen by the sender of the segment. it could for example be the current value of its real-time clock 22. the second value, ts echo reply (tsecr), is the last tsval that was received from the remote host and stored in the tcb. the ﬁgure below shows how the utilization of this timestamp option allows for the disambiguation of the round-trip-time measurement when there are retransmissions.
once the round-trip-time measurements have been collected for a given tcp connection, the tcp entity must compute the retransmission timeout. as the round-trip-time measurements may change during the lifetime of a connection, the retransmission timeout may also change. at the beginning of a connection 23 , the tcp entity that sends a syn segment does not know the round-trip-time to reach the remote host and the initial retransmission timeout is usually set to 3 seconds rfc 2988. the original tcp speciﬁcation proposed in rfc 793 to include two additional variables in the tcb :
• srtt : the smoothed round-trip-time computed as srrt = (α × srtt) + ((1 − α) × rtt) where rtt is the round-trip-time measured according to the above procedure and α a smoothing factor (e.g. 0.8 or 0.9)
23 as a tcp client often establishes several parallel or successive connections with the same server, rfc 2140 has proposed to reuse for a new connection some information that was collected in the tcb of a previous connection, such as the measured rtt. however, this solution has not been widely implemented.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
to ease the attachment of hosts to subnets, most networks now support the dynamic host conﬁguration protocol (dhcp) rfc 2131. dhcp allows a host to automatically retrieve its assigned ipv4 address. a dhcp server is associated to each subnet 15. each dhcp server manages a pool of ipv4 addresses assigned to the subnet. when a host is ﬁrst attached to the subnet, it sends a dhcp request message in a udp segment (the dhcp server listens on port 67). as the host knows neither its ipv4 address nor the ipv4 address of the dhcp server, this udp segment is sent inside an ipv4 packet whose source and destination addresses are respectively 0.0.0.0 and 255.255.255.255. the dhcp request may contain various options such as the name of the host, its datalink layer address, etc. the server captures the dhcp request and selects an unassigned address in its address pool. it then sends the assigned ipv4 address in a dhcp reply message which contains the datalink layer address of the host and additional information such as the subnet mask of the ipv4 address, the address of the default router or the address of the dns resolver. this dhcp reply message is sent in an ipv4 packet whose source and destination addresses are respectively the ipv4 address of the dhcp server and the 255.255.255.255 broadcast address. the dhcp reply also speciﬁes the lifetime of the address allocation. this forces the host to renew its address allocation once it expires. thanks to the limited lease time, ip addresses are automatically returned to the pool of addresses hosts are powered off. this reduces the waste of ipv4 addresses. in an nbma network, the interactions between ipv4 and the datalink layer are more complex as the arp protocol cannot be used as in a lan. such nbma networks use special servers that store the mappings between ip addresses and the corresponding datalink layer address. asynchronous transfer mode (atm) networks for example can use either the atmarp protocol deﬁned in rfc 2225 or the nexthop resolution protocol (nhrp) deﬁned in rfc 2332. atm networks are less frequently used today and we will not describe the detailed operation of these servers.
at this point of the description of ipv4, it is useful to have a detailed look at how an ipv4 implementation sends, receives and forwards ipv4 packets. the simplest case is when a host needs to send a segment in an ipv4 packet. the host performs two operations. first, it must decide on which interface the packet will be sent. second it must create the corresponding ip packet(s). to simplify the discussion in this section, we ignore the utilisation of ipv4 options. this is not a severe limitation as today ipv4 packets rarely contain options. details about the processing of the ipv4 options may be found in the relevant rfcs, such as rfc 791. furthermore, we also assume that only point-to-point links are used. we defer the explanation of the operation of ipv4 over local area networks until the next chapter. an ipv4 host having n datalink layer interfaces manages n + 1 ipv4 addresses :
• the 127.0.0.1/32 ipv4 address assigned by convention to its loopback address • one a.b.c.d/p ipv4 address assigned to each of its n datalink layer interfaces
such a host maintains a routing table containing one entry for its loopback address and one entry for each subnet identiﬁer assigned to its interfaces. furthermore, the host usually uses one of its interfaces as the default interface when sending packets that are not addressed to a directly connected destination. this is represented by the default route : 0.0.0.0/0 that is associated to one interface. when a transport protocol running on the host requests the transmission of a segment, it usually provides the ipv4 destination address to the ipv4 layer in addition to the segment 16. the ipv4 implementation ﬁrst performs a longest preﬁx match with the destination address in its routing table. the lookup returns the identiﬁcation of the interface that must be used to send the packet. the host can then create the ipv4 packet containing the segment. the source ipv4 address of the packet is the ipv4 address of the host on the interface returned by the longest preﬁx match. the protocol ﬁeld of the packet is set to the identiﬁcation of the local transport protocol which created the segment. the ttl ﬁeld of the packet is set to the default ttl used by the host. the host must now choose the packet’s identiﬁcation. this identiﬁcation is important if the packet becomes fragmented in the network, as it ensures that the destination is able to reassemble the received fragments. ideally, a sending host should never send a packet twice with the same identiﬁcation to the same destination host, in order to ensure that all fragments are correctly reassembled by the destination. unfortunately, with a 16 bits identiﬁcation ﬁeld and an expected msl of
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
note: a note on timers the ﬁrst rip implementations sent their distance vector exactly every 30 seconds. this worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time [fj1994]. they collected packet traces in these networks and found that after some time the routers’ timers became synchronised, i.e. almost all routers were sending their distance vectors at almost the same time. this synchronisation of the transmission times of the distance vectors caused an overload on the routers’ cpu but also increased the convergence time of the protocol in some cases. this was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. sally floyd and van jacobson proposed in [fj1994] a simple solution to solve this synchronisation problem. instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval rfc 2080. this randomisation of the delays prevents the synchronisation that occurs with a ﬁxed delay and is now a recommended practice for protocol designers.
link-state routing protocols are used in ip networks. open shortest path first (ospf), deﬁned in rfc 2328, is the link state routing protocol that has been standardised by the ietf. the last version of ospf, which supports ipv6, is deﬁned in rfc 5340. ospf is frequently used in enterprise networks and in some isp networks. however, isp networks often use the is-is link-state routing protocol [iso10589] , which was developed for the iso clnp protocol but was adapted to be used in ip rfc 1195 networks before the ﬁnalisation of the standardisation of ospf. a detailed analysis of isis and ospf may be found in [bmo2006] and [perlman2000]. additional information about ospf may be found in [moy1998]. compared to the basics of link-state routing protocols that we discussed in section link state routing, there are some particularities of ospf that are worth discussing. first, in a large network, ﬂooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. a better approach would be to introduce hierarchical routing. hierarchical routing divides the network into regions. all the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. ospf supports a restricted variant of hierarchical routing. in ospf’s terminology, a region is called an area. ospf imposes restrictions on how a network can be divided into areas. an area is a set of routers and links that are grouped together. usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area 23 . an ospf area contains two types of routers rfc 2328:
• internal router : a router whose directly connected networks belong to the area • area border routers : a router that is attached to several areas.
for example, the network shown in the ﬁgure below has been divided into three areas : area 1, containing routers r1, r3, r4, r5 and ra, area 2 containing r7, r8, r9, r10, rb and rc. ospf areas are identiﬁed by a 32 bit integer, which is sometimes represented as an ip address. among the ospf areas, area 0, also called the backbone area has a special role. the backbone area groups all the area border routers (routers ra, rb and rc in the ﬁgure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router
a ﬁrst solution to support such a lan with a link-state routing protocol would be to consider that a lan is equivalent to a full-mesh of point-to-point links as if each router can directly reach any other router on the lan. however, this approach has two important drawbacks :
2. remote routers, when looking at the topology distributed by ospf, consider that there is a full-mesh of links between all the lan routers. such a full-mesh implies a lot of redundancy in case of failure, while in practice the entire lan may completely fail. in case of a failure of the entire lan, all routers need to detect the failures and ﬂood link state packets before the lan is completely removed from the ospf topology by remote routers.
to better represent lans and reduce the number of ospf packets that are exchanged, ospf handles lan differently. when ospf routers boot on a lan, they elect 24 one of them as the designated router (dr) rfc 2328. the dr router represents the local area network, and advertises the lan’s subnet (138.48.4.0/24 in the example above). furthermore, lan routers only exchange hello packets with the dr. thanks to the utilisation of a dr, the topology of the lan appears as a set of point-to-point links connected to the dr as shown in the ﬁgure below.
note: how to quickly detect a link failure ? network operators expect an ospf network to be able to quickly recover from link or router failures [vpd2004]. in an ospf network, the recovery after a failure is performed in three steps [ffeb2005] :
• the routers that are adjacent to the failure detect it quickly. the default solution is to rely on the regular exchange of hello packets. however, the interval between successive hellos is often set to 10 seconds... setting the hello timer down to a few milliseconds is difﬁcult as hello packets are created and processed by the main cpu of the routers and these routers cannot easily generate and process a hello packet every millisecond on each of their interfaces. a better solution is to use a dedicated failure detection protocol such as the bidirectional forwarding detection (bfd) protocol deﬁned in [kw2009] that can be implemented directly on the router interfaces. another solution to be able to detect the failure is to instrument the physical and the datalink layer so that they can interrupt the router when a link fails. unfortunately, such a solution cannot be used on all types of physical and datalink layers.
as explained earlier, the internet is composed of more than 30,000 different networks 25 called domains. each domain is composed of a group of routers and hosts that are managed by the same organisation. example domains include belnet, sprint, level3, geant, abilene, cisco or google ...
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
to ease the attachment of hosts to subnets, most networks now support the dynamic host conﬁguration protocol (dhcp) rfc 2131. dhcp allows a host to automatically retrieve its assigned ipv4 address. a dhcp server is associated to each subnet 15. each dhcp server manages a pool of ipv4 addresses assigned to the subnet. when a host is ﬁrst attached to the subnet, it sends a dhcp request message in a udp segment (the dhcp server listens on port 67). as the host knows neither its ipv4 address nor the ipv4 address of the dhcp server, this udp segment is sent inside an ipv4 packet whose source and destination addresses are respectively 0.0.0.0 and 255.255.255.255. the dhcp request may contain various options such as the name of the host, its datalink layer address, etc. the server captures the dhcp request and selects an unassigned address in its address pool. it then sends the assigned ipv4 address in a dhcp reply message which contains the datalink layer address of the host and additional information such as the subnet mask of the ipv4 address, the address of the default router or the address of the dns resolver. this dhcp reply message is sent in an ipv4 packet whose source and destination addresses are respectively the ipv4 address of the dhcp server and the 255.255.255.255 broadcast address. the dhcp reply also speciﬁes the lifetime of the address allocation. this forces the host to renew its address allocation once it expires. thanks to the limited lease time, ip addresses are automatically returned to the pool of addresses hosts are powered off. this reduces the waste of ipv4 addresses. in an nbma network, the interactions between ipv4 and the datalink layer are more complex as the arp protocol cannot be used as in a lan. such nbma networks use special servers that store the mappings between ip addresses and the corresponding datalink layer address. asynchronous transfer mode (atm) networks for example can use either the atmarp protocol deﬁned in rfc 2225 or the nexthop resolution protocol (nhrp) deﬁned in rfc 2332. atm networks are less frequently used today and we will not describe the detailed operation of these servers.
at this point of the description of ipv4, it is useful to have a detailed look at how an ipv4 implementation sends, receives and forwards ipv4 packets. the simplest case is when a host needs to send a segment in an ipv4 packet. the host performs two operations. first, it must decide on which interface the packet will be sent. second it must create the corresponding ip packet(s). to simplify the discussion in this section, we ignore the utilisation of ipv4 options. this is not a severe limitation as today ipv4 packets rarely contain options. details about the processing of the ipv4 options may be found in the relevant rfcs, such as rfc 791. furthermore, we also assume that only point-to-point links are used. we defer the explanation of the operation of ipv4 over local area networks until the next chapter. an ipv4 host having n datalink layer interfaces manages n + 1 ipv4 addresses :
• the 127.0.0.1/32 ipv4 address assigned by convention to its loopback address • one a.b.c.d/p ipv4 address assigned to each of its n datalink layer interfaces
such a host maintains a routing table containing one entry for its loopback address and one entry for each subnet identiﬁer assigned to its interfaces. furthermore, the host usually uses one of its interfaces as the default interface when sending packets that are not addressed to a directly connected destination. this is represented by the default route : 0.0.0.0/0 that is associated to one interface. when a transport protocol running on the host requests the transmission of a segment, it usually provides the ipv4 destination address to the ipv4 layer in addition to the segment 16. the ipv4 implementation ﬁrst performs a longest preﬁx match with the destination address in its routing table. the lookup returns the identiﬁcation of the interface that must be used to send the packet. the host can then create the ipv4 packet containing the segment. the source ipv4 address of the packet is the ipv4 address of the host on the interface returned by the longest preﬁx match. the protocol ﬁeld of the packet is set to the identiﬁcation of the local transport protocol which created the segment. the ttl ﬁeld of the packet is set to the default ttl used by the host. the host must now choose the packet’s identiﬁcation. this identiﬁcation is important if the packet becomes fragmented in the network, as it ensures that the destination is able to reassemble the received fragments. ideally, a sending host should never send a packet twice with the same identiﬁcation to the same destination host, in order to ensure that all fragments are correctly reassembled by the destination. unfortunately, with a 16 bits identiﬁcation ﬁeld and an expected msl of
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
deﬁned and implemented. when isps started to upgrade their physical infrastructure to provide internet access over asymmetric digital subscriber lines (adsl), they tried to reuse their existing authentication (and billing) systems. to meet these requirements, the ietf developed speciﬁcations to allow ppp frames to be transported over other networks than the point-to-point links for which ppp was designed. nowadays, most adsl deployments use ppp over either atm rfc 2364 or ethernet rfc 2516.
ethernet was designed in the 1970s at the palo alto research center [metcalfe1976]. the ﬁrst prototype 4 used a coaxial cable as the shared medium and 3 mbps of bandwidth. ethernet was improved during the late 1970s and in the 1980s, digital equipment, intel and xerox published the ﬁrst ofﬁcial ethernet speciﬁcation [dix]. this speciﬁcation deﬁnes several important parameters for ethernet networks. the ﬁrst decision was to standardise the commercial ethernet at 10 mbps. the second decision was the duration of the slot time. in ethernet, a long slot time enables networks to span a long distance but forces the host to use a larger minimum frame size. the compromise was a slot time of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes. the third decision was the frame format. the experimental 3 mbps ethernet network built at xerox used short frames containing 8 bit source and destination addresses ﬁelds, a 16 bit type indication, up to 554 bytes of payload and a 16 bit crc. using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. although the initial ethernet speciﬁcation [dix] only allowed up to 1024 hosts on an ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. the ﬁrst change was to require each host attached to an ethernet network to have a globally unique datalink layer address. until then, datalink layer addresses were manually conﬁgured on each host. [dp1981] went against that state of the art and noted “suitable installation-speciﬁc administrative procedures are also needed for assigning numbers to hosts on a network. if a host is moved from one network to another it may be necessary to change its host number if its former number is in use on the new network. this is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). it is anticipated that in future ofﬁce environments, hosts locations will change as often as telephones are changed in present-day ofﬁces.” the second change introduced by ethernet was to encode each address as a 48 bits ﬁeld [dp1981]. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages [dp1981] including the ability to allocate large blocks of addresses to manufacturers. eventually, other lan technologies opted for 48 bits addresses as well [802]_ . the third change introduced by ethernet was the deﬁnition of broadcast and multicast addresses. the need for multicast ethernet was foreseen in [dp1981] and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer. the datalink layer addresses used in ethernet networks are often called mac addresses. they are structured as shown in the ﬁgure below. the ﬁrst bit of the address indicates whether the address identiﬁes a network adapter or a multicast group. the upper 24 bits are used to encode an organisation unique identiﬁer (oui). this oui identiﬁes a block of addresses that has been allocated by the secretariat 5 who is responsible for the uniqueness of ethernet addresses to a manufacturer. once a manufacturer has received an oui, it can build and sell products with one of the 16 million addresses in this block.
the original 10 mbps ethernet speciﬁcation [dix] deﬁned a simple frame format where each frame is composed of ﬁve ﬁelds. the ethernet frame starts with a preamble (not shown in the ﬁgure below) that is used by the physical layer of the receiver to synchronise its clock with the sender’s clock. the ﬁrst ﬁeld of the frame is the destination
4 additional information about the history of the ethernet technology may be found at http://ethernethistory.typepad.com/ 5 initially, the ouis were allocated by xerox [dp1981]. however, once ethernet became an ieee and later an iso standard, the allocation
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the routing information protocol (rip) is the simplest routing protocol that was standardised for the tcp/ip protocol suite. rip is deﬁned in rfc 2453. additional information about rip may be found in [malkin1999] rip routers periodically exchange rip messages. the format of these messages is shown below. a rip message is sent inside a udp segment whose destination port is set to 521. a rip message contains several ﬁelds. the cmd ﬁeld indicates whether the rip message is a request or a response. routers send one of more rip response messages every 30 seconds. these messages contain the distance vectors that summarize the router’s routing table. the rip request messages can be used by routers or hosts to query other routers about the content of their routing table. a typical usage is when a router boots and quickly wants to receive the rip responses from its neighbours to compute its own routing table. the current version of rip is version 2 deﬁned in rfc 2453 for ipv4 and rfc 2080 for ipv6.
the rip header contains an authentication ﬁeld. this authentication can be used by network administrators to ensure that only the rip messages sent by the routers that they manage are used to build the routing tables. rfc 2453 only supports a basic authentication scheme where all routers are conﬁgured with the same password and include this password in all rip messages. this is not very secure since an attacker can know the password by capturing a single rip message. however, this password can protect against conﬁguration errors. stronger authentication schemes are described in rfc 2082 and rfc 4822, but the details of these mechanisms are outside the scope of this section. each rip message contains a set of route entries. each route entry is encoded as a 20 bytes ﬁeld whose format is shown below. rip was initially designed to be suitable for different network layer protocols. some implementations of rip were used in xns or ipx networks. the ﬁrst ﬁeld of the rip route entry is the address family identiﬁer (afi). this identiﬁer indicates the type of address found in the route entry 22. ipv4 uses afi=1. the other important ﬁelds of the route entry are the ipv4 preﬁx, the netmask that indicates the length of the subnet identiﬁer and is encoded as a 32 bits netmask and the metric. although the metric is encoded as a 32 bits ﬁeld, the maximum rip metric is 15 (for rip, 16 = ∞)
with a 20 bytes route entry, it was difﬁcult to use the same format as above to support ipv6. instead of deﬁning a variable length route entry format, the designers of rfc 2080 deﬁned a new format that does not include an afi ﬁeld. the format of the route entries used by rfc 2080 is shown below. plen is the length of the subnet identiﬁer in bits and the metric is encoded as one byte. the maximum metric is still 15.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
among these addresses, some are well known. for example, all endsystem automatically belong to the ff02::1 multicast group while all routers automatically belong to the ff02::2 multicast group. we discuss ipv6 multicast later.
the ipv6 packet format was heavily inspired by the packet format proposed for the sipp protocol in rfc 1710. the standard ipv6 header deﬁned in rfc 2460 occupies 40 bytes and contains 8 different ﬁelds, as shown in the ﬁgure below.
• version : a 4 bits ﬁeld set to 6 and intended to allow ip to evolve in the future if needed • trafﬁc class : this 8 bits ﬁeld plays a similar role as the ds byte in the ipv4 header • flow label : this ﬁeld was initially intended to be used to tag packets belonging to the same ﬂow. however,
• next header : this 8 bits ﬁeld indicates the type 19 of header that follows the ipv6 header. it can be a transport layer header (e.g. 6 for tcp or 17 for udp) or an ipv6 option. handling options as a next header allows simplifying the processing of ipv6 packets compared to ipv4.
the jumbogram option contains the packet length as a 32 bits ﬁeld. such packets can only be sent from a source to a destination if all the routers on the path support this option. however, as of this writing it does not seem that the jumbogram option has been implemented. the router alert option deﬁned in rfc 2711 is the second example of a hop-by-hop option. the packets that contain this option should be processed in a special way by intermediate routers. this option is used for ip packets that carry resource reservation protocol (rsvp) messages. its usage is explained later. the type 0 routing header deﬁned in rfc 2460 is an example of an ipv6 option that must be processed by some routers. this option is encoded as shown below.
the type 0 routing option was intended to allow a host to indicate a loose source route that should be followed by a packet by specifying the addresses of some of the routers that must forward this packet. unfortunately, further work with this routing header, including an entertaining demonstration with scapy [be2007] , revealed some severe security problems with this routing header. for this reason, loose source routing with the type 0 routing header has been removed from the ipv6 speciﬁcation rfc 5095. in ipv6, fragmentation is performed exclusively by the source host and relies on the fragmentation header. this 64 bits header is composed of six ﬁelds :
• a next header ﬁeld that indicates the type of the header that follows the fragmentation header • a reserved ﬁeld set to 0. • the fragment offset is a 13-bit unsigned integer that contains the offset, in 8 bytes units, of the data following
• the more ﬂag, which is set to 0 in the last fragment of a packet and to 1 in all other fragments. • the 32 bits identiﬁcation ﬁeld indicates to which original packet a fragment belongs. when a host sends fragmented packets, it should ensure that it does not reuse the same identiﬁcation ﬁeld for packets sent to the same destination during a period of msl seconds. this is easier with the 32 bits identiﬁcation used in the ipv6 fragmentation header, than with the 16 bits identiﬁcation ﬁeld of the ipv4 header.
some ipv6 implementations send the fragments of a packet in increasing fragment offset order, starting from the ﬁrst fragment. others send the fragments in reverse order, starting from the last fragment. the latter solution can be advantageous for the host that needs to reassemble the fragments, as it can easily allocate the buffer required to
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the ethernet frame format shown above is speciﬁed in [dix]. this is the format used to send both ipv4 rfc 894 and ipv6 packets rfc 2464. after the publication of [dix], the institute of electrical and electronic engineers (ieee) began to standardise several local area network technologies. ieee worked on several lan technologies, starting with ethernet, token ring and token bus. these three technologies were completely different, but they all agreed to use the 48 bits mac addresses speciﬁed initially for ethernet [802]_ . while developing its ethernet standard [802.3], the ieee 802.3 working group was confronted with a problem. ethernet mandated a minimum payload size of 46 bytes, while some companies were looking for a lan technology that could transparently transport short frames containing only a few bytes of payload. such a frame can be sent by an ethernet host by padding it to ensure that the payload is at least 46 bytes long. however since the ethernet header [dix] does not contain a length ﬁeld, it is impossible for the receiver to determine how many useful bytes were placed inside the payload ﬁeld. to solve this problem, the ieee decided to replace the type ﬁeld of the ethernet [dix] header with a length ﬁeld 9. this length ﬁeld contains the number of useful bytes in the frame payload. the payload must still contain at least 46 bytes, but padding bytes are added by the sender and removed by the receiver. in order to add the length ﬁeld without signiﬁcantly changing the frame format, ieee had to remove the type ﬁeld. without this ﬁeld, it is impossible for a receiving host to identify the type of network layer packet inside a received frame. to solve this new problem, ieee developed a completely new sublayer called the logical link control [802.2]. several protocols were deﬁned in this sublayer. one of them provided a slightly different version of the type ﬁeld of the original ethernet frame format. another contained acknowledgements and retransmissions to provide a reliable service... in practice, [802.2] is never used to support ip in ethernet networks. the ﬁgure below shows the ofﬁcial [802.3] frame format.
9 fortunately, ieee was able to deﬁne the [802.3] frame format while maintaining backward compatibility with the ethernet [dix] frame format. the trick was to only assign values above 1500 as ethertype values. when a host receives a frame, it can determine whether the frame’s format by checking its ethertype/length ﬁeld. a value lower smaller than 1501 is clearly a length indicator and thus an [802.3] frame. a value larger than 1501 can only be type and thus a [dix] frame.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
in comparison with ipv4, the ipv6 packets are much simpler and easier to process by routers. a ﬁrst important difference is that there is no checksum inside the ipv6 header. this is mainly because all datalink layers and transport protocols include a checksum or a crc to protect their frames/segments against transmission errors. adding a checksum in the ipv6 header would have forced each router to recompute the checksum of all packets, with limited beneﬁt in detecting errors. in practice, an ip checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. however, this beneﬁt was found to be too small given the reliability of current memories and the cost of computing the checksum on each router. a second difference with ipv4 is that the ipv6 header does not support fragmentation and reassembly. experience with ipv4 has shown that fragmenting packets in routers was costly [km1995] and the developers of ipv6 have decided that routers would not fragment packets anymore. if a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an icmpv6 messages to inform the sender of the problem. the sender can then either fragment the packet or perform path mtu discovery. in ipv6, packet fragmentation is performed only by the source by using ipv6 options. the third difference are the ipv6 options, which are simpler and easier to process than the ipv4 options.
note: header compression on low bandwidth links given the size of the ipv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for voice over ip applications. in such environments, several techniques can be used to reduce the overhead. a ﬁrst solution is to use data compression in the datalink layer to compress all the information exchanged [thomborson1992]. these techniques are similar to the data compression algorithms used in tools such as compress(1) or gzip(1) rfc 1951. they compress streams of bits without taking advantage of the fact that these streams contain ip packets with a known structure. a second solution is to compress the ip and tcp header. these header compression techniques, such as the one deﬁned in rfc 2507 take advantage of the redundancy found in successive packets from the same ﬂow to signiﬁcantly reduce the size of the protocol headers. another solution is to deﬁne a compressed encoding of the ipv6 header that matches the capabilities of the underlying datalink layer rfc 4944.
in ipv6, each option is considered as one header containing a multiple of 8 bytes to ensure that ipv6 options in a packet are aligned on 64 bit boundaries. ipv6 deﬁnes several type of options :
• the hop-by-hop options are options that must be processed by the routers on the packet’s path • the type 0 routing header, which is similar to the ipv4 loose source routing option • the fragmentation option, which is used when fragmenting an ipv6 packet • the destination options • the security options that allow ipv6 hosts to exchange packets with cryptographic authentication (ah
rfc 2460 provides lots of detail on the encodings of the different types of options. in this section, we only discus some of them. the reader may consult rfc 2460 for more information about the other options. the ﬁrst point to note is that each option contains a next header ﬁeld, which indicates the type of header that follows the option. a second point to note is that in order to allow routers to efﬁciently parse ipv6 packets, the options that must be processed by routers (hop-by-hop options and type 0 routing header) must appear ﬁrst in the packet. this allows the router to process a packet without being forced to analyse all the packet’s options. a third point to note is that hop-by-hop and destination options are encoded using a type length value format. furthermore, the type ﬁeld contains bits that indicate whether a router that does not understand this option should ignore the option or discard the packet. this allows the introduction of new options into the network without forcing all devices to be upgraded to support them at the same time. two hop-by-hop options have been deﬁned. rfc 2675 speciﬁes the jumbogram that enables ipv6 to support packets containing a payload larger than 65535 bytes. these jumbo packets have their payload length set to 0 and
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
deﬁned and implemented. when isps started to upgrade their physical infrastructure to provide internet access over asymmetric digital subscriber lines (adsl), they tried to reuse their existing authentication (and billing) systems. to meet these requirements, the ietf developed speciﬁcations to allow ppp frames to be transported over other networks than the point-to-point links for which ppp was designed. nowadays, most adsl deployments use ppp over either atm rfc 2364 or ethernet rfc 2516.
ethernet was designed in the 1970s at the palo alto research center [metcalfe1976]. the ﬁrst prototype 4 used a coaxial cable as the shared medium and 3 mbps of bandwidth. ethernet was improved during the late 1970s and in the 1980s, digital equipment, intel and xerox published the ﬁrst ofﬁcial ethernet speciﬁcation [dix]. this speciﬁcation deﬁnes several important parameters for ethernet networks. the ﬁrst decision was to standardise the commercial ethernet at 10 mbps. the second decision was the duration of the slot time. in ethernet, a long slot time enables networks to span a long distance but forces the host to use a larger minimum frame size. the compromise was a slot time of 51.2 microseconds, which corresponds to a minimum frame size of 64 bytes. the third decision was the frame format. the experimental 3 mbps ethernet network built at xerox used short frames containing 8 bit source and destination addresses ﬁelds, a 16 bit type indication, up to 554 bytes of payload and a 16 bit crc. using 8 bit addresses was suitable for an experimental network, but it was clearly too small for commercial deployments. although the initial ethernet speciﬁcation [dix] only allowed up to 1024 hosts on an ethernet network, it also recommended three important changes compared to the networking technologies that were available at that time. the ﬁrst change was to require each host attached to an ethernet network to have a globally unique datalink layer address. until then, datalink layer addresses were manually conﬁgured on each host. [dp1981] went against that state of the art and noted “suitable installation-speciﬁc administrative procedures are also needed for assigning numbers to hosts on a network. if a host is moved from one network to another it may be necessary to change its host number if its former number is in use on the new network. this is easier said than done, as each network must have an administrator who must record the continuously changing state of the system (often on a piece of paper tacked to the wall !). it is anticipated that in future ofﬁce environments, hosts locations will change as often as telephones are changed in present-day ofﬁces.” the second change introduced by ethernet was to encode each address as a 48 bits ﬁeld [dp1981]. 48 bit addresses were huge compared to the networking technologies available in the 1980s, but the huge address space had several advantages [dp1981] including the ability to allocate large blocks of addresses to manufacturers. eventually, other lan technologies opted for 48 bits addresses as well [802]_ . the third change introduced by ethernet was the deﬁnition of broadcast and multicast addresses. the need for multicast ethernet was foreseen in [dp1981] and thanks to the size of the addressing space it was possible to reserve a large block of multicast addresses for each manufacturer. the datalink layer addresses used in ethernet networks are often called mac addresses. they are structured as shown in the ﬁgure below. the ﬁrst bit of the address indicates whether the address identiﬁes a network adapter or a multicast group. the upper 24 bits are used to encode an organisation unique identiﬁer (oui). this oui identiﬁes a block of addresses that has been allocated by the secretariat 5 who is responsible for the uniqueness of ethernet addresses to a manufacturer. once a manufacturer has received an oui, it can build and sell products with one of the 16 million addresses in this block.
the original 10 mbps ethernet speciﬁcation [dix] deﬁned a simple frame format where each frame is composed of ﬁve ﬁelds. the ethernet frame starts with a preamble (not shown in the ﬁgure below) that is used by the physical layer of the receiver to synchronise its clock with the sender’s clock. the ﬁrst ﬁeld of the frame is the destination
4 additional information about the history of the ethernet technology may be found at http://ethernethistory.typepad.com/ 5 initially, the ouis were allocated by xerox [dp1981]. however, once ethernet became an ieee and later an iso standard, the allocation
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
this heuristic requires an additional variable in the tcb (dupacks). most implementations set the default number of duplicate acknowledgements that trigger a retransmission to 3. it is now part of the standard tcp speciﬁcation rfc 2581. the fast retransmit heuristic improves the tcp performance provided that isolated segments are lost and the current window is large enough to allow the sender to send three duplicate acknowledgements. the ﬁgure below illustrates the operation of the fast retransmit heuristic.
when losses are not isolated or when the windows are small, the performance of the fast retransmit heuristic decreases. in such environments, it is necessary to allow a tcp sender to use a selective repeat strategy instead of the default go-back-n strategy. implementing selective-repeat requires a change to the tcp protocol as the receiver needs to be able to inform the sender of the out-of-order segments that it has already received. this can be done by using the selective acknowledgements (sack) option deﬁned in rfc 2018. this tcp option is
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the reply code indicates whether the command was successful or not. a reply code of 2xy indicates that the command has been accepted. a reply code of 3xy indicates that the command has been accepted, but additional information from the client is expected. a reply code of 4xy indicates a transient negative reply. this means that for some reason, which is indicated by either the other digits or the comment, the command cannot be processed immediately, but there is some hope that the problem will only be transient. this is basically telling the client to try the same command again later. in contrast, a reply code of 5xy indicates a permanent failure or error. in this case, it is useless for the client to retry the same command later. other application layer protocols such as ftp rfc 959 or http rfc 2616 use a similar structure for their reply codes. additional details about the other reply codes may be found in rfc 5321. examples of smtp reply codes include the following :
syntax error, command unrecognized syntax error in parameters or arguments command not implemented bad sequence of commands <domain> service ready <domain> service closing transmission channel <domain> service not available, closing transmission channel requested mail action okay, completed requested mail action not taken: mailbox unavailable requested action not taken: insufficient system storage requested action not taken: mailbox unavailable start mail input; end with <crlf>.<crlf>
the ﬁrst four reply codes correspond to errors in the commands sent by the client. the fourth reply code would be sent by the server when the client sends commands in an incorrect order (e.g. the client tries to send an email before providing the destination address of the message). reply code 220 is used by the server as the ﬁrst message when it agrees to interact with the client. reply code 221 is sent by the server before closing the underlying transport connection. reply code 421 is returned when there is a problem (e.g. lack of memory/disk resources) that prevents the server from accepting the transport connection. reply code 250 is the standard positive reply that indicates the success of the previous command. reply codes 450 and 452 indicate that the destination mailbox is temporarily unavailable, for various reasons, while reply code 550 indicates that the mailbox does not exist or cannot be used for policy reasons. reply code 354 indicates that the client can start transmitting its email message. the transfer of an email message is performed in three phases. during the ﬁrst phase, the client opens a transport connection with the server. once the connection has been established, the client and the server exchange greetings messages (ehlo command). most servers insist on receiving valid greeting messages and some of them drop the underlying transport connection if they do not receive a valid greeting. once the greetings have been exchanged, the email transfer phase can start. during this phase, the client transfers one or more email messages by indicating the email address of the sender (mail from: command), the email address of the recipient (rcpt to: command) followed by the headers and the body of the email message (data command). once the client has ﬁnished sending all its queued email messages to the smtp server, it terminates the smtp association (quit command). a successful transfer of an email message is shown below
s: 220 smtp.example.com esmtp mta information c: ehlo mta.example.org s: 250 hello mta.example.org, glad to meet you c: mail from:<alice@example.org> s: 250 ok c: rcpt to:<bob@example.com> s: 250 ok c: data s: 354 end data with <cr><lf>.<cr><lf> c: from: "alice doe" <alice@example.org> c: to: bob smith <bob@example.com> c: date: mon, 9 mar 2010 18:22:32 +0100 c: subject: hello c: c: hello bob c: this is a small message containing 4 lines of text. c: best regards,
• a status line , that indicates whether the request was successful or not • a header , that contains additional information about the response. the response header ends with an empty
• the get method is the most popular one. it is used to retrieve a document from a server. the get method is encoded as get followed by the path of the uri of the requested document and the version of http used by the client. for example, to retrieve the http://www.w3.org/markup/ uri, a client must open a tcp on port 80 with host www.w3.org and send a http request containing the following line get /markup/ http/1.0
– the head method is a variant of the get method that allows the retrieval of the header lines for a given uri without retrieving the entire document. it can be used by a client to verify if a document exists, for instance.
http clients and servers can include many different http headers in http requests and responses. each http header is encoded as a single ascii-line terminated by cr and lf. several of these headers are brieﬂy described below. a detailed discussion of all standard headers may be found in rfc 1945. the mime headers can appear in both http requests and http responses.
• the content-length: header is the mime header that indicates the length of the mime document in bytes. • the content-type: header is the mime header that indicates the type of the attached mime document.
• the connection: header is used with the keep-alive argument by the client to indicate that it expects the underlying tcp connection to be persistent. when this header is used with the close argument, it indicates that the entity that sent it will close the underlying tcp connection at the end of the http response.
• the keep-alive: header is used by the server to inform the client about how it agrees to use the persistent connection. a typical keep-alive: contains two parameters : the maximum number of requests that the server agrees to serve on the underlying tcp connection and the timeout (in seconds) after which the server will close an idle connection
the example below shows the operation of http/1.1 over a persistent tcp connection to retrieve three uris stored on the same server. once the connection has been established, the client sends its ﬁrst request with the connection: keep-alive header to request a persistent connection.
the server replies with the connection: keep-alive header and indicates that it accepts a maximum of 100 http requests over this connection and that it will close the connection if it remains idle for 15 seconds.
http/1.1 200 ok date: fri, 19 mar 2010 09:23:37 gmt server: apache/2.0.63 (freebsd) php/5.2.12 with suhosin-patch keep-alive: timeout=15, max=100 connection: keep-alive content-length: 3462 content-type: text/html
get /style.css http/1.1 host: www.kame.net referer: http://www.kame.net/ user-agent: mozilla/5.0 (macintosh; u; intel mac os x 10_6_2; en-us) connection: keep-alive
tcp connection on port 80 and check that the tcp connection is accepted by the remote host. however, as http is an ascii-based protocol, it is also very easy to write a small script that downloads a web page on the server and compares its content with the expected one. use telnet to verify that a web server is running on host rembrandt.info.ucl.ac.be 31
3. instead of using telnet on port 80, it is also possible to use a command-line tool such as curl use curl with the –trace-ascii traceﬁle option to store in traceﬁle all the information exchanged by curl when accessing the server.
• what is the version of http used by curl ? • can you explain the different headers placed by curl in the request ? • can you explain the different headers found in the response ?
4. http 1.1, speciﬁed in rfc 2616 forces the client to use the host: in all its requests. http 1.0 does not deﬁne the host: header, by most implementations support it. by using telnet and curl retrieve the ﬁrst page of the http://totem.info.ucl.ac.be webserver by sending http requests with and without the host: header. explain the difference between the two 32 .
7. the headers sent in a http request allow the client to provide additional information to the server. one of these headers is the language header that allows to indicate the preferred language of the client 33. for example, curl -haccept-language:en http://www.google.be’ will send to ‘http://www.google.be a http request indicating english (en) as the preferred language. does google provide a different page in french (fr) and walloon (wa) ? same question for http://www.uclouvain.be (given the size of the homepage, use diff to compare the different pages retrieved from www.uclouvain.be)
9. what is a http cookie ? list some advantages and drawbacks of using cookies on web servers. 10. you are now responsible for the http://www.belgium.be. the government has built two datacenters containing 1000 servers each in antwerp and namur. this website contains static information and your objective is to balance the load between the different servers and ensures that the service remains up even if one of the datacenters is disconnected from the internet due to ﬂooding or other natural disasters. what are the techniques that you can use to achieve this goal ?
31 the minimum command sent to a http server is get / http/1.0 followed by crlf and a blank line 32 use dig to ﬁnd the ip address used by totem.info.ucl.ac.be 33 the list of available language tags can be found at http://www.loc.gov/standards/iso639-2/php/code_list.php additional information about
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the server replies with the requested style sheet and maintains the persistent connection. note that the server only accepts 99 remaining http requests over this persistent connection.
http/1.1 200 ok date: fri, 19 mar 2010 09:23:37 gmt server: apache/2.0.63 (freebsd) php/5.2.12 with suhosin-patch last-modified: mon, 10 apr 2006 05:06:39 gmt content-length: 2235 keep-alive: timeout=15, max=99 connection: keep-alive content-type: text/css
then the client automatically requests the web server’s icon 18 , that could be displayed by the browser. this server does not contain such uri and thus replies with a 404 http status. however, the underlying tcp connection is not closed immediately.
get /favicon.ico http/1.1 host: www.kame.net referer: http://www.kame.net/ user-agent: mozilla/5.0 (macintosh; u; intel mac os x 10_6_2; en-us) connection: keep-alive
http/1.1 404 not found date: fri, 19 mar 2010 09:23:40 gmt server: apache/2.0.63 (freebsd) php/5.2.12 with suhosin-patch content-length: 318 keep-alive: timeout=15, max=98 connection: keep-alive content-type: text/html; charset=iso-8859-1
as illustrated above, a client can send several http requests over the same persistent tcp connection. however, it is important to note that all of these http requests are considered to be independent by the server. each http request must be self-contained. this implies that each request must include all the header lines that are required by the server to understand the request. the independence of these requests is one of the important design choices of http. as a consequence of this design choice, when a server processes a http request, it doesn’t’ use any other information than what is contained in the request itself. this explains why the client adds its user-agent: header in all of the http requests it sends over the persistent tcp connection. however, in practice, some servers want to provide content tuned for each user. for example, some servers can provide information in several languages or other servers want to provide advertisements that are targeted to different types of users. to do this, servers need to maintain some information about the preferences of each user and use this information to produce content matching the user’s preferences. http contains several mechanisms that enable to solve this problem. we discuss three of them below. a ﬁrst solution is to force the users to be authenticated. this was the solution used by ftp to control the ﬁles that each user could access. initially, user names and passwords could be included inside uris rfc 1738. however, placing passwords in the clear in a potentially publicly visible uri is completely insecure and this usage has now been deprecated rfc 3986. http supports several extension headers rfc 2617 that can be used by a server to request the authentication of the client by providing his/her credentials. however, user names and passwords have not been popular on web servers as they force human users to remember one user name and one password per server. remembering a password is acceptable when a user needs to access protected content, but users will not accept the need for a user name and password only to receive targeted advertisements from the web sites that they visit. a second solution to allow servers to tune that content to the needs and capabilities of the user is to rely on the different types of accept-* http headers. for example, the accept-language: can be used by the client to
18 favorite icons are small icons that are used to represent web servers in the toolbar of internet browsers. microsoft added this feature in their browsers without taking into account the w3c standards. see http://www.w3.org/2005/10/howto-favicon for a discussion on how to cleanly support such favorite icons.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
in comparison with ipv4, the ipv6 packets are much simpler and easier to process by routers. a ﬁrst important difference is that there is no checksum inside the ipv6 header. this is mainly because all datalink layers and transport protocols include a checksum or a crc to protect their frames/segments against transmission errors. adding a checksum in the ipv6 header would have forced each router to recompute the checksum of all packets, with limited beneﬁt in detecting errors. in practice, an ip checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. however, this beneﬁt was found to be too small given the reliability of current memories and the cost of computing the checksum on each router. a second difference with ipv4 is that the ipv6 header does not support fragmentation and reassembly. experience with ipv4 has shown that fragmenting packets in routers was costly [km1995] and the developers of ipv6 have decided that routers would not fragment packets anymore. if a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an icmpv6 messages to inform the sender of the problem. the sender can then either fragment the packet or perform path mtu discovery. in ipv6, packet fragmentation is performed only by the source by using ipv6 options. the third difference are the ipv6 options, which are simpler and easier to process than the ipv4 options.
note: header compression on low bandwidth links given the size of the ipv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for voice over ip applications. in such environments, several techniques can be used to reduce the overhead. a ﬁrst solution is to use data compression in the datalink layer to compress all the information exchanged [thomborson1992]. these techniques are similar to the data compression algorithms used in tools such as compress(1) or gzip(1) rfc 1951. they compress streams of bits without taking advantage of the fact that these streams contain ip packets with a known structure. a second solution is to compress the ip and tcp header. these header compression techniques, such as the one deﬁned in rfc 2507 take advantage of the redundancy found in successive packets from the same ﬂow to signiﬁcantly reduce the size of the protocol headers. another solution is to deﬁne a compressed encoding of the ipv6 header that matches the capabilities of the underlying datalink layer rfc 4944.
in ipv6, each option is considered as one header containing a multiple of 8 bytes to ensure that ipv6 options in a packet are aligned on 64 bit boundaries. ipv6 deﬁnes several type of options :
• the hop-by-hop options are options that must be processed by the routers on the packet’s path • the type 0 routing header, which is similar to the ipv4 loose source routing option • the fragmentation option, which is used when fragmenting an ipv6 packet • the destination options • the security options that allow ipv6 hosts to exchange packets with cryptographic authentication (ah
rfc 2460 provides lots of detail on the encodings of the different types of options. in this section, we only discus some of them. the reader may consult rfc 2460 for more information about the other options. the ﬁrst point to note is that each option contains a next header ﬁeld, which indicates the type of header that follows the option. a second point to note is that in order to allow routers to efﬁciently parse ipv6 packets, the options that must be processed by routers (hop-by-hop options and type 0 routing header) must appear ﬁrst in the packet. this allows the router to process a packet without being forced to analyse all the packet’s options. a third point to note is that hop-by-hop and destination options are encoded using a type length value format. furthermore, the type ﬁeld contains bits that indicate whether a router that does not understand this option should ignore the option or discard the packet. this allows the introduction of new options into the network without forcing all devices to be upgraded to support them at the same time. two hop-by-hop options have been deﬁned. rfc 2675 speciﬁes the jumbogram that enables ipv6 to support packets containing a payload larger than 65535 bytes. these jumbo packets have their payload length set to 0 and
the jumbogram option contains the packet length as a 32 bits ﬁeld. such packets can only be sent from a source to a destination if all the routers on the path support this option. however, as of this writing it does not seem that the jumbogram option has been implemented. the router alert option deﬁned in rfc 2711 is the second example of a hop-by-hop option. the packets that contain this option should be processed in a special way by intermediate routers. this option is used for ip packets that carry resource reservation protocol (rsvp) messages. its usage is explained later. the type 0 routing header deﬁned in rfc 2460 is an example of an ipv6 option that must be processed by some routers. this option is encoded as shown below.
the type 0 routing option was intended to allow a host to indicate a loose source route that should be followed by a packet by specifying the addresses of some of the routers that must forward this packet. unfortunately, further work with this routing header, including an entertaining demonstration with scapy [be2007] , revealed some severe security problems with this routing header. for this reason, loose source routing with the type 0 routing header has been removed from the ipv6 speciﬁcation rfc 5095. in ipv6, fragmentation is performed exclusively by the source host and relies on the fragmentation header. this 64 bits header is composed of six ﬁelds :
• a next header ﬁeld that indicates the type of the header that follows the fragmentation header • a reserved ﬁeld set to 0. • the fragment offset is a 13-bit unsigned integer that contains the offset, in 8 bytes units, of the data following
• the more ﬂag, which is set to 0 in the last fragment of a packet and to 1 in all other fragments. • the 32 bits identiﬁcation ﬁeld indicates to which original packet a fragment belongs. when a host sends fragmented packets, it should ensure that it does not reuse the same identiﬁcation ﬁeld for packets sent to the same destination during a period of msl seconds. this is easier with the 32 bits identiﬁcation used in the ipv6 fragmentation header, than with the 16 bits identiﬁcation ﬁeld of the ipv4 header.
some ipv6 implementations send the fragments of a packet in increasing fragment offset order, starting from the ﬁrst fragment. others send the fragments in reverse order, starting from the last fragment. the latter solution can be advantageous for the host that needs to reassemble the fragments, as it can easily allocate the buffer required to
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
the simple mail transfer protocol (smtp) deﬁned in rfc 5321 is a client-server protocol. the smtp speciﬁcation distinguishes between ﬁve types of processes involved in the delivery of email messages. email messages are composed on a mail user agent (mua). the mua is usually either an email client or a webmail. the mua sends the email message to a mail submission agent (msa). the msa processes the received email and forwards it to the mail transmission agent (mta). the mta is responsible for the transmission of the email, directly or via intermediate mtas to the mta of the destination domain. this destination mta will then forward the message to the mail delivery agent (mda) where it will be accessed by the recipient’s mua. smtp is used for the interactions between mua and msa 13, msa-mta and mta-mta. smtp is a text-based protocol like many other application-layer protocols on the internet. it relies on the bytestream service. servers listen on port 25. clients send commands that are each composed of one line of ascii text terminated by cr+lf. servers reply by sending ascii lines that contain a three digit numerical error/success code and optional comments. the smtp protocol, like most text-based protocols, is speciﬁed as a bnf. the full bnf is deﬁned in rfc 5321. the main smtp commands are deﬁned by the bnf rules shown in the ﬁgure below.
in this bnf, atext corresponds to printable ascii characters. this bnf rule is deﬁned in rfc 5322. the ﬁve main commands are ehlo, mail from:, rcpt to:, data and quit 14. postmaster is the alias of the system administrator who is responsible for a given domain or smtp server. all domains must have a postmaster alias. the smtp responses are deﬁned by the bnf shown in the ﬁgure below.
14 the ﬁrst versions of smtp used helo as the ﬁrst command sent by a client to a smtp server. when smtp was extended to support newer features such as 8 bits characters, it was necessary to allow a server to recognise whether it was interacting with a client that supported the extensions or not. ehlo became mandatory with the publication of rfc 2821.
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
we explained how a transport connection can be safely released. we then discussed the mechanisms that are used in tcp, the reliable transport protocol, used by most applications on the internet. most notably, we described the congestion control mechanism that has been included in tcp since the late 1980s and explained how the reliability mechanisms used by tcp have been tuned over the years.
this section is divided in two parts. the ﬁrst part contains exercises on the principles of transport protocols, including tcp. the second part contains programming challenges packet analysis tools to observe the behaviour of transport protocols.
1. consider the alternating bit protocol as described in this chapter • how does the protocol recover from the loss of a data segment ? • how does the protocol recovers from the loss of an acknowledgement ? 2. a student proposed to optimise the alternating bit protocol by adding a negative acknowledgment, i.e. the receiver sends a nak control segment when it receives a corrupted data segment. what kind of information should be placed in this control segment and how should the sender react when receiving such a nak ?
• the 16 bits or the 32 bits cyclical redundancy checks (crc) that are often used on disks, in zip archives and in datalink layer protocols. see http://docs.python.org/library/binascii.html for a python module that contains the 32 bits crc
5. checksums and crcs should not be confused with secure hash functions such as md5 deﬁned in rfc 1321 or sha-1 described in rfc 4634. secure hash functions are used to ensure that ﬁles or sometimes packets/segments have not been modiﬁed. secure hash functions aim at detecting malicious changes while checksums and crcs only detect random transmission errors. perform some experiments with hash functions such as those deﬁned in the http://docs.python.org/library/hashlib.html python hashlib module to verify that this is indeed the case.
[rfc1939] myers, j. and rose, m., post ofﬁce protocol - version 3, rfc 1939, may 1996 [rfc1945] berners-lee, t., fielding, r. and frystyk, h., hypertext transfer protocol – http/1.0, rfc 1945,
[rfc1948] bellovin, s., defending against sequence number attacks, rfc 1948, may 1996 [rfc1951] deutsch, p., deflate compressed data format speciﬁcation version 1.3, rfc 1951, may 1996 [rfc1981] mccann, j., deering, s. and mogul, j., path mtu discovery for ip version 6, rfc 1981, aug. 1996 [rfc2003] perkins, c., ip encapsulation within ip, rfc 2003, oct. 1996 [rfc2018] mathis, m., mahdavi, j., floyd, s. and romanow, a., tcp selective acknowledgment options, rfc
[rfc2080] malkin, g. and minnear, r., ripng for ipv6, rfc 2080, jan. 1997 [rfc2082] baker, f. and atkinson, r., rip-2 md5 authentication, rfc 2082, jan. 1997 [rfc2131] droms, r., dynamic host conﬁguration protocol, rfc 2131, march 1997 [rfc2140] touch, j., tcp control block interdependence, rfc 2140, april 1997 [rfc2225] laubach, m., halpern, j., classical ip and arp over atm, rfc 2225, april 1998 [rfc2328] moy, j., ospf version 2, rfc 2328, april 1998 [rfc2332] luciani, j. and katz, d. and piscitello, d. and cole, b. and doraswamy, n., nbma next hop reso-
[rfc2368] hoffman, p. and masinter, l. and zawinski, j., the mailto url scheme, rfc 2368, july 1998 [rfc2453] malkin, g., rip version 2, rfc 2453, nov. 1998 [rfc2460] deering s., hinden, r., internet protocol, version 6 (ipv6) speciﬁcation, rfc 2460, dec. 1998 [rfc2464] crawford, m., transmission of ipv6 packets over ethernet networks, rfc 2464, dec. 1998 [rfc2507] degermark, m. and nordgren, b. and pink, s., ip header compression, rfc 2507, feb. 1999 [rfc2516] mamakos, l. and lidl, k. and evarts, j. and carrel, j. and simone, d. and wheeler, r., a method for
[rfc2581] allman, m. and paxson, v. and stevens, w., tcp congestion control, rfc 2581, april 1999 [rfc2616] fielding, r. and gettys, j. and mogul, j. and frystyk, h. and masinter, l. and leach, p. and berners-
[rfc2854] connolly, d. and masinter, l., the ‘text/html’ media type, rfc 2854, june 2000 [rfc2965] kristol, d. and montulli, l., http state management mechanism, rfc 2965, oct. 2000
denial of service attacks when a tcp entity opens a tcp connection, it creates a transmission control block (tcb). the tcb contains the entire state that is maintained by the tcp entity for each tcp connection. during connection establishment, the tcb contains the local ip address, the remote ip address, the local port number, the remote port number, the current local sequence number, the last sequence number received from the remote entity. until the mid 1990s, tcp implementations had a limit on the number of tcp connections that could be in the syn rcvd state at a given time. many implementations set this limit to about 100 tcbs. this limit was considered sufﬁcient even for heavily load http servers given the small delay between the reception of a syn segment and the reception of the ack segment that terminates the establishment of the tcp connection. when the limit of 100 tcbs in the syn rcvd state is reached, the tcp entity discards all received tcp syn segments that do not correspond to an existing tcb. this limit of 100 tcbs in the syn rcvd state was chosen to protect the tcp entity from the risk of overloading its memory with too many tcbs in the syn rcvd state. however, it was also the reason for a new type of denial of service (dos) attack rfc 4987. a dos attack is deﬁned as an attack where an attacker can render a resource unavailable in the network. for example, an attacker may cause a dos attack on a 2 mbps link used by a company by sending more than 2 mbps of packets through this link. in this case, the dos attack was more subtle. as a tcp entity discards all received syn segments as soon as it has 100 tcbs in the syn rcvd state, an attacker simply had to send a few 100 syn segments every second to a server and never reply to the received syn+ack segments. to avoid being caught, attackers were of course sending these syn segments with a different address than their own ip address a. on most tcp implementations, once a tcb entered the syn rcvd state, it remained in this state for several seconds, waiting for a retransmission of the initial syn segment. this attack was later called a syn ﬂood attack and the servers of the isp named panix were among the ﬁrst to be affected by this attack. to avoid the syn ﬂood attacks, recent tcp implementations no longer enter the syn rcvd state upon reception of a syn segment. instead, they reply directly with a syn+ack segment and wait until the reception of a valid ack. this implementation trick is only possible if the tcp implementation is able to verify that the received ack segment acknowledges the syn+ack segment sent earlier without storing the initial sequence number of this syn+ack segment in a tcb. the solution to solve this problem, which is known as syn cookies is to compute the 32 bits of the isn as follows :
• the high order bits contain the low order bits of a counter that is incremented slowly • the low order bits contain a hash value computed over the local and remote ip addresses and ports and
the advantage of the syn cookies is that by using them, the server does not need to create a tcb upon reception of the syn segment and can still check the returned ack segment by recomputing the syn cookie.
retransmitting the ﬁrst syn segment as ip provides an unreliable connectionless service, the syn and syn+ack segments sent to open a tcp connection could be lost. current tcp implementations start a retransmission timer when they send the ﬁrst syn segment. this timer is often set to three seconds for the ﬁrst retransmission and then doubles after each retransmission rfc 2988. tcp implementations also enforce a maximum number of retransmissions for the initial syn segment.
as explained earlier, tcp segments may contain an optional header extension. in the syn and syn+ack segments, these options are used to negotiate some parameters and the utilisation of extensions to the basic tcp speciﬁcation. the ﬁrst parameter which is negotiated during the establishment of a tcp connection is the maximum segment size (mss). the mss is the size of the largest segment that a tcp entity is able to process. according to rfc 879, all tcp implementations must be able to receive tcp segments containing 536 bytes of payload. however, most tcp implementations are able to process larger segments. such tcp implementations use the tcp mss option in the syn/syn+ack segment to indicate the largest segment they are able to process. the mss value indicates the maximum size of the payload of the tcp segments. the client (resp. server) stores in its tcb the mss value announced by the server (resp. the client).
storing snd.wnd and rcv.wnd as 16 bits integers in the tcb, they should be stored as 32 bits integers. as the tcp segment header only contains 16 bits to place the window ﬁeld, it is impossible to copy the value of snd.wnd in each sent tcp segment. instead the header contains snd.wnd >> s where s is the scaling factor ( 0 ≤ s ≤ 14) negotiated during connection establishment. the client adds its proposed scaling factor as a tcp option in the syn segment. if the server supports rfc 1323, it places in the syn+ack segment the scaling factor that it uses when advertising its own receive window. the local and remote scaling factors are included in the tcb. if the server does not support rfc 1323, it ignores the received option and no scaling is applied. by using the window scaling extensions deﬁned in rfc 1323, tcp implementations can use a receive buffer of up to 1 gbyte. with such a receive buffer, the maximum throughput that can be achieved by a single tcp connection becomes :
these throughputs are acceptable in today’s networks. however, there are already servers having 10 gbps interfaces... early tcp implementations had ﬁxed receiving and sending buffers 20. today’s high performance implementations are able to automatically adjust the size of the sending and receiving buffer to better support high bandwidth ﬂows [smm1998]
in a go-back-n transport protocol such as tcp, the retransmission timeout must be correctly set in order to achieve good performance. if the retransmission timeout expires too early, then bandwidth is wasted by retransmitting segments that have already been correctly received; whereas if the retransmission timeout expires too late, then bandwidth is wasted because the sender is idle waiting for the expiration of its retransmission timeout. a good setting of the retransmission timeout clearly depends on an accurate estimation of the round-trip-time of each tcp connection. the round-trip-time differs between tcp connections, but may also change during the lifetime of a single connection. for example, the ﬁgure below shows the evolution of the round-trip-time between two hosts during a period of 45 seconds.
the easiest solution to measure the round-trip-time on a tcp connection is to measure the delay between the transmission of a data segment and the reception of a corresponding acknowledgement 21. as illustrated in the
20 see http://fasterdata.es.net/tuning.html for more information on how to tune a tcp implementation 21 in theory, a tcp implementation could store the timestamp of each data segment transmitted and compute a new estimate for the roundtrip-time upon reception of the corresponding acknowledgement. however, using such frequent measurements introduces a lot of noise in practice and many implementations still measure the round-trip-time once per round-trip-time by recording the transmission time of one segment at a time rfc 2988
• rto : the retransmission timeout is computed as rto = min(60, max(1, β × srtt)) where β is used to take into account the delay variance (value : 1.3 to 2.0). the 60 and 1 constants are used to ensure that the rto is not larger than one minute nor smaller than 1 second.
however, in practice, this computation for the retransmission timeout did not work well. the main problem was that the computed rto did not correctly take into account the variations in the measured round-trip-time. van jacobson proposed in his seminal paper [jacobson1988] an improved algorithm to compute the rto and implemented it in the bsd unix distribution. this algorithm is now part of the tcp standard rfc 2988. jacobson’s algorithm uses two state variables, srtt the smoothed rtt and rttvar the estimation of the variance of the rtt and two parameters : α and β. when a tcp connection starts, the ﬁrst rto is set to 3 seconds. when a ﬁrst estimation of the rtt is available, the srtt, rttvar and rto are computed as
the proposed values for the parameters are α = 1 4. this allows a tcp implementation, implemented in the kernel, to perform the rtt computation by using shift operations instead of the more costly ﬂoating point operations [jacobson1988]. the ﬁgure below illustrates the computation of the rto upon rtt changes.
the default go-back-n retransmission strategy was deﬁned in rfc 793. when the retransmission timer expires, tcp retransmits the ﬁrst unacknowledged segment (i.e. the one having sequence number snd.una). after each expiration of the retransmission timeout, rfc 2988 recommends to double the value of the retransmission timeout. this is called an exponential backoff. this doubling of the retransmission timeout after a retransmission was included in tcp to deal with issues such as network/receiver overload and incorrect initial estimations of the retransmission timeout. if the same segment is retransmitted several times, the retransmission timeout is doubled after every retransmission until it reaches a conﬁgured maximum. rfc 2988 suggests a maximum retransmission timeout of at least 60 seconds. once the retransmission timeout reaches this conﬁgured maximum, the remote host is considered to be unreachable and the tcp connection is closed. this retransmission strategy has been reﬁned based on the experience of using tcp on the internet. the ﬁrst reﬁnement was a clariﬁcation of the strategy used to send acknowledgements. as tcp uses piggybacking, the
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
however, these three classes of addresses were not ﬂexible enough. a class a subnet was too large for most organisations and a class c subnet was too small. flexibility was added by the introduction of variable-length subnets in rfc 1519. with variable-length subnets, the subnet identiﬁer can be any size, from 1 to 31 bits. variable-length subnets allow the network operators to use a subnet that better matches the number of hosts that are placed inside the subnet. a subnet identiﬁer or ipv4 preﬁx is usually 3 represented as a.b.c.d/p where a.b.c.d is the network address obtained by concatenating the subnet identiﬁer with a host identiﬁer containing only 0 and p is the length of the subnet identiﬁer in bits. the table below provides examples of ip subnets.
the ﬁgure below provides a simple example of the utilisation of ipv4 subnets in an enterprise network. the length of the subnet identiﬁer assigned to a lan usually depends on the expected number of hosts attached to the lan. for point-to-point links, many deployments have used /30 preﬁxes, but recent routers are now using /31 subnets on point-to-point links rfc 3021 or do not even use ipv4 addresses on such links 4.
a second issue concerning the addresses of the network layer is the allocation scheme that is used to allocate blocks of addresses to organisations. the ﬁrst allocation scheme was based on the different classes of addresses. the pool of ipv4 addresses was managed by a secretariat who allocated address blocks on a ﬁrst-come ﬁrst served basis. large organisations such as ibm, bbn, as well as stanford or the mit were able to obtain a class a address block. most organisations requested a class b address block containing 65536 addresses, which was suitable for most enterprises and universities. the table below provides examples of some ipv4 address blocks in the class b space.
3 another way of representing ip subnets is to use netmasks. a netmask is a 32 bits ﬁeld whose p high order bits are set to 1 and the low order bits are set to 0. the number of high order bits set 1 indicates the length of the subnet identiﬁer. netmasks are usually represented in the same dotted decimal format as ipv4 addresses. for example 10.0.0.0/8 would be represented as 10.0.0.0 255.0.0.0 while 192.168.1.0/24 would be represented as 192.168.1.0 255.255.255.0. in some cases, the netmask can be represented in hexadecimal.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
network address translation (nat) was proposed in [te1993] and rfc 3022 as a short term solution to deal with the expected shortage of ipv4 addresses in the late 1980s - early 1990s. combined with cidr, nat helped to signiﬁcantly slow down the consumption of ipv4 addresses. a nat is a middlebox that interconnects two networks that are using ipv4 addresses from different addressing spaces. usually, one of these addressing spaces is the public internet while the other is using the private ipv4 addresses deﬁned in rfc 1918. a very common deployment of nat is in broadband access routers as shown in the ﬁgure below. the broadband access router interconnects a home network, either wifi or ethernet based, and the global internet via one isp over adsl or catv. a single ipv4 address is allocated to the broadband access router and network address translation allows all of the hosts attached to the home network to share a single public ipv4 address.
a second type of deployment is in enterprise networks as shown in the ﬁgure below. in this case, the nat functionality is installed on a border router of the enterprise. a private ipv4 address is assigned to each enterprise host while the border router manages a pool containing several public ipv4 addresses.
as the name implies, a nat is a device that “translates” ip addresses. a nat maintains a mapping table between the private ip addresses used in the internal network and the public ipv4 addresses. nat allows a large number of hosts to share a pool of ip addresses, as these hosts do not all access the global internet at the same time. the simplest nat is a middlebox that uses a one-to-one mapping between a private ip address and a public ip address. to understand its operation, let us assume that a nat, such as the one shown above, has just booted. when the nat receives the ﬁrst packet from source s in the internal network which is destined to the public internet, it creates a mapping between internal address s and the ﬁrst address of its pool of public addresses (p1). then, it translates the received packet so that it can be sent to the public internet. this translation is performed as followed :
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
a router with two point-to-point interfaces and one loopback interface. when a point-to-point interface fails, it becomes unreachable and the router cannot receive anymore packets via this ip address. this is not the case for the loopback interface. it remains reachable as long as at least one of the router’s interfaces remains up. ibgp sessions are usually established using the router’s loopback addresses as endpoints. this allows the ibgp session and its underlying tcp connection to remain up even if physical interfaces fail on the routers.
now that routers can learn interdomain routes over ibgp and ebgp sessions, let us examine what happens when router r3 sends a packet destined to 194.100.1.234. r3 forwards this packet to r4. r4 uses an intradomain routing protocol and bgp. its bgp routing table contains the following longest preﬁx match :
this routes indicates that to forward a packet towards 194.100.0.0/23, r4 needs to forward the packet along the route towards 195.100.0.1. however, r4 is not directly connected to 195.100.0.1. r4 learned a route that matches this address thanks to its intradomain routing protocol that distributed the following routes :
to build its forwarding table, r4 must combine the routes learned from the intradomain routing protocol with the routes learned from bgp. thanks to its intradomain routing table, for each interdomain route r4 replaces the bgp nexthop with its shortest path computed by the intradomain routing protocol. in the ﬁgure above, r4 forwards packets to 194.100.0.0/23 via 195.100.0.10 to which it is directly connected via its north interface. r4 ‘s resulting forwarding table, which associates an outgoing interface for a directly connected preﬁx or a directly connected nexthop and an outgoing interface for preﬁxes learned via bgp, is shown below :
• 194.100.0.0/23 via 195.100.0.10 (north) • 195.100.0.0/30 via 195.100.0.10 (north) • 195.100.0.4/30 east • 195.100.0.8/30 north • 194.100.2.0/23 via 195.100.0.10 (north) • 194.100.4.0/23 west
there is thus a coupling between the interdomain and the intradomain routing tables. if the intradomain routes change, e.g. due to link failures or changes in link metrics, then the forwarding table must be updated on each router as the shortest path towards a bgp nexthop may have changed. the last point to be discussed before looking at the bgp decision process is that a network may contain routers that do not maintain any ebgp session. these routers can be stub routers attached to a single router in the network or core routers that reside on the path between two border routers that are using bgp as illustrated in the ﬁgure below. in the scenario above, router r2 needs to be able to forward a packet towards any destination in the 12.0.0.0/8 preﬁx inside as30. such a packet would need to be forwarded by router r5 since this router resides on the path between r2 and its bgp nexthop attached to r4. two solutions can be used to ensure that r2 is able to forward such interdomain packets :
• enable bgp on router r5 and include this router in the ibgp full-mesh. two ibgp sessions would be added in the ﬁgure above : r2-r5 and r4-r5. this solution works and is used by many ases. however, it forces all routers to have enough resources (cpu and memory) to run bgp and maintain a large forwarding table • encapsulate the interdomain packets sent through the as so that router r5 never needs to forward a packet whose destination is outside the local as. different encapsulation mechanisms exist. multiprotocol label switching (mpls) rfc 3031 and the layer 2 tunneling protocol (l2tp) rfc 3931 are frequently used in large domains, but a detailed explanation of these techniques is outside the scope of this section. the
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
destination (resp. source) port of the segments sent by the client (see ﬁgure utilization of the tcp source and destination ports). a tcp connection is always identiﬁed by ﬁve pieces of information :
• the sequence number (32 bits), acknowledgement number (32 bits) and window (16 bits) ﬁelds are used to provide a reliable data transfer, using a window-based protocol. in a tcp bytestream, each byte of the stream consumes one sequence number. their utilisation will be described in more detail in section tcp reliable data transfer
• the urgent pointer is used to indicate that some data should be considered as urgent in a tcp bytestream. however, it is rarely used in practice and will not be described here. additional details about the utilisation of this pointer may be found in rfc 793, rfc 1122 or [stevens1994]
– the syn ﬂag is used during connection establishment – the fin ﬂag is used during connection release – the rst is used in case of problems or when an invalid segment has been received – when the ack ﬂag is set, it indicates that the acknowledgment ﬁeld contains a valid number. other-
– the urg ﬂag is used together with the urgent pointer – the psh ﬂag is used as a notiﬁcation from the sender to indicate to the receiver that it should pass all the data it has received to the receiving process. however, in practice tcp implementations do not allow tcp users to indicate when the psh ﬂag should be set and thus there are few real utilizations of this ﬂag.
• the reserved ﬁeld was initially reserved for future utilization. it is now used by rfc 3168. • the tcp header length (thl) or data offset ﬁeld is a four bits ﬁeld that indicates the size of the tcp
• the optional header extension is used to add optional information to the tcp header. thanks to this header extension, it is possible to add new ﬁelds to the tcp header that were not planned in the original speciﬁcation. this allowed tcp to evolve since the early eighties. the details of the tcp header extension are explained in sections tcp connection establishment and tcp reliable data transfer.
the rest of this section is organised as follows. we ﬁrst explain the establishment and the release of a tcp connection, then we discuss the mechanisms that are used by tcp to provide a reliable bytestream service. we end the section with a discussion of network congestion and explain the mechanisms that tcp uses to avoid congestion collapse.
a tcp connection is established by using a three-way handshake. the connection establishment phase uses the sequence number, the acknowledgment number and the syn ﬂag. when a tcp connection is established, the two communicating hosts negotiate the initial sequence number to be used in both directions of the connection. for this, each tcp entity maintains a 32 bits counter, which is supposed to be incremented by one at least every 4
tcp uses the segment losses as an indication of congestion. when there are no losses, the network is assumed to be not congested. this implies that congestion is the main cause of packet losses. this is true in wired networks, but unfortunately not always true in wireless networks. another solution is to rely on explicit feedback. this is the solution proposed in the decbit congestion control scheme [rj1995] and used in frame relay and atm networks. this explicit feedback can be implemented in two ways. a ﬁrst solution would be to deﬁne a special message that could be sent by routers to hosts when they are congested. unfortunately, generating such messages may increase the amount of congestion in the network. such a congestion indication packet is thus discouraged rfc 1812. a better approach is to allow the intermediate routers to indicate, in the packets that they forward, their current congestion status. binary feedback can be encoded by using one bit in the packet header. with such a scheme, congested routers set a special bit in the packets that they forward while non-congested routers leave this bit unmodiﬁed. the destination host returns the congestion status of the network in the acknowledgements that it sends. details about such a solution in ip networks may be found in rfc 3168. unfortunately, as of this writing, this solution is still not deployed despite its potential beneﬁts.
the tcp congestion control scheme was initially proposed by van jacobson in [jacobson1988]. the current speciﬁcation may be found in rfc 5681. tcp relies on additive increase and multiplicative decrease (aimd). to implement aimd, a tcp host must be able to control its transmission rate. a ﬁrst approach would be to use timers and adjust their expiration times in function of the rate imposed by aimd. unfortunately, maintaining such timers for a large number of tcp connections can be difﬁcult. instead, van jacobson noted that the rate of tcp congestion can be artiﬁcially controlled by constraining its sending window. a tcp connection cannot send data rtt where window is the maximum between the host’s sending window and the window advertised faster than window by the receiver. tcp’s congestion control scheme is based on a congestion window. the current value of the congestion window (cwnd) is stored in the tcb of each tcp connection and the window that can be used by the sender is constrained by min(cwnd, rwin, swin) where swin is the current sending window and rwin the last received receive window. the additive increase part of the tcp congestion control increments the congestion window by mss bytes every round-trip-time. in the tcp literature, this phase is often called the congestion avoidance phase. the multiplicative decrease part of the tcp congestion control divides the current value of the congestion window once congestion has been detected. when a tcp connection begins, the sending host does not know whether the part of the network that it uses to reach the destination is congested or not. to avoid causing too much congestion, it must start with a small congestion window. [jacobson1988] recommends an initial window of mss bytes. as the additive increase part of the tcp congestion control scheme increments the congestion window by mss bytes every round-trip-time, the tcp connection may have to wait many round-trip-times before being able to efﬁciently use the available bandwidth. this is especially important in environments where the bandwidth × rtt product is high. to avoid waiting too many round-trip-times before reaching a congestion window that is large enough to efﬁciently utilise the network, the tcp congestion control scheme includes the slow-start algorithm. the objective of the tcp slow-start is to quickly reach an acceptable value for the cwnd. during slow-start, the congestion window is doubled every round-trip-time. the slow-start algorithm uses an additional variable in the tcb : sshtresh (slowstart threshold). the ssthresh is an estimation of the last value of the cwnd that did not cause congestion. it is initialised at the sending window and is updated after each congestion event. in practice, a tcp implementation considers the network to be congested once its needs to retransmit a segment. the tcp congestion control scheme distinguishes between two types of congestion :
• mild congestion. tcp considers that the network is lightly congested if it receives three duplicate acknowledgements and performs a fast retransmit. if the fast retransmit is successful, this implies that only one segment has been lost. in this case, tcp performs multiplicative decrease and the congestion window is divided by 2. the slow-start threshold is set to the new value of the congestion window.
• severe congestion. tcp considers that the network is severely congested when its retransmission timer expires. in this case, tcp retransmits the ﬁrst segment, sets the slow-start threshold to 50% of the congestion window. the congestion window is reset to its initial value and tcp performs a slow-start.
the ﬁgure below illustrates the evolution of the congestion window when there is severe congestion. at the beginning of the connection, the sender performs slow-start until the ﬁrst segments are lost and the retransmission timer expires. at this time, the ssthresh is set to half of the current congestion window and the congestion window is reset at one segment. the lost segments are retransmitted as the sender again performs slow-start until the
39. a web server serves mainly html pages that ﬁt inside 10 tcp segments. assuming that the transmission time of each segment can be neglected, compute the total transfer time of such a page (in round-trip-times) assuming that :
40. rfc 3168 deﬁnes mechanism that allow routers to mark packets by setting one bit in the packet header when they are congested. when a tcp destination receives such a marking in a packet, it returns the congestion marking to the source that reacts by halving its congestion window and performs congestion avoidance. consider a tcp connection where the fourth data segment experiences congestion. compare the delay to transmit 8 segments in a network where routers discards packets during congestion and a network where routers mark packets during congestion.
• run the client and the servers on different workstations to determine experimentally the largest sdu that is supported by your language and os. if possible, use different languages and operating systems in each group.
a simple client that sends the following message shown in the ﬁgure below. in this message, the bit ﬂags should be set to 01010011b, the value of the 16 bits ﬁeld must be the square root of the value contained in the 32 bits ﬁeld, the character string must be an ascii representation (without any trailing 0) of the number contained in the 32 bits character ﬁeld. the last 16 bits of the message contain an internet checksum that has been computed over the entire message. upon reception of a message, the server veriﬁes that :
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
share information on the web. they were also extended by other developers who contributed to new features. for example, ncsa added support for images in their mosaic browser that was eventually used to create netscape communications.
the ﬁrst components of the world wide web are the uniform resource identiﬁers (uri), deﬁned in rfc 3986. a uri is a character string that unambiguously identiﬁes a resource on the world wide web. here is a subset of the bnf for uris
= scheme ":" "//" authority path [ "?" query ] [ "#" fragment ] = alpha *( alpha / digit / "+" / "-" / "." ) = [ userinfo "@" ] host [ ":" port ] = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" )
= unreserved / pct-encoded / sub-delims / ":" / "@" = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" ) = "%" hexdig hexdig = alpha / digit / "-" / "." / "_" / "~" = gen-delims / sub-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@" = "!" / "$" / "&" / "’" / "(" / ")" / "*" / "+" / "," / ";" / "="
the ﬁrst component of a uri is its scheme. a scheme can be seen as a selector, indicating the meaning of the ﬁelds after it. in practice, the scheme often identiﬁes the application-layer protocol that must be used by the client to retrieve the document, but it is not always the case. some schemes do not imply a protocol at all and some do not indicate a retrievable document 17. the most frequent scheme is http that will be described later. a uri scheme can be deﬁned for almost any application layer protocol [#furilist]_. the characters ‘: and // follow the scheme of any uri. the second part of the uri is the authority. with retrievable uri, this includes the dns name or the ip address of the server where the document can be retrieved using the protocol speciﬁed via the scheme. this name can be preceded by some information about the user (e.g. a user name) who is requesting the information. earlier deﬁnitions of the uri allowed the speciﬁcation of a user name and a password before the @ character ( rfc 1738), but this is now deprecated as placing a password inside a uri is insecure. the host name can be followed by the semicolon character and a port number. a default port number is deﬁned for some protocols and the port number should only be included in the uri if a non-default port number is used (for other protocols, techniques like service dns records are used). the third part of the uri is the path to the document. this path is structured as ﬁlenames on a unix host (but it does not imply that the ﬁles are indeed stored this way on the server). if the path is not speciﬁed, the server will return a default document. the last two optional parts of the uri are used to provide a query and indicate a speciﬁc part (e.g. a section in an article) of the requested document. sample uris are shown below.
http://tools.ietf.org/html/rfc3986.html mailto:infobot@example.com?subject=current-issue http://docs.python.org/library/basehttpserver.html?highlight=http#basehttpserver.basehttprequesthandler telnet://[2001:6a8:3080:3::2]:80/ ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
the ﬁrst uri corresponds to a document named rfc3986.html that is stored on the server named tools.ietf.org and can be accessed by using the http protocol on its default port. the second uri corresponds to an email message, with subject current-issue, that will be sent to user infobot in domain example.com. the mailto: uri scheme is deﬁned in rfc 6068. the third uri references the portion basehttpserver.basehttprequesthandler of the document basehttpserver.html that is stored in the library directory on server docs.python.org. this document can be retrieved by using the http protocol. the query highlight=http is associated to this uri. the fourth example is a server that operates the telnet protocol, uses ipv6 address 2001:6a8:3080:3::2 and is reachable on port 80. the last uri is somewhat special. most users will assume that it corresponds to a document stored on the cnn.example.com
17 an example of a non-retrievable uri is urn:isbn:0-380-81593-1 which is an unique identiﬁer for a book, through the urn scheme (see rfc 3187). of course, any uri can be make retrievable via a dedicated server or a new protocol but this one has no explicit protocol. same thing for the scheme tag (see rfc 4151), often used in web syndication (see rfc 4287 about the atom syndication format). even when the scheme is retrievable (for instance with http‘), it is often used only as an identiﬁer, not as a way to get a resource. see http://norman.walsh.name/2006/07/25/namesandaddresses for a good explanation.
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
this parity scheme has been used in some rams as well as to encode characters sent over a serial line. it is easy to show that this coding scheme allows the receiver to detect a single transmission error, but it cannot correct it. however, if two or more bits are in error, the receiver may not always be able to detect the error. some coding schemes allow the receiver to correct some transmission errors. for example, consider the coding scheme that encodes each source bit as follows :
for example, consider a sender that sends 111. if there is one bit in error, the receiver could receive 011 or 101 or 110. in these three cases, the receiver will decode the received bit pattern as a 1 since it contains a majority of bits set to 1. if there are two bits in error, the receiver will not be able anymore to recover from the transmission error. this simple coding scheme forces the sender to transmit three bits for each source bit. however, it allows the receiver to correct single bit errors. more advanced coding systems that allow to recover from errors are used in several types of physical layers. transport protocols use error detection schemes, but none of the widely used transport protocols rely on error correction schemes. to detect errors, a segment is usually divided into two parts :
• a header that contains the ﬁelds used by the transport protocol to ensure reliable delivery. the header contains a checksum or cyclical redundancy check (crc) [williams1993] that is used to detect transmission errors
some segment headers also include a length , which indicates the total length of the segment or the length of the payload. the simplest error detection scheme is the checksum. a checksum is basically an arithmetic sum of all the bytes that a segment is composed of. there are different types of checksums. for example, an eight bit checksum can be computed as the arithmetic sum of all the bytes of (both the header and trailer of) the segment. the checksum is computed by the sender before sending the segment and the receiver veriﬁes the checksum upon reception of each segment. the receiver discards segments received with an invalid checksum. checksums can be easily implemented in software, but their error detection capabilities are limited. cyclical redundancy checks (crc) have better error detection capabilities [sgp98], but require more cpu when implemented in software.
note: checksums, crcs, ... most of the protocols in the tcp/ip protocol suite rely on the simple internet checksum in order to verify that the received segment has not been affected by transmission errors. despite its popularity and ease of implementation, the internet checksum is not the only available checksum mechanism. cyclical redundancy checks (crc) are very powerful error detection schemes that are used notably on disks, by many datalink layer protocols and ﬁle formats such as zip or png. they can easily be implemented efﬁciently in hardware and have better error-detection capabilities than the internet checksum [sgp98] . however, when the ﬁrst transport protocols were designed, crcs were considered to be too cpu-intensive for software implementations and other checksum mechanisms were used instead. the tcp/ip community chose the internet checksum, the osi community chose the fletcher checksum [sklower89] . now, there are efﬁcient techniques to quickly compute crcs in software [feldmeier95] , the sctp protocol initially chose the adler-32 checksum but replaced it recently with a crc (see rfc 3309).
the second imperfection of the network layer is that segments may be lost. as we will see later, the main cause of packet losses in the network layer is the lack of buffers in intermediate routers. since the receiver sends an acknowledgement segment after having received each data segment, the simplest solution to deal with losses is to use a retransmission timer. when the sender sends a segment, it starts a retransmission timer. the value of this retransmission timer should be larger than the round-trip-time, i.e. the delay between the transmission of a data segment and the reception of the corresponding acknowledgement. when the retransmission timer expires, the sender assumes that the data segment has been lost and retransmits it. this is illustrated in the ﬁgure below. unfortunately, retransmission timers alone are not sufﬁcient to recover from segment losses. let us consider, as an example, the situation depicted below where an acknowledgement is lost. in this case, the sender retransmits
we explained how a transport connection can be safely released. we then discussed the mechanisms that are used in tcp, the reliable transport protocol, used by most applications on the internet. most notably, we described the congestion control mechanism that has been included in tcp since the late 1980s and explained how the reliability mechanisms used by tcp have been tuned over the years.
this section is divided in two parts. the ﬁrst part contains exercises on the principles of transport protocols, including tcp. the second part contains programming challenges packet analysis tools to observe the behaviour of transport protocols.
1. consider the alternating bit protocol as described in this chapter • how does the protocol recover from the loss of a data segment ? • how does the protocol recovers from the loss of an acknowledgement ? 2. a student proposed to optimise the alternating bit protocol by adding a negative acknowledgment, i.e. the receiver sends a nak control segment when it receives a corrupted data segment. what kind of information should be placed in this control segment and how should the sender react when receiving such a nak ?
• the 16 bits or the 32 bits cyclical redundancy checks (crc) that are often used on disks, in zip archives and in datalink layer protocols. see http://docs.python.org/library/binascii.html for a python module that contains the 32 bits crc
5. checksums and crcs should not be confused with secure hash functions such as md5 deﬁned in rfc 1321 or sha-1 described in rfc 4634. secure hash functions are used to ensure that ﬁles or sometimes packets/segments have not been modiﬁed. secure hash functions aim at detecting malicious changes while checksums and crcs only detect random transmission errors. perform some experiments with hash functions such as those deﬁned in the http://docs.python.org/library/hashlib.html python hashlib module to verify that this is indeed the case.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
another utilisation of tcp options during connection establishment is to enable tcp extensions. for example, consider rfc 1323 (which is discussed in tcp reliable data transfer). rfc 1323 deﬁnes tcp extensions to support timestamps and larger windows. if the client supports rfc 1323, it adds a rfc 1323 option to its syn if the server understands this rfc 1323 option and wishes to use it, it replies with an rfc 1323 segment. option in the syn+ack segment and the extension deﬁned in rfc 1323 is used throughout the tcp connection. otherwise, if the server’s syn+ack does not contain the rfc 1323 option, the client is not allowed to use this extension and the corresponding tcp header options throughout the tcp connection. tcp’s option mechanism is ﬂexible and it allows the extension of tcp while maintaining compatibility with older implementations. the tcp options are encoded by using a type length value format where :
• the ﬁrst byte indicates the type of the option. • the second byte indicates the total length of the option (including the ﬁrst two bytes) in bytes • the last bytes are speciﬁc for each type of option
rfc 793 deﬁnes the maximum segment size (mss) tcp option that must be understood by all tcp implementations. this option (type 2) has a length of 4 bytes and contains a 16 bits word that indicates the mss supported by the sender of the syn segment. the mss option can only be used in tcp segments having the syn ﬂag set. rfc 793 also deﬁnes two special options that must be supported by all tcp implementations. the ﬁrst option is end of option. it is encoded as a single byte having value 0x00 and can be used to ensure that the tcp header extension ends on a 32 bits boundary. the no-operation option, encoded as a single byte having value 0x01, can be used when the tcp header extension contains several tcp options that should be aligned on 32 bit boundaries. all other options 14 are encoded by using the tlv format.
note: the robustness principle the handling of the tcp options by tcp implementations is one of the many applications of the robustness principle which is usually attributed to jon postel and is often quoted as “be liberal in what you accept, and conservative in what you send” rfc 1122 concerning the tcp options, the robustness principle implies that a tcp implementation should be able to accept tcp options that it does not understand, in particular in received syn segments, and that it should be able to parse any received segment without crashing, even if the segment contains an unknown tcp option. furthermore, a server should not send in the syn+ack segment or later, options that have not been proposed by the client in the syn segment.
• graceful connection release, where each tcp user can release its own direction of data transfer • abrupt connection release, where either one user closes both directions of data transfer or one tcp entity is forced to close the connection (e.g. because the remote host does not reply anymore or due to lack of resources)
the abrupt connection release mechanism is very simple and relies on a single segment having the rst bit set. a tcp segment containing the rst bit can be sent for the following reasons :
• a non-syn segment was received for a non-existing tcp connection rfc 793 • by extension, some implementations respond with an rst segment to a segment that is received on an existing connection but with an invalid header rfc 3360. this causes the corresponding connection to be closed and has caused security attacks rfc 4953
• by extension, some implementations send an rst segment when they need to close an existing tcp connection (e.g. because there are not enough resources to support this connection or because the remote host is considered to be unreachable). measurements have shown that this usage of tcp rst was widespread [aw05]
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
furthermore when a tcp connection has been idle for more than its current retransmission timer, it should reset its congestion window to the congestion window size that it uses when the connection begins, as it no longer knows the current congestion state of the network.
note: initial congestion window the original tcp congestion control mechanism proposed in [jacobson1988] recommended that each tcp connection should begin by setting cwnd = m ss. however, in today’s higher bandwidth networks, using such a small initial congestion window severely affects the performance for short tcp connections, such as those used by web servers. since the publication of rfc 3390, tcp hosts are allowed to use an initial congestion window of about 4 kbytes, which corresponds to 3 segments in many environments.
thanks to its congestion control scheme, tcp adapts its transmission rate to the losses that occur in the network. intuitively, the tcp transmission rate decreases when the percentage of losses increases. researchers have proposed detailed models that allow the prediction of the throughput of a tcp connection when losses occur [msmo1997] . to have some intuition about the factors that affect the performance of tcp, let us consider a very simple model. its assumptions are not completely realistic, but it gives us good intuition without requiring complex mathematics. this model considers a hypothetical tcp connection that suffers from equally spaced segment losses. if p is the p − 1 segments and the next segment is lost. segment loss ratio, then the tcp connection successfully transfers 1 if we ignore the slow-start at the beginning of the connection, tcp in this environment is always in congestion avoidance as there are only isolated losses that can be recovered by using fast retransmit. the evolution of the congestion window is thus as shown in the ﬁgure below. note the that x-axis of this ﬁgure represents time measured in units of one round-trip-time, which is supposed to be constant in the model, and the y-axis represents the size of the congestion window measured in mss-sized segments.
2 ), and is incremented by as the losses are equally spaced, the congestion window always starts at some value ( w one mss every round-trip-time until it reaches twice this value (w). at this point, a segment is retransmitted and 2 round-tripthe cycle starts again. if the congestion window is measured in mss-sized segments, a cycle lasts w times. the bandwidth of the tcp connection is the number of bytes that have been transmitted during a given period of time. during a cycle, the number of segments that are sent on the tcp connection is equal to the area of the yellow trapeze in the ﬁgure. its area is thus :
31. consider a transport that supports window of one hundred 1250 bytes segments. what is the maximum bandwidth that this protocol can achieve if the round-trip-time is set to one second ? what happens if, instead of advertising a window of one hundred segments, the receiver decides to advertise a window of 10 segments ?
32. explain under which circumstances a transport entity could advertise a window of 0 segments ? 33. to understand the operation of the tcp congestion control mechanism, it is useful to draw some time sequence diagrams. let us consider a simple scenario of a web client connected to the internet that wishes to retrieve a simple web page from a remote web server. for simplicity, we will assume that the delay between the client and the server is 0.5 seconds and that the packet transmission times on the client and the servers are negligible (e.g. they are both connected to a 1 gbps network). we will also assume that the client and the server use 1 kbytes segments.
1. compute the time required to open a tcp connection, send an http request and retrieve a 16 kbytes web page. this page size is typical of the results returned by search engines like google_ or bing. an important factor in this delay is the initial size of the tcp congestion window on the server. assume ﬁrst that the initial window is set to 1 segment as deﬁned in rfc 2001, 4 kbytes (i.e. 4 segments in this case) as proposed in rfc 3390 or 16 kbytes as proposed in a recent paper.
3. same question as above but assume now that the 6th segment is lost. 4. same question as above, but consider now the loss of the second and seventh acknowledgements sent by the
5. does the analysis above changes if the initial window is set to 16 kbytes instead of one segment ? 34. several mbytes have been sent on a tcp connection and it becomes idle for several minutes. discuss which
35. to operate reliably, a transport protocol that uses go-back-n (resp. selective repeat) cannot use a window that is larger than 2n − 1 (resp. 2n−1) segments. does this limitation affects tcp ? explain your answer. 36. consider the simple network shown in the ﬁgure below. in this network, the router between the client and the server can only store on each outgoing interface one packet in addition to the packet that it is currently transmitting. it discards all the packets that arrive while its buffer is full. assuming that you can neglect the transmission time of acknowledgements and that the server uses an initial window of one segment and has a retransmission timer set to 500 milliseconds, what is the time required to transmit 10 segments from the client to the server. does the performance increases if the server uses an initial window of 16 segments instead ?
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
in the example above, the mta running on mta.example.org opens a tcp connection to the smtp server on host smtp.example.com. the lines preﬁxed with s: (resp. c:) are the responses sent by the server (resp. the commands sent by the client). the server sends its greetings as soon as the tcp connection has been established. the client then sends the ehlo command with its fully qualiﬁed domain name. the server replies with reply-code 250 and sends its greetings. the smtp association can now be used to exchange an email. to send an email, the client must ﬁrst provide the address of the recipient with rcpt to:. then it uses the mail from: with the address of the sender. both the recipient and the sender are accepted by the server. the client can now issue the data command to start the transfer of the email message. after having received the 354 reply code, the client sends the headers and the body of its email message. the client indicates the end of the message by sending a line containing only the . (dot) character 15. the server conﬁrms that the email message has been queued for delivery or transmission with a reply code of 250. the client issues the quit command to close the session and the server conﬁrms with reply-code 221, before closing the tcp connection.
note: open smtp relays and spam since its creation in 1971, email has been a very useful tool that is used by many users to exchange lots of information. in the early days, all smtp servers were open and anyone could use them to forward emails towards their ﬁnal destination. unfortunately, over the years, some unscrupulous users have found ways to use email for marketing purposes or to send malware. the ﬁrst documented abuse of email for marketing purposes occurred in 1978 when a marketer who worked for a computer vendor sent a marketing email to many arpanet users. at that time, the arpanet could only be used for research purposes and this was an abuse of the acceptable use policy. unfortunately, given the extremely low cost of sending emails, the problem of unsolicited emails has not stopped. unsolicited emails are now called spam and a study carried out by enisa in 2009 reveals that 95% of email was spam and this number seems to continue to grow. this places a burden on the email infrastructure of internet service providers and large companies that need to process many useless messages. given the amount of spam messages, smtp servers are no longer open rfc 5068. several extensions to smtp have been developed in recent years to deal with this problem. for example, the smtp authentication scheme deﬁned in rfc 4954 can be used by an smtp server to authenticate a client. several techniques have also been proposed to allow smtp servers to authenticate the messages sent by their users rfc 4870 rfc 4871 .
when the ﬁrst versions of smtp were designed, the internet was composed of minicomputers that were used by an entire university department or research lab. these minicomputers were used by many users at the same time. email was mainly used to send messages from a user on a given host to another user on a remote host. at that time, smtp was the only protocol involved in the delivery of the emails as all hosts attached to the network were running an smtp server. on such hosts, an email destined to local users was delivered by placing the email in a special directory or ﬁle owned by the user. however, the introduction of personal computers in the 1980s, changed this environment. initially, users of these personal computers used applications such as telnet to open a remote session on the local minicomputer to read their email. this was not user-friendly. a better solution appeared with the development of user friendly email client applications on personal computers. several protocols were designed to allow these client applications to retrieve the email messages destined to a user from his/her server. two of these protocols became popular and are still used today. the post ofﬁce protocol (pop), deﬁned in rfc 1939, is the simplest one. it allows a client to download all the messages destined to a given user from his/her email server. we describe pop brieﬂy in this section. the second protocol is the internet message access protocol (imap), deﬁned in rfc 3501. imap is more powerful, but also more complex than pop. imap was designed to allow client applications to efﬁciently access in real-time to messages stored in various folders on servers. imap
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
solution were developed to solve this problem. the ﬁrst short term solution was the introduction of classless inter domain routing (cidr). a second short term solution was the network address translation (nat) mechanism, deﬁned in rfc 1631. nat allowed multiple hosts to share a single public ip address, it is explained in section middleboxes. however, in parallel with these short-term solutions, which have allowed the ipv4 internet to continue to be usable until now, the internet engineering task force started to work on developing a replacement for ipv4. this work started with an open call for proposals, outlined in rfc 1550. several groups responded to this call with proposals for a next generation internet protocol (ipng) :
the ietf decided to pursue the development of ipng based on the sipp proposal. as ip version 5 was already used by the experimental st-2 protocol deﬁned in rfc 1819, the successor of ip version 4 is ip version 6. the initial ip version 6 deﬁned in rfc 1752 was designed based on the following assumptions :
• ipv6 addresses are encoded as a 128 bits ﬁeld • the ipv6 header has a simple format that can easily be parsed by hardware devices • a host should be able to conﬁgure its ipv6 address automatically • security must be part of ipv6
note: the ipng address size when the work on ipng started, it was clear that 32 bits was too small to encode an ipng address and all proposals used longer addresses. however, there were many discussions about the most suitable address length. a ﬁrst approach, proposed by sip in rfc 1710, was to use 64 bit addresses. a 64 bits address space was 4 billion times larger than the ipv4 address space and, furthermore, from an implementation perspective, 64 bit cpus were being considered and 64 bit addresses would naturally ﬁt inside their registers. another approach was to use an existing address format. this was the tuba proposal ( rfc 1347) that reuses the iso clnp 20 bytes addresses. the 20 bytes addresses provided room for growth, but using iso clnp was not favored by the ietf partially due to political reasons, despite the fact that mature clnp implementations were already available. 128 bits appeared to be a reasonable compromise at that time.
the scalability of a network layer protocol heavily depends the experience of ipv6 spent a lot of effort deﬁning its addresson its addressing architecture. ing architecture rfc 3513. there are 340, 282, 366, 920, 938, 463, 463, 374, 607, 431, 768, 211, 456(3.4 × 1038) different ipv6 addresses. as the surface of the earth is about 510,072,000 km2, this implies that there are about 6.67 × 1023 ipv6 addresses per square meter on earth. compared to ipv4, which offers only 8 addresses per square kilometer, this is a signiﬁcant improvement on paper. ipv6 supports unicast, multicast and anycast addresses. as with ipv4, an ipv6 unicast address is used to identify one datalink-layer interface on a host. if a host has several datalink layer interfaces (e.g. an ethernet interface and a wifi interface), then it needs several ipv6 addresses. in general, an ipv6 unicast address is structured as shown in the ﬁgure below. an ipv6 unicast address is composed of three parts :
1. a global routing preﬁx that is assigned to the internet service provider that owns this block of addresses 2. a subnet identiﬁer that identiﬁes a customer of the isp 3. an interface identiﬁer that identiﬁes a particular interface on an endsystem
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
for example, a web hosting company that wants to spread the load over a pool of hundred servers can conﬁgure its nameservers to return different answers to different clients. if each answer has a small ttl, the clients will be forced to send dns queries regularly. the nameserver will reply to these queries by supplying the address of the less loaded server. the rdlength ﬁeld is the length of the rdata ﬁeld that contains the information of the type speciﬁed in the type ﬁeld. several types of dns rr are used in practice. the a type is used to encode the ipv4 address that corresponds to the speciﬁed name. the aaaa type is used to encode the ipv6 address that corresponds to the speciﬁed name. a ns record contains the name of the dns server that is responsible for a given domain. for example, a query for the a record associated to the www.ietf.org name returns the following answer. this answer contains several pieces of information. first, the name www.ietf.org is associated to ip address 64.170.98.32. second, the ietf.org domain is managed by six different nameservers. three of these nameservers are reachable via ipv4 and ipv6. two of them are not reachable via ipv6 and ns0.ietf.org is only reachable via ipv6. a query for the aaaa record associated to www.ietf.org returns 2001:1890:1112:1::20 and the same authority and additional sections. cname (or canonical names) are used to deﬁne aliases. for example www.example.com could be a cname for pc12.example.com that is the actual name of the server on which the web server for www.example.com runs.
note: reverse dns and in-addr.arpa the dns is mainly used to ﬁnd the ip address that correspond to a given name. however, it is sometimes useful to obtain the name that corresponds to an ip address. this done by using the ptr (pointer) rr. the rdata part of a ptr rr contains the name while the name part of the rr contains the ip address encoded in the in-addr.arpa domain. ipv4 addresses are encoded in the in-addr.arpa by reversing the four digits that compose the dotted decimal representation of the address. for example, consider ipv4 address 192.0.2.11. the hostname associated to this address can be found by requesting the ptr rr that corresponds to 11.2.0.192.in-addr.arpa. a similar solution is used to support ipv6 addresses, see rfc 3596.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
however, given the regular losses that we consider, the number of segments that are sent between two losses (i.e. during a cycle) is by deﬁnition equal to 1 p. the throughput (in bytes per second) of the tcp connection is equal to the number of segments transmitted divided by the duration of the cycle :
more detailed models and the analysis of simulations have shown that a ﬁrst order model of the tcp throughput when losses occur was t hroughput ≈ k×m ss rtt×√
• tcp connections with a small round-trip-time can achieve a higher throughput than tcp connections having a longer round-trip-time when losses occur. this implies that the tcp congestion control scheme is not completely fair since it favors the connections that have the shorter round-trip-time
• tcp connections that use a large mss can achieve a higher throughput that the tcp connections that use a shorter mss. this creates another source of unfairness between tcp connections. however, it should be noted that today most hosts are using almost the same mss, roughly 1460 bytes.
in general, the maximum throughput that can be achieved by a tcp connection depends on its maximum window size and the round-trip-time if there are no losses. if there are losses, it depends on the mss, the round-trip-time and the loss ratio.
note: the tcp congestion control zoo the ﬁrst tcp congestion control scheme was proposed by van jacobson in [jacobson1988]. in addition to writing the scientiﬁc paper, van jacobson also implemented the slow-start and congestion avoidance schemes in release 4.3 tahoe of the bsd unix distributed by the university of berkeley. later, he improved the congestion control by adding the fast retransmit and the fast recovery mechanisms in the reno release of 4.3 bsd unix. since then, many researchers have proposed, simulated and implemented modiﬁcations to the tcp congestion control scheme. some of these modiﬁcations are still used today, e.g. :
• tcp vegas, which uses changes in the round-trip-time to estimate congestion in order to avoid it [bop1994] • cubic, which was designed for high bandwidth links and is the default congestion control scheme in the
a search of the scientiﬁc literature will probably reveal more than 100 different variants of the tcp congestion control scheme. most of them have only been evaluated by simulations. however, the tcp implementation in the recent linux kernels supports several congestion control schemes and new ones can be easily added. we can expect that new tcp congestion control schemes will always continue to appear.
in this chapter, we have studied the transport layer. this layer provides two types of services to the application layer. the unreliable connectionless service is the simplest service offered to applications. on the internet, this is the service offered by udp. however, most applications prefer to use a reliable and connection-oriented transport service. we have shown that providing this service was much more complex than providing an unreliable service as the transport layer needs to recover from the errors that occur in the network layer. for this, transport layer protocols rely on several mechanisms. first, they use a handshake mechanism, such as the three-way handshake mechanism, to correctly establish a transport connection. once the connection has been established, transport entities exchange segments. each segment contains a sequence number, and the transport layer uses acknowledgements to conﬁrm the segments that have been correctly received. in addition, timers are used to recover from segment losses and sliding windows are used to avoid overﬂowing the buffers of the transport entities. finally,
2. perform the same experiment, but now send a syn segment towards port 7. this port is the default port for the discard service (see services(5)) launched by xinetd(8)). what segment does the server sends in reply ? what happens upon reception of this segment ? explain your answer.
12. the linux tcp/ip stack can be easily conﬁgured by using sysctl(8) to change kernel conﬁguration variables. see http://fasterdata.es.net/tcp-tuning/ip-sysctl-2.6.txt for a recent list of the sysctl variables on the linux tcp/ip stack. try to disable the selective acknowledgements and the rfc1323 timestamp and large window options and open a tcp connection on port 7 on the server by using :manpage:telnet‘(1)‘. check by using tcpdump(1) the effect of these kernel variables on the segments sent by the linux stack in netkit.
13. network administrators sometimes need to verify which networking daemons are active on a server. when logged on the server, several tools can be used to verify this. a ﬁrst solution is to use the netstat(8) command. this command allows you to extract various statistics from the networking stack on the linux kernel. for tcp, netstat can list all the active tcp connections with the state of their fsm. netstat supports the following options that could be useful during this exercises :
• -t requests information about the tcp connections • -n requests numeric output (by default, netstat sends dns queries to resolve ip addresses in hosts and uses /etc/services to convert port number in service names, -n is recommended on netkit machines)
• -e provides more information about the state of the tcp connections • -o provides information about the timers • -a provides information about all tcp connections, not only those in the established state
on the netkit lab, launch a daemon and start a tcp connection by using telnet(1) and use netstat(8) to verify the state of these connections. a second solution to determine which network daemons are running on a server is to use a tool like nmap(1). nmap(1) can be run remotely and thus can provide information about a host on which the system administrator cannot login. use tcpdump(1) to collect the segments sent by nmap(1) running on the client and explain how nmap(1) operates.
the emulated network is composed of three uml machines 32: a client, a server and a router. the client and the server are connected via the router. the client sends data to the server. the link between the router and the client is controlled by using the netem linux kernel module. this module allows us to insert additional delays, reduce the link bandwidth and insert random packet losses.
31 with an emulated network, it is more difﬁcult to obtain quantitative results than with a real network since all the emulated machines need to share the same cpu and memory. this creates interactions between the different emulated machines that do not happen in the real world. however, since the objective of this exercise is only to allow the students to understand the behaviour of the tcp congestion control mechanism, this is not a severe problem. about
see http://linuxgazette.net/135/pfeiffer.html and http://www.cs.helsinki.ﬁ/research/iwtcp/papers/linuxtcp.pdf or the source code of a recent linux. a description of some of the sysctl variables that allow to tune the tcp implementation in the linux kernel may be found in http://fasterdata.es.net/tcp-tuning/linux.html. for this exercise, we have conﬁgured the linux kernel to use the newreno scheme rfc 3782 that is very close to the ofﬁcial standard deﬁned in rfc 5681
the transport layer enables the applications to efﬁciently and reliably exchange data. transport layer entities expect to be able to send segment to any destination without having to understand anything about the underlying subnetwork technologies. many subnetwork technologies exist. most of them differ in subtle details (frame size, addressing, ...). the network layer is the glue between these subnetworks and the transport layer. it hides to the transport layer all the complexity of the underlying subnetworks and ensures that information can be exchanged between hosts connected to different types of subnetworks. in this chapter, we ﬁrst explain the principles of the network layer. these principles include the datagram and virtual circuit modes, the separation between the data plane and the control plane and the algorithms used by routing protocols. then, we explain, in more detail, the network layer in the internet, starting with ipv4 and ipv6 and then moving to the routing protocols (rip, ospf and bgp).
the main objective of the network layer is to allow endsystems, connected to different networks, to exchange information through intermediate systems called router. the unit of information in the network layer is called a packet.
before explaining the network layer in detail, it is useful to begin by analysing the service provided by the datalink layer. there are many variants of the datalink layer. some provide a connection-oriented service while others provide a connectionless service. in this section, we focus on connectionless datalink layer services as they are the most widely used. using a connection-oriented datalink layer causes some problems that are beyond the scope of this chapter. see rfc 3819 for a discussion on this topic. there are three main types of datalink layers. the simplest datalink layer is when there are only two communicating systems that are directly connected through the physical layer. such a datalink layer is used when there is a point-to-point link between the two communicating systems. the two systems can be endsystems or routers. ppp (point-to-point protocol), deﬁned in rfc 1661, is an example of such a point-to-point datalink layer. datalink layers exchange frames and a datalink frame sent by a datalink layer entity on the left is transmitted through the physical layer, so that it can reach the datalink layer entity on the right. point-to-point datalink layers can either
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
• 127.0.0.0/8, which is reserved for loopback addresses. each host implementing ipv4 must have a loopback interface (that is not attached to a datalink layer). by convention, ipv4 address 127.0.0.1 is assigned to this interface. this allows processes running on a host to use tcp/ip to contact other processes running on the same host. this can be very useful for testing purposes.
now that we have clariﬁed the allocation of ipv4 addresses and the utilisation of the longest preﬁx match to forward ipv4 packets, we can have a more detailed look at ipv4 by starting with the format of the ipv4 packets. the ipv4 packet format was deﬁned in rfc 791. apart from a few clariﬁcations and some backward compatible changes, the ipv4 packet format did not change signiﬁcantly since the publication of rfc 791. all ipv4 packets use the 20 bytes header shown below. some ipv4 packets contain an optional header extension that is described later.
• a 4 bits ip header length (ihl) that indicates the length of the ip header in 32 bits words. this ﬁeld allows ipv4 to use options if required, but as it is encoded as a 4 bits ﬁeld, the ipv4 header cannot be longer than 64 bytes.
• an 8 bits ds ﬁeld that is used for quality of service and whose usage is described later. • an 8 bits protocol ﬁeld that indicates the transport layer protocol that must process the packet’s payload at
• a 32 bits source address ﬁeld that contains the ipv4 address of the source host • a 32 bits destination address ﬁeld that contains the ipv4 address of the destination host • a 16 bits checksum that protects only the ipv4 header against transmission errors
the other ﬁelds of the ipv4 header are used for speciﬁc purposes. the ﬁrst is the 8 bits time to live (ttl) ﬁeld. this ﬁeld is used by ipv4 to avoid the risk of having an ipv4 packet caught in an inﬁnite loop due to a transient
the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
a router with two point-to-point interfaces and one loopback interface. when a point-to-point interface fails, it becomes unreachable and the router cannot receive anymore packets via this ip address. this is not the case for the loopback interface. it remains reachable as long as at least one of the router’s interfaces remains up. ibgp sessions are usually established using the router’s loopback addresses as endpoints. this allows the ibgp session and its underlying tcp connection to remain up even if physical interfaces fail on the routers.
now that routers can learn interdomain routes over ibgp and ebgp sessions, let us examine what happens when router r3 sends a packet destined to 194.100.1.234. r3 forwards this packet to r4. r4 uses an intradomain routing protocol and bgp. its bgp routing table contains the following longest preﬁx match :
this routes indicates that to forward a packet towards 194.100.0.0/23, r4 needs to forward the packet along the route towards 195.100.0.1. however, r4 is not directly connected to 195.100.0.1. r4 learned a route that matches this address thanks to its intradomain routing protocol that distributed the following routes :
to build its forwarding table, r4 must combine the routes learned from the intradomain routing protocol with the routes learned from bgp. thanks to its intradomain routing table, for each interdomain route r4 replaces the bgp nexthop with its shortest path computed by the intradomain routing protocol. in the ﬁgure above, r4 forwards packets to 194.100.0.0/23 via 195.100.0.10 to which it is directly connected via its north interface. r4 ‘s resulting forwarding table, which associates an outgoing interface for a directly connected preﬁx or a directly connected nexthop and an outgoing interface for preﬁxes learned via bgp, is shown below :
• 194.100.0.0/23 via 195.100.0.10 (north) • 195.100.0.0/30 via 195.100.0.10 (north) • 195.100.0.4/30 east • 195.100.0.8/30 north • 194.100.2.0/23 via 195.100.0.10 (north) • 194.100.4.0/23 west
there is thus a coupling between the interdomain and the intradomain routing tables. if the intradomain routes change, e.g. due to link failures or changes in link metrics, then the forwarding table must be updated on each router as the shortest path towards a bgp nexthop may have changed. the last point to be discussed before looking at the bgp decision process is that a network may contain routers that do not maintain any ebgp session. these routers can be stub routers attached to a single router in the network or core routers that reside on the path between two border routers that are using bgp as illustrated in the ﬁgure below. in the scenario above, router r2 needs to be able to forward a packet towards any destination in the 12.0.0.0/8 preﬁx inside as30. such a packet would need to be forwarded by router r5 since this router resides on the path between r2 and its bgp nexthop attached to r4. two solutions can be used to ensure that r2 is able to forward such interdomain packets :
• enable bgp on router r5 and include this router in the ibgp full-mesh. two ibgp sessions would be added in the ﬁgure above : r2-r5 and r4-r5. this solution works and is used by many ases. however, it forces all routers to have enough resources (cpu and memory) to run bgp and maintain a large forwarding table • encapsulate the interdomain packets sent through the as so that router r5 never needs to forward a packet whose destination is outside the local as. different encapsulation mechanisms exist. multiprotocol label switching (mpls) rfc 3031 and the layer 2 tunneling protocol (l2tp) rfc 3931 are frequently used in large domains, but a detailed explanation of these techniques is outside the scope of this section. the
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
share information on the web. they were also extended by other developers who contributed to new features. for example, ncsa added support for images in their mosaic browser that was eventually used to create netscape communications.
the ﬁrst components of the world wide web are the uniform resource identiﬁers (uri), deﬁned in rfc 3986. a uri is a character string that unambiguously identiﬁes a resource on the world wide web. here is a subset of the bnf for uris
= scheme ":" "//" authority path [ "?" query ] [ "#" fragment ] = alpha *( alpha / digit / "+" / "-" / "." ) = [ userinfo "@" ] host [ ":" port ] = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" )
= unreserved / pct-encoded / sub-delims / ":" / "@" = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" ) = "%" hexdig hexdig = alpha / digit / "-" / "." / "_" / "~" = gen-delims / sub-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@" = "!" / "$" / "&" / "’" / "(" / ")" / "*" / "+" / "," / ";" / "="
the ﬁrst component of a uri is its scheme. a scheme can be seen as a selector, indicating the meaning of the ﬁelds after it. in practice, the scheme often identiﬁes the application-layer protocol that must be used by the client to retrieve the document, but it is not always the case. some schemes do not imply a protocol at all and some do not indicate a retrievable document 17. the most frequent scheme is http that will be described later. a uri scheme can be deﬁned for almost any application layer protocol [#furilist]_. the characters ‘: and // follow the scheme of any uri. the second part of the uri is the authority. with retrievable uri, this includes the dns name or the ip address of the server where the document can be retrieved using the protocol speciﬁed via the scheme. this name can be preceded by some information about the user (e.g. a user name) who is requesting the information. earlier deﬁnitions of the uri allowed the speciﬁcation of a user name and a password before the @ character ( rfc 1738), but this is now deprecated as placing a password inside a uri is insecure. the host name can be followed by the semicolon character and a port number. a default port number is deﬁned for some protocols and the port number should only be included in the uri if a non-default port number is used (for other protocols, techniques like service dns records are used). the third part of the uri is the path to the document. this path is structured as ﬁlenames on a unix host (but it does not imply that the ﬁles are indeed stored this way on the server). if the path is not speciﬁed, the server will return a default document. the last two optional parts of the uri are used to provide a query and indicate a speciﬁc part (e.g. a section in an article) of the requested document. sample uris are shown below.
http://tools.ietf.org/html/rfc3986.html mailto:infobot@example.com?subject=current-issue http://docs.python.org/library/basehttpserver.html?highlight=http#basehttpserver.basehttprequesthandler telnet://[2001:6a8:3080:3::2]:80/ ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
the ﬁrst uri corresponds to a document named rfc3986.html that is stored on the server named tools.ietf.org and can be accessed by using the http protocol on its default port. the second uri corresponds to an email message, with subject current-issue, that will be sent to user infobot in domain example.com. the mailto: uri scheme is deﬁned in rfc 6068. the third uri references the portion basehttpserver.basehttprequesthandler of the document basehttpserver.html that is stored in the library directory on server docs.python.org. this document can be retrieved by using the http protocol. the query highlight=http is associated to this uri. the fourth example is a server that operates the telnet protocol, uses ipv6 address 2001:6a8:3080:3::2 and is reachable on port 80. the last uri is somewhat special. most users will assume that it corresponds to a document stored on the cnn.example.com
17 an example of a non-retrievable uri is urn:isbn:0-380-81593-1 which is an unique identiﬁer for a book, through the urn scheme (see rfc 3187). of course, any uri can be make retrievable via a dedicated server or a new protocol but this one has no explicit protocol. same thing for the scheme tag (see rfc 4151), often used in web syndication (see rfc 4287 about the atom syndication format). even when the scheme is retrievable (for instance with http‘), it is often used only as an identiﬁer, not as a way to get a resource. see http://norman.walsh.name/2006/07/25/namesandaddresses for a good explanation.
the server replies with the requested style sheet and maintains the persistent connection. note that the server only accepts 99 remaining http requests over this persistent connection.
http/1.1 200 ok date: fri, 19 mar 2010 09:23:37 gmt server: apache/2.0.63 (freebsd) php/5.2.12 with suhosin-patch last-modified: mon, 10 apr 2006 05:06:39 gmt content-length: 2235 keep-alive: timeout=15, max=99 connection: keep-alive content-type: text/css
then the client automatically requests the web server’s icon 18 , that could be displayed by the browser. this server does not contain such uri and thus replies with a 404 http status. however, the underlying tcp connection is not closed immediately.
get /favicon.ico http/1.1 host: www.kame.net referer: http://www.kame.net/ user-agent: mozilla/5.0 (macintosh; u; intel mac os x 10_6_2; en-us) connection: keep-alive
http/1.1 404 not found date: fri, 19 mar 2010 09:23:40 gmt server: apache/2.0.63 (freebsd) php/5.2.12 with suhosin-patch content-length: 318 keep-alive: timeout=15, max=98 connection: keep-alive content-type: text/html; charset=iso-8859-1
as illustrated above, a client can send several http requests over the same persistent tcp connection. however, it is important to note that all of these http requests are considered to be independent by the server. each http request must be self-contained. this implies that each request must include all the header lines that are required by the server to understand the request. the independence of these requests is one of the important design choices of http. as a consequence of this design choice, when a server processes a http request, it doesn’t’ use any other information than what is contained in the request itself. this explains why the client adds its user-agent: header in all of the http requests it sends over the persistent tcp connection. however, in practice, some servers want to provide content tuned for each user. for example, some servers can provide information in several languages or other servers want to provide advertisements that are targeted to different types of users. to do this, servers need to maintain some information about the preferences of each user and use this information to produce content matching the user’s preferences. http contains several mechanisms that enable to solve this problem. we discuss three of them below. a ﬁrst solution is to force the users to be authenticated. this was the solution used by ftp to control the ﬁles that each user could access. initially, user names and passwords could be included inside uris rfc 1738. however, placing passwords in the clear in a potentially publicly visible uri is completely insecure and this usage has now been deprecated rfc 3986. http supports several extension headers rfc 2617 that can be used by a server to request the authentication of the client by providing his/her credentials. however, user names and passwords have not been popular on web servers as they force human users to remember one user name and one password per server. remembering a password is acceptable when a user needs to access protected content, but users will not accept the need for a user name and password only to receive targeted advertisements from the web sites that they visit. a second solution to allow servers to tune that content to the needs and capabilities of the user is to rely on the different types of accept-* http headers. for example, the accept-language: can be used by the client to
18 favorite icons are small icons that are used to represent web servers in the toolbar of internet browsers. microsoft added this feature in their browsers without taking into account the w3c standards. see http://www.w3.org/2005/10/howto-favicon for a discussion on how to cleanly support such favorite icons.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
chosen by the client. thanks to this identiﬁer, the client can match the received answer with the question that it sent. the qr ﬂag is set to 0 in dns queries and 1 in dns answers. the opcode is used to specify the type of query. for instance, a standard query is when a client sends a name and the server returns the corresponding data and an update request is when the client sends a name and new data and the server then updates its database. the aa bit is set when the server that sent the response has authority for the domain name found in the question section. in the original dns deployments, two types of servers were considered : authoritative servers and nonauthoritative servers. the authoritative servers are managed by the system administrators responsible for a given domain. they always store the most recent information about a domain. non-authoritative servers are servers or resolvers that store dns information about external domains without being managed by the owners of a domain. they may thus provide answers that are out of date. from a security point of view, the authoritative bit is not an absolute indication about the validity of an answer. securing the domain name system is a complex problem that was only addressed satisfactorily recently by the utilisation of cryptographic signatures in the dnssec extensions to dns described in rfc 4033. however, these extensions are outside the scope of this chapter. the rd (recursion desired) bit is set by a client when it sends a query to a resolver. such a query is said to be recursive because the resolver will recurse through the dns hierarchy to retrieve the answer on behalf of the client. in the past, all resolvers were conﬁgured to perform recursive queries on behalf of any internet host. however, this exposes the resolvers to several security risks. the simplest one is that the resolver could become overloaded by having too many recursive queries to process. as of this writing, most resolvers 10 only allow recursive queries from clients belonging to their company or network and discard all other recursive queries. the ra bit indicates whether the server supports recursion. the rcode is used to distinguish between different types of errors. see rfc 1035 for additional details. the last four ﬁelds indicate the size of the question, answer, authority and additional sections of the dns message. the last four sections of the dns message contain resource records (rr). all rrs have the same top level format shown in the ﬁgure below. in a resource record (rr), the name indicates the name of the node to which this resource record pertains. the two bytes type ﬁeld indicate the type of resource record. the class ﬁeld was used to support the utilisation of the dns in other environments than the internet. the ttl ﬁeld indicates the lifetime of the resource record in seconds. this ﬁeld is set by the server that returns an answer and indicates for how long a client or a resolver can store the resource record inside its cache. a long ttl indicates a stable rr. some companies use short ttl values for mobile hosts and also for popular servers.
[rfc2988] paxson, v. and allman, m., computing tcp’s retransmission timer, rfc 2988, nov. 2000 [rfc2991] thaler, d. and hopps, c., multipath issues in unicast and multicast next-hop selection, rfc 2991,
[rfc3243] carpenter, b. and brim, s., middleboxes: taxonomy and issues, rfc 3234, feb. 2002 [rfc3235] senie, d., network address translator (nat)-friendly application design guidelines, rfc 3235,
conﬁguration protocol for ipv6 (dhcpv6), rfc 3315, july 2003 [rfc3330] iana, special-use ipv4 addresses, rfc 3330, sept. 2002 [rfc3360] floyd, s., inappropriate tcp resets considered harmful, rfc 3360, aug. 2002 [rfc3390] allman, m. and floyd, s. and partridge, c., increasing tcp’s initial window, rfc 3390, oct. 2002 [rfc3490] faltstrom, p. and hoffman, p. and costello, a., internationalizing domain names in applications
[rfc3501] crispin, m., internet message access protocol - version 4 rev1, rfc 3501, march 2003 [rfc3513] hinden, r. and deering, s., internet protocol version 6 (ipv6) addressing architecture, rfc 3513,
[rfc3819] karn, p. and bormann, c. and fairhurst, g. and grossman, d. and ludwig, r. and mahdavi, j. and montenegro, g. and touch, j. and wood, l., advice for internet subnetwork designers, rfc 3819, july 2004 [rfc3828] larzon, l-a. and degermark, m. and pink, s. and jonsson, l-e. and fairhurst, g., the lightweight
[rfc3972] aura, t., cryptographically generated addresses (cga), rfc 3972, march 2005 [rfc3986] berners-lee, t. and fielding, r. and masinter, l., uniform resource identiﬁer (uri): generic syn-
share information on the web. they were also extended by other developers who contributed to new features. for example, ncsa added support for images in their mosaic browser that was eventually used to create netscape communications.
the ﬁrst components of the world wide web are the uniform resource identiﬁers (uri), deﬁned in rfc 3986. a uri is a character string that unambiguously identiﬁes a resource on the world wide web. here is a subset of the bnf for uris
= scheme ":" "//" authority path [ "?" query ] [ "#" fragment ] = alpha *( alpha / digit / "+" / "-" / "." ) = [ userinfo "@" ] host [ ":" port ] = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" )
= unreserved / pct-encoded / sub-delims / ":" / "@" = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" ) = "%" hexdig hexdig = alpha / digit / "-" / "." / "_" / "~" = gen-delims / sub-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@" = "!" / "$" / "&" / "’" / "(" / ")" / "*" / "+" / "," / ";" / "="
the ﬁrst component of a uri is its scheme. a scheme can be seen as a selector, indicating the meaning of the ﬁelds after it. in practice, the scheme often identiﬁes the application-layer protocol that must be used by the client to retrieve the document, but it is not always the case. some schemes do not imply a protocol at all and some do not indicate a retrievable document 17. the most frequent scheme is http that will be described later. a uri scheme can be deﬁned for almost any application layer protocol [#furilist]_. the characters ‘: and // follow the scheme of any uri. the second part of the uri is the authority. with retrievable uri, this includes the dns name or the ip address of the server where the document can be retrieved using the protocol speciﬁed via the scheme. this name can be preceded by some information about the user (e.g. a user name) who is requesting the information. earlier deﬁnitions of the uri allowed the speciﬁcation of a user name and a password before the @ character ( rfc 1738), but this is now deprecated as placing a password inside a uri is insecure. the host name can be followed by the semicolon character and a port number. a default port number is deﬁned for some protocols and the port number should only be included in the uri if a non-default port number is used (for other protocols, techniques like service dns records are used). the third part of the uri is the path to the document. this path is structured as ﬁlenames on a unix host (but it does not imply that the ﬁles are indeed stored this way on the server). if the path is not speciﬁed, the server will return a default document. the last two optional parts of the uri are used to provide a query and indicate a speciﬁc part (e.g. a section in an article) of the requested document. sample uris are shown below.
http://tools.ietf.org/html/rfc3986.html mailto:infobot@example.com?subject=current-issue http://docs.python.org/library/basehttpserver.html?highlight=http#basehttpserver.basehttprequesthandler telnet://[2001:6a8:3080:3::2]:80/ ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
the ﬁrst uri corresponds to a document named rfc3986.html that is stored on the server named tools.ietf.org and can be accessed by using the http protocol on its default port. the second uri corresponds to an email message, with subject current-issue, that will be sent to user infobot in domain example.com. the mailto: uri scheme is deﬁned in rfc 6068. the third uri references the portion basehttpserver.basehttprequesthandler of the document basehttpserver.html that is stored in the library directory on server docs.python.org. this document can be retrieved by using the http protocol. the query highlight=http is associated to this uri. the fourth example is a server that operates the telnet protocol, uses ipv6 address 2001:6a8:3080:3::2 and is reachable on port 80. the last uri is somewhat special. most users will assume that it corresponds to a document stored on the cnn.example.com
17 an example of a non-retrievable uri is urn:isbn:0-380-81593-1 which is an unique identiﬁer for a book, through the urn scheme (see rfc 3187). of course, any uri can be make retrievable via a dedicated server or a new protocol but this one has no explicit protocol. same thing for the scheme tag (see rfc 4151), often used in web syndication (see rfc 4287 about the atom syndication format). even when the scheme is retrievable (for instance with http‘), it is often used only as an identiﬁer, not as a way to get a resource. see http://norman.walsh.name/2006/07/25/namesandaddresses for a good explanation.
the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
many ftp clients offer a user interface similar to a unix shell and allow the client to browse the ﬁle system on the server and to send and retrieve ﬁles. ftp servers can be conﬁgured in two modes :
ftp was very popular in the 1990s and early 2000s, but today it has mostly been superseded by more recent protocols. authenticated access to ﬁles is mainly done by using the secure shell (ssh) protocol deﬁned in rfc 4251 and supported by clients such as scp or sftp. nowadays, anonymous access is mainly provided by web protocols. in the late 1980s, high energy physicists working at cern had to efﬁciently exchange documents about their ongoing and planned experiments. tim berners-lee evaluated several of the documents sharing techniques that were available at that time [b1989]. as none of the existing solutions met cern’s requirements, they choose to develop a completely new document sharing system. this system was initially called the mesh, but was quickly renamed the world wide web. the starting point for the world wide web are hypertext documents. an hypertext document is a document that contains references (hyperlinks) to other documents that the reader can immediately access. hypertext was not invented for the world wide web. the idea of hypertext documents was proposed in 1945 [bush1945] and the ﬁrst experiments were done during the 1960s [nelson1965] [myers1998] . compared to the hypertext documents that were used in the late 1980s, the main innovation introduced by the world wide web was to allow hyperlinks to reference documents stored on remote machines.
a document sharing system such as the world wide web is composed of three important parts. 1. a standardised addressing scheme that allows unambiguous identiﬁcation of documents 2. a standard document format : the hypertext markup language 3. a standardised protocol that facilitates efﬁcient retrieval of documents stored on a server
note: open standards and open implementations open standards have, and are still playing a key role in the success of the world wide web as we know it today. without open standards, the world wide web would never have reached its current size. in addition to open standards, another important factor for the success of the web was the availability of open and efﬁcient implementations of these standards. when cern started to work on the web, their objective was to build a running system that could be used by physicists. they developed open-source implementations of the ﬁrst web servers and web clients. these open-source implementations were powerful and could be used as is, by institutions willing to
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
in the previous sections, we have explained the operation of bgp routers. compared to intradomain routing protocols, a key feature of bgp is its ability to support interdomain routing policies that are deﬁned by each domain as its import and export ﬁlters and ranking process. a domain can deﬁne its own routing policies and router vendors have implemented many conﬁguration tweaks to support complex routing policies. however, the routing policy chosen by a domain may interfere with the routing policy chosen by another domain. to understand this issue, let us ﬁrst consider the simple internetwork shown below.
in this internetwork, we focus on the route towards 1.0.0.0/8 which is advertised by as1. let us also assume that as3 (resp. as4) prefers, e.g. for economic reasons, a route learned from as4 (as3) over a route learned from as1. when as1 sends u(1.0.0.0/8,as1) to as3 and as4, three sequences of exchanges of bgp messages are possible : 1. as3 sends ﬁrst u(1.0.0.0/8,as3:as1) to as4. as4 has learned two routes towards 1.0.0.0/8. it runs its bgp
3. as3 sends u(1.0.0.0/8,as3:as1) to as4 and, at the same time, as4 sends u(1.0.0.0/8,as4:as1). as3 prefers the route via as4 and thus sends w(1.0.0.0/8) to as4. in the mean time, as4 prefers the route via as3 and thus sends w(1.0.0.0/8) to as3. upon reception of the bgp withdraws, as3 and as4 only know the direct route towards 1.0.0.0/8. as3 (resp. as4) sends u(1.0.0.0/8,as3:as1) (resp. u(1.0.0.0/8,as4:as1)) to as4 (resp. as3). as3 and as4 could in theory continue to exchange bgp messages for ever. in practice, one of them sends one message faster than the other and bgp converges.
the example above has shown that the routes selected by bgp routers may sometimes depend on the ordering of the bgp messages that are exchanged. other similar scenarios may be found in rfc 4264. from an operational perspective, the above conﬁguration is annoying since the network operators cannot easily predict which paths are chosen. unfortunately, there are even more annoying bgp conﬁgurations. for example, let us consider the conﬁguration below which is often named bad gadget [gw1999] in this internetwork, there are four ases. as0 advertises one route towards one preﬁx and we only analyse the routes towards this preﬁx. the routing preferences of as1, as3 and as4 are the following :
• as1 prefers the path as3:as0 over all other paths • as3 prefers the path as4:as0 over all other paths • as4 prefers the path as1:as0 over all other paths
as0 sends u(p,as0) to as1, as3 and as4. as this is the only route known by as1, as3 and as4 towards p, they all select the direct path. let us now consider one possible exchange of bgp messages :
preferred paths for as31. as4:as1 2. as1preferred paths for as41. as3:as12. as11.0.0.0/8as1as1as3as3as4as4saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
in practice, to establish a bgp session between routers r1 and r2 in the ﬁgure above, the network administrator of as3 must ﬁrst conﬁgure on r1 the ip address of r2 on the r1-r2 link and the as number of r2. router r1 then regularly tries to establish the bgp session with r2. r2 only agrees to establish the bgp session with r1 once it has been conﬁgured with the ip address of r1 and its as number. for security reasons, a router never establishes a bgp session that has not been manually conﬁgured on the router. the bgp protocol rfc 4271 deﬁnes several types of messages that can be exchanged over a bgp session :
• open : this message is sent as soon as the tcp connection between the two routers has been established. it initialises the bgp session and allows the negotiation of some options. details about this message may be found in rfc 4271
• notification : this message is used to terminate a bgp session, usually because an error has been detected by the bgp peer. a router that sends or receives a notification message immediately shutdowns the corresponding bgp session.
• keepalive : this message is used to ensure a regular exchange of messages on the bgp session, even when no route changes. when a bgp router has not sent an update message during the last 30 seconds, it shall send a keepalive message to conﬁrm to the other peer that it is still up. if a peer does not receive any bgp message during a period of 90 seconds 32, the bgp session is considered to be down and all the routes learned over this session are withdrawn.
as explained earlier, bgp relies on incremental updates. this implies that when a bgp session starts, each router ﬁrst sends bgp update messages to advertise to the other peer all the exportable routes that it knows. once all these routes have been advertised, the bgp router only sends bgp update messages about a preﬁx if the route is new, one of its attributes has changed or the route became unreachable and must be withdrawn. the bgp update message allows bgp routers to efﬁciently exchange such information while minimising the number of bytes exchanged. each update message contains :
• a list of ip preﬁxes that are withdrawn • a list of ip preﬁxes that are (re-)advertised • the set of attributes (e.g. as-path) associated to the advertised preﬁxes
in the remainder of this chapter, and although all routing information is exchanged using bgp update messages, we assume for simplicity that a bgp message contains only information about one preﬁx and we use the words :
• withdraw message to indicate a bgp update message containing one route that is withdrawn • update message to indicate a bgp update containing a new or updated route towards one destination
32 90 seconds is the default delay recommended by rfc 4271. however, two bgp peers can negotiate a different timer during the establishment of their bgp session. using a too small interval to detect bgp session failures is not recommended. bfd [kw2009] can be used to replace bgp’s keepalive mechanism if fast detection of interdomain link failures is required.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
share information on the web. they were also extended by other developers who contributed to new features. for example, ncsa added support for images in their mosaic browser that was eventually used to create netscape communications.
the ﬁrst components of the world wide web are the uniform resource identiﬁers (uri), deﬁned in rfc 3986. a uri is a character string that unambiguously identiﬁes a resource on the world wide web. here is a subset of the bnf for uris
= scheme ":" "//" authority path [ "?" query ] [ "#" fragment ] = alpha *( alpha / digit / "+" / "-" / "." ) = [ userinfo "@" ] host [ ":" port ] = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" )
= unreserved / pct-encoded / sub-delims / ":" / "@" = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" ) = "%" hexdig hexdig = alpha / digit / "-" / "." / "_" / "~" = gen-delims / sub-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@" = "!" / "$" / "&" / "’" / "(" / ")" / "*" / "+" / "," / ";" / "="
the ﬁrst component of a uri is its scheme. a scheme can be seen as a selector, indicating the meaning of the ﬁelds after it. in practice, the scheme often identiﬁes the application-layer protocol that must be used by the client to retrieve the document, but it is not always the case. some schemes do not imply a protocol at all and some do not indicate a retrievable document 17. the most frequent scheme is http that will be described later. a uri scheme can be deﬁned for almost any application layer protocol [#furilist]_. the characters ‘: and // follow the scheme of any uri. the second part of the uri is the authority. with retrievable uri, this includes the dns name or the ip address of the server where the document can be retrieved using the protocol speciﬁed via the scheme. this name can be preceded by some information about the user (e.g. a user name) who is requesting the information. earlier deﬁnitions of the uri allowed the speciﬁcation of a user name and a password before the @ character ( rfc 1738), but this is now deprecated as placing a password inside a uri is insecure. the host name can be followed by the semicolon character and a port number. a default port number is deﬁned for some protocols and the port number should only be included in the uri if a non-default port number is used (for other protocols, techniques like service dns records are used). the third part of the uri is the path to the document. this path is structured as ﬁlenames on a unix host (but it does not imply that the ﬁles are indeed stored this way on the server). if the path is not speciﬁed, the server will return a default document. the last two optional parts of the uri are used to provide a query and indicate a speciﬁc part (e.g. a section in an article) of the requested document. sample uris are shown below.
http://tools.ietf.org/html/rfc3986.html mailto:infobot@example.com?subject=current-issue http://docs.python.org/library/basehttpserver.html?highlight=http#basehttpserver.basehttprequesthandler telnet://[2001:6a8:3080:3::2]:80/ ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
the ﬁrst uri corresponds to a document named rfc3986.html that is stored on the server named tools.ietf.org and can be accessed by using the http protocol on its default port. the second uri corresponds to an email message, with subject current-issue, that will be sent to user infobot in domain example.com. the mailto: uri scheme is deﬁned in rfc 6068. the third uri references the portion basehttpserver.basehttprequesthandler of the document basehttpserver.html that is stored in the library directory on server docs.python.org. this document can be retrieved by using the http protocol. the query highlight=http is associated to this uri. the fourth example is a server that operates the telnet protocol, uses ipv6 address 2001:6a8:3080:3::2 and is reachable on port 80. the last uri is somewhat special. most users will assume that it corresponds to a document stored on the cnn.example.com
17 an example of a non-retrievable uri is urn:isbn:0-380-81593-1 which is an unique identiﬁer for a book, through the urn scheme (see rfc 3187). of course, any uri can be make retrievable via a dedicated server or a new protocol but this one has no explicit protocol. same thing for the scheme tag (see rfc 4151), often used in web syndication (see rfc 4287 about the atom syndication format). even when the scheme is retrievable (for instance with http‘), it is often used only as an identiﬁer, not as a way to get a resource. see http://norman.walsh.name/2006/07/25/namesandaddresses for a good explanation.
the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
reassemble all fragments of the packet upon reception of the last fragment. when a host receives the ﬁrst fragment of an ipv6 packet, it cannot know a priori the length of the entire ipv6 packet. the ﬁgure below provides an example of a fragmented ipv6 packet containing a udp segment. the next header type reserved for the ipv6 fragmentation option is 44.
finally, the last type of ipv6 options is the encaspulating security payload (esp) deﬁned in rfc 4303 and the authentication header (ah) deﬁned in rfc 4302. these two headers are used by ipsec rfc 4301. they are discussed in another chapter.
icmpv6 deﬁned in rfc 4443 is the companion protocol for ipv6 as icmpv4 is the companion protocol for ipv4. icmpv6 is used by routers and hosts to report problems when processing ipv6 packets. however, as we will see in chapter the datalink layer and the local area networks, icmpv6 is also used when auto-conﬁguring addresses. the traditional utilisation of icmpv6 is similar to icmpv4. icmpv6 messages are carried inside ipv6 packets (the next header ﬁeld for icmpv6 is 58). each icmp message contains an 8 bits header with a type ﬁeld, a code ﬁeld and a 16 bits checksum computed over the entire icmpv6 message. the message body contains a copy of the ipv6 packet in error.
icmpv6 speciﬁes two classes of messages : error messages that indicate a problem in handling a packet and informational messages. four types of error messages are deﬁned in rfc 4443 :
• 1 [destination unreachable. such an icmpv6 message is sent when the destination address of a packet is unreachable. the code ﬁeld of the icmp header contains additional information about the type of unreachability. the following codes are speciﬁed in rfc 4443]
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
reassemble all fragments of the packet upon reception of the last fragment. when a host receives the ﬁrst fragment of an ipv6 packet, it cannot know a priori the length of the entire ipv6 packet. the ﬁgure below provides an example of a fragmented ipv6 packet containing a udp segment. the next header type reserved for the ipv6 fragmentation option is 44.
finally, the last type of ipv6 options is the encaspulating security payload (esp) deﬁned in rfc 4303 and the authentication header (ah) deﬁned in rfc 4302. these two headers are used by ipsec rfc 4301. they are discussed in another chapter.
icmpv6 deﬁned in rfc 4443 is the companion protocol for ipv6 as icmpv4 is the companion protocol for ipv4. icmpv6 is used by routers and hosts to report problems when processing ipv6 packets. however, as we will see in chapter the datalink layer and the local area networks, icmpv6 is also used when auto-conﬁguring addresses. the traditional utilisation of icmpv6 is similar to icmpv4. icmpv6 messages are carried inside ipv6 packets (the next header ﬁeld for icmpv6 is 58). each icmp message contains an 8 bits header with a type ﬁeld, a code ﬁeld and a 16 bits checksum computed over the entire icmpv6 message. the message body contains a copy of the ipv6 packet in error.
icmpv6 speciﬁes two classes of messages : error messages that indicate a problem in handling a packet and informational messages. four types of error messages are deﬁned in rfc 4443 :
• 1 [destination unreachable. such an icmpv6 message is sent when the destination address of a packet is unreachable. the code ﬁeld of the icmp header contains additional information about the type of unreachability. the following codes are speciﬁed in rfc 4443]
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
reassemble all fragments of the packet upon reception of the last fragment. when a host receives the ﬁrst fragment of an ipv6 packet, it cannot know a priori the length of the entire ipv6 packet. the ﬁgure below provides an example of a fragmented ipv6 packet containing a udp segment. the next header type reserved for the ipv6 fragmentation option is 44.
finally, the last type of ipv6 options is the encaspulating security payload (esp) deﬁned in rfc 4303 and the authentication header (ah) deﬁned in rfc 4302. these two headers are used by ipsec rfc 4301. they are discussed in another chapter.
icmpv6 deﬁned in rfc 4443 is the companion protocol for ipv6 as icmpv4 is the companion protocol for ipv4. icmpv6 is used by routers and hosts to report problems when processing ipv6 packets. however, as we will see in chapter the datalink layer and the local area networks, icmpv6 is also used when auto-conﬁguring addresses. the traditional utilisation of icmpv6 is similar to icmpv4. icmpv6 messages are carried inside ipv6 packets (the next header ﬁeld for icmpv6 is 58). each icmp message contains an 8 bits header with a type ﬁeld, a code ﬁeld and a 16 bits checksum computed over the entire icmpv6 message. the message body contains a copy of the ipv6 packet in error.
icmpv6 speciﬁes two classes of messages : error messages that indicate a problem in handling a packet and informational messages. four types of error messages are deﬁned in rfc 4443 :
• 1 [destination unreachable. such an icmpv6 message is sent when the destination address of a packet is unreachable. the code ﬁeld of the icmp header contains additional information about the type of unreachability. the following codes are speciﬁed in rfc 4443]
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
reassemble all fragments of the packet upon reception of the last fragment. when a host receives the ﬁrst fragment of an ipv6 packet, it cannot know a priori the length of the entire ipv6 packet. the ﬁgure below provides an example of a fragmented ipv6 packet containing a udp segment. the next header type reserved for the ipv6 fragmentation option is 44.
finally, the last type of ipv6 options is the encaspulating security payload (esp) deﬁned in rfc 4303 and the authentication header (ah) deﬁned in rfc 4302. these two headers are used by ipsec rfc 4301. they are discussed in another chapter.
icmpv6 deﬁned in rfc 4443 is the companion protocol for ipv6 as icmpv4 is the companion protocol for ipv4. icmpv6 is used by routers and hosts to report problems when processing ipv6 packets. however, as we will see in chapter the datalink layer and the local area networks, icmpv6 is also used when auto-conﬁguring addresses. the traditional utilisation of icmpv6 is similar to icmpv4. icmpv6 messages are carried inside ipv6 packets (the next header ﬁeld for icmpv6 is 58). each icmp message contains an 8 bits header with a type ﬁeld, a code ﬁeld and a 16 bits checksum computed over the entire icmpv6 message. the message body contains a copy of the ipv6 packet in error.
icmpv6 speciﬁes two classes of messages : error messages that indicate a problem in handling a packet and informational messages. four types of error messages are deﬁned in rfc 4443 :
• 1 [destination unreachable. such an icmpv6 message is sent when the destination address of a packet is unreachable. the code ﬁeld of the icmp header contains additional information about the type of unreachability. the following codes are speciﬁed in rfc 4443]
• 2 : packet too big. the router that was to send the icmpv6 message received an ipv6 packet that is larger than the mtu of the outgoing link. the icmpv6 message contains the mtu of this link in bytes. this allows the sending host to implement path mtu discovery rfc 1981
• 3 : time exceeded. this error message can be sent either by a router or by a host. a router would set code to 0 to report the reception of a packet whose hop limit reached 0. a host would set code to 1 to report that it was unable to reassemble received ipv6 fragments.
• 4 : parameter problem. this icmpv6 message is used to report either the reception of an ipv6 packet with an erroneous header ﬁeld (type 0) or an unknown next header or ip option (types 1 and 2). in this case, the message body contains the erroneous ipv6 packet and the ﬁrst 32 bits of the message body contain a pointer to the error.
two types of informational icmpv6 messages are deﬁned in rfc 4443 : echo request and echo reply, which are used to test the reachability of a destination by using ping6(8). icmpv6 also allows the discovery of the path between a source and a destination by using traceroute6(8). the output below shows a traceroute between a host at uclouvain and one of the main ietf servers. note that this ipv6 path is different than the ipv4 path that was described earlier although the two traceroutes were performed at the same time.
2001:6a8:3080:2::1 13.821 ms 2001:6a8:3000:8000::1 0.651 ms 10ge.cr2.bruvil.belnet.net 3.402 ms 10ge.cr2.brueve.belnet.net 3.668 ms 10ge.cr2.brueve.belnet.net belnet.rt1.ams.nl.geant2.net 10.598 ms so-7-0-0.rt2.cop.dk.geant2.net kbn-ipv6-b1.ipv6.telia.net 21.078 ms s-ipv6-b1-link.ipv6.telia.net 31.312 ms s-ipv6-b1-link.ipv6.telia.net 61.986 ms
note: rate limitation of icmp messages high-end hardware based routers use special purpose chips on their interfaces to forward ipv6 packets at line rate. these chips are optimised to process correct ip packets. they are not able to create icmp messages at line rate. when such a chip receives an ip packet that triggers an icmp message, it interrupts the main cpu of the router and the software running on this cpu processes the packet. this cpu is much slower than the hardware acceleration found on the interfaces [gill2004]. it would be overloaded if it had to process ip packets at line rate and generate one icmp message for each received packet. to protect this cpu, high-end routers limit the rate at which the hardware can interrupt the main cpu and thus the rate at which icmp messages can be generated. this implies that not all erroneous ip packets cause the transmission of an icmp message. the risk of overloading the main cpu of the router is also the reason why using hop-by-hop ipv6 options, including the router alter option is discouraged 20.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
hot potato routing allows as1 to minimise the cost of forwarding packets towards as2. however, there are situations where this is not desirable. for example, assume that as1 and as2 are domains with routers on both the east and the west coast of the us. in these two domains, the high metric associated to links r6-r8 and r0-r2 correspond to the cost of forwarding a packet across the usa. if as2 is a customer that pays as1, it would prefer to receive the packets destined to 1.0.0.0/8 via the r2-r6 link instead of the r7-r3 link. this is the objective of cold potato routing. cold potato routing is implemented using the multi-exit discriminator (med) attribute. this attribute is an optional bgp attribute that may be set 37 by border routers when advertising a bgp route over an ebgp session. the med attribute is usually used to indicate over an ebgp session the cost to reach the bgp nexthop for the advertised route. the med attribute is set by the router that advertises a route over an ebgp session. in the example above, router r2 sends u(1.0.0.0/8,r2,as2,med=1) while r3 sends u(1.0.0.0/8,r3,as2,med=98). assume that the bgp session r7-3 is the ﬁrst to be established. r7 sends u(1.0.0.0/8,r3,as2,med=98) to both r8 and r6. at this point, all routers inside as1 send the packets towards 1.0.0.0/8 via r7-r3. then, the r6r2 bgp session is established and router r6 receives u(1.0.0.0/8,r2,as2,med=1). router r6 runs its decision process for destination 1.0.0.0/8 and selects the route via r2 as its chosen route to reach this preﬁx since this is the only route that it knows. r6 sends u(1.0.0.0/8,r2,as2,med=1) to routers r8 and r7. they both run their decision process and prefer the route advertised by r6, as it contains the smallest med. now, all routers inside as1 forward the packets to 1.0.0.0/8 via link r6-r2 as expected by as2. as router r7 no longer uses the bgp route learned via r3, it must stop advertising it over ibgp sessions and sends w(1.0.0.0/8) over its ibgp sessions with r6 and r8. however, router r7 still keeps the route learned from r3 inside its adj-rib-in. if the r6-r2 link fails, r6 sends w(1.0.0.0/8) over its ibgp sessions and router r7 responds by sending u(1.0.0.0/8,r3,as2,med=98) over its ibgp sessions. in practice, the ﬁfth step of the bgp decision process is slightly more complex, as the routes towards a given preﬁx can be learned from different ases. for example, assume that in ﬁgure hot and cold potato routing, 1.0.0.0/8 is also advertised by as3 (not shown in the ﬁgure) that has peering links with routers r6 and r8. if as3 advertises a route whose med attribute is set to 2 and another with a med set to 3, how should as1‘s router compare the four bgp routes towards 1.0.0.0/8 ? is a med value of 1 from as2 better than a med value of 2 from as3 ? the ﬁfth step of the bgp decision process solves this problem by only comparing the med attribute of the routes learned from the same neighbour as. additional details about the med attribute may be found in rfc 4451. it should be noted that using the med attribute may cause some problems in bgp networks as explained in [gw2002]. in practice, the med attribute is not used on ebgp sessions unless the two domains agree to enable it. the last step of the bgp decision allows the selection of a single route when a bgp router has received several routes that are considered as equal by the ﬁrst six steps of the decision process. this can happen for example in a dual-homed stub attached to two different providers. as shown in the ﬁgure below, router r1 receives two equally good bgp routes towards 1.0.0.0/8. to break the ties, each router is identiﬁed by a unique router-id which in practice is one of the ip addresses assigned to the router. on some routers, the lowest router id step in the bgp decision process is replaced by the selection of the oldest route rfc 5004. preferring the oldest route when breaking ties is used to prefer stable paths over unstable paths. however, a drawback of this approach is that the selection of the bgp routes depends on the arrival times of the corresponding messages. this makes the bgp selection process non-deterministic and can lead to problems that are difﬁcult to debug.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
the best solution to allow bgp routers to distribute, inside an as, all the routes learned over bgp sessions is to establish bgp sessions among all the bgp routers inside the as. in practice, there are two types of bgp sessions :
in practice, each bgp router inside a domain maintains an ibgp session with every other bgp router in the domain 34. this creates a full-mesh of ibgp sessions among all bgp routers of the domain. ibgp sessions, like ebgp sessions run over tcp connections. note that in contrast with ebgp sessions that are established between directly connected routers, ibgp sessions are often established between routers that are not directly connected. an important point to note about ibgp sessions is that a bgp router only advertises a route over an ibgp session provided that :
a bgp router does not advertise a route that it has learned over an ibgp session over another ibgp session. note that a router can, of course, advertise over an ebgp session a route that it has learned over an ibgp session. this difference between the behaviour of a bgp router over ibgp and ebgp session is due to the utilisation of a full-mesh of ibgp sessions. consider a network containing three bgp routers : a, b and c interconnected via a full-mesh of ibgp sessions. if router a learns a route towards preﬁx p from router b, router a does not need to advertise the received route to router c since router c also learns the same route over the c-b ibgp session. let us consider what happens when router r1 sends to understand the utilisation of an ibgp session, u(194.100.0.0/23,195.100.0.1,as10) in the network shown below. this bgp message is processed by r2 which advertises it over its ibgp session with r4. the bgp update sent by r2 contains the same nexthop and the same as-path as in the bgp update received by r2. r4 then sends u(194.100.0.0/23,195.100.0.5,as20:as10) to r3. note that the bgp nexthop and the as-path are only updated 35 when a bgp route is advertised over an ebgp session.
note: loopback interfaces and ibgp sessions in addition to their physical interfaces, routers can also be conﬁgured with a special loopback interface. a loopback interface is a software interface that is always up. when a loopback interface is conﬁgured on a router, the address associated to this interface is advertised by the intradomain routing protocol. consider for example
34 using a full-mesh of ibgp sessions is suitable in small networks. however, this solution does not scale in large networks containing ibgp sessions must be established in a domain containing n bgp routers. large domains use either
hundreds or more routers since n×(n−1) route reﬂection rfc 4456 or confederations rfc 5065 to scale their ibgp, but this goes beyond this introduction.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.8/30195.100.0.9195.100.0.10ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
a udp application that is often used in the wide area. however, in local area networks, many distributed systems rely on remote procedure call (rpc) that is often used on top of udp. in unix environments, the network file system (nfs) is built on top of rpc and runs frequently on top of udp. a second class of udp-based applications are the interactive computer games that need to frequently exchange small messages, such as the player’s location or their recent actions. many of these games use udp to minimise the delay and can recover from losses. a third class of applications are multimedia applications such as interactive voice over ip or interactive video over ip. these interactive applications expect a delay shorter than about 200 milliseconds between the sender and the receiver and can recover from losses directly inside the application.
the transmission control protocol (tcp) was initially deﬁned in rfc 793. several parts of the protocol have been improved since the publication of the original protocol speciﬁcation 9. however, the basics of the protocol remain and an implementation that only supports rfc 793 should inter-operate with today’s implementation. tcp provides a reliable bytestream, connection-oriented transport service on top of the unreliable connectionless network service provided by ip. tcp is used by a large number of applications, including :
• email (smtp, pop, imap) • world wide web ( http, ...) • most ﬁle transfer protocols ( ftp, peer-to-peer ﬁle sharing applications , ...) • remote computer access : telnet, ssh, x11, vnc, ... • non-interactive multimedia applications : ﬂash
on the global internet, most of the applications used in the wide area rely on tcp. many studies 10 have reported that tcp was responsible for more than 90% of the data exchanged in the global internet. to provide this service, tcp relies on a simple segment format that is shown in the ﬁgure below. each tcp segment contains a header described below and, optionally, a payload. the default length of the tcp header is twenty bytes, but some tcp headers contain options.
• source and destination ports. the source and destination ports play an important role in tcp, as they allow the identiﬁcation of the connection to which a tcp segment belongs. when a client opens a tcp connection, it typically selects an ephemeral tcp port number as its source port and contacts the server by using the server’s port number. all the segments that are sent by the client on this connection have the same source and destination ports. the server sends segments that contain as source (resp. destination port, the
these studies have been performed by collecting all transmitted over a given link during a period of a few hours or days and then analysing their headers recent studies include http://www.caida.org/research/trafﬁc-analysis/tcpudpratio/, https://research.sprintlabs.com/packstat/packetoverview.php or http://www.nanog.org/meetings/nanog43/presentations/labovitz_internetstats_n43.pdf
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
we explained how a transport connection can be safely released. we then discussed the mechanisms that are used in tcp, the reliable transport protocol, used by most applications on the internet. most notably, we described the congestion control mechanism that has been included in tcp since the late 1980s and explained how the reliability mechanisms used by tcp have been tuned over the years.
this section is divided in two parts. the ﬁrst part contains exercises on the principles of transport protocols, including tcp. the second part contains programming challenges packet analysis tools to observe the behaviour of transport protocols.
1. consider the alternating bit protocol as described in this chapter • how does the protocol recover from the loss of a data segment ? • how does the protocol recovers from the loss of an acknowledgement ? 2. a student proposed to optimise the alternating bit protocol by adding a negative acknowledgment, i.e. the receiver sends a nak control segment when it receives a corrupted data segment. what kind of information should be placed in this control segment and how should the sender react when receiving such a nak ?
• the 16 bits or the 32 bits cyclical redundancy checks (crc) that are often used on disks, in zip archives and in datalink layer protocols. see http://docs.python.org/library/binascii.html for a python module that contains the 32 bits crc
5. checksums and crcs should not be confused with secure hash functions such as md5 deﬁned in rfc 1321 or sha-1 described in rfc 4634. secure hash functions are used to ensure that ﬁles or sometimes packets/segments have not been modiﬁed. secure hash functions aim at detecting malicious changes while checksums and crcs only detect random transmission errors. perform some experiments with hash functions such as those deﬁned in the http://docs.python.org/library/hashlib.html python hashlib module to verify that this is indeed the case.
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
0x14fb9c03d97e 00010100 11111011 10011100 00000011 11011001 01111110 000101 001111 101110 011100 000000 111101 100101 111110 5 15 46 28 0 61 37 62 f p u c a 9 l +
the last point to be discussed about base64 is what happens when the length of the sequence of bytes to be encoded is not a multiple of three. in this case, the last group of bytes may contain one or two bytes instead of three. base64 reserves the = character as a padding character. this character is used twice when the last group contains two bytes and once when it contains one byte as illustrated by the two examples below.
now that we have explained the format of the email messages, we can discuss how these messages can be exchanged through the internet. the ﬁgure below illustrates the protocols that are used when alice sends an email message to bob. alice prepares her email with an email client or on a webmail interface. to send her email to bob, alice‘s client will use the simple mail transfer protocol (smtp) to deliver her message to her smtp server. alice‘s email client is conﬁgured with the name of the default smtp server for her domain. there is usually at least one smtp server per domain. to deliver the message, alice‘s smtp server must ﬁnd the smtp server that contains bob‘s mailbox. this can be done by using the mail exchange (mx) records of the dns. a set of mx records can be associated to each domain. each mx record contains a numerical preference and the fully qualiﬁed domain name of a smtp server that is able to deliver email messages destined to all valid email addresses of this domain. the dns can return several mx records for a given domain. in this case, the server with the lowest preference is used ﬁrst. if this server is not reachable, the second most preferred server is used etc. bob‘s smtp server will store the message sent by alice until bob retrieves it using a webmail interface or protocols such as the post ofﬁce protocol (pop) or the internet message access protocol (imap).
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
the routing information protocol (rip) is the simplest routing protocol that was standardised for the tcp/ip protocol suite. rip is deﬁned in rfc 2453. additional information about rip may be found in [malkin1999] rip routers periodically exchange rip messages. the format of these messages is shown below. a rip message is sent inside a udp segment whose destination port is set to 521. a rip message contains several ﬁelds. the cmd ﬁeld indicates whether the rip message is a request or a response. routers send one of more rip response messages every 30 seconds. these messages contain the distance vectors that summarize the router’s routing table. the rip request messages can be used by routers or hosts to query other routers about the content of their routing table. a typical usage is when a router boots and quickly wants to receive the rip responses from its neighbours to compute its own routing table. the current version of rip is version 2 deﬁned in rfc 2453 for ipv4 and rfc 2080 for ipv6.
the rip header contains an authentication ﬁeld. this authentication can be used by network administrators to ensure that only the rip messages sent by the routers that they manage are used to build the routing tables. rfc 2453 only supports a basic authentication scheme where all routers are conﬁgured with the same password and include this password in all rip messages. this is not very secure since an attacker can know the password by capturing a single rip message. however, this password can protect against conﬁguration errors. stronger authentication schemes are described in rfc 2082 and rfc 4822, but the details of these mechanisms are outside the scope of this section. each rip message contains a set of route entries. each route entry is encoded as a 20 bytes ﬁeld whose format is shown below. rip was initially designed to be suitable for different network layer protocols. some implementations of rip were used in xns or ipx networks. the ﬁrst ﬁeld of the rip route entry is the address family identiﬁer (afi). this identiﬁer indicates the type of address found in the route entry 22. ipv4 uses afi=1. the other important ﬁelds of the route entry are the ipv4 preﬁx, the netmask that indicates the length of the subnet identiﬁer and is encoded as a 32 bits netmask and the metric. although the metric is encoded as a 32 bits ﬁeld, the maximum rip metric is 15 (for rip, 16 = ∞)
with a 20 bytes route entry, it was difﬁcult to use the same format as above to support ipv6. instead of deﬁning a variable length route entry format, the designers of rfc 2080 deﬁned a new format that does not include an afi ﬁeld. the format of the route entries used by rfc 2080 is shown below. plen is the length of the subnet identiﬁer in bits and the metric is encoded as one byte. the maximum metric is still 15.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
recent estimations of the number of hosts attached to the internet show a continuing growth since 20+ years. however, although the number of hosts attached to the internet is high, it should be compared to the number of mobile phones that are in use today. more and more of these mobile phones will be connected to the internet. furthermore, thanks to the availability of tcp/ip implementations requiring limited resources such as uip [dunkels2003], we can expect to see a growth of tcp/ip enabled embedded devices.
before looking at the services provided by computer networks, it is useful to agree on some terminology that is widely used in networking literature. first of all, computer networks are often classiﬁed in function of the geographical area that they cover
another classiﬁcation of computer networks is based on their physical topology. in the following ﬁgures, physical links are represented as lines while boxes show computers or other types of networking equipment. computer networks are used to allow several hosts to exchange information between themselves. to allow any host to send messages to any other host in the network, the easiest solution is to organise them as a full-mesh, with a direct and dedicated link between each pair of hosts. such a physical topology is sometimes used, especially when high performance and high redundancy is required for a small number of hosts. however, it has two major drawbacks :
physical interfaces on a node will limit the size of a full-mesh network that can be built • for a network containing n hosts, n×(n−1) in the same room, but rarely when they are located several kilometers apart
the second possible physical organisation, which is also used inside computers to connect different extension cards, is the bus. in a bus network, all hosts are attached to a shared medium, usually a cable through a single interface. when one host sends an electrical signal on the bus, the signal is received by all hosts attached to the bus. a drawback of bus-based networks is that if the bus is physically cut, then the network is split into two isolated networks. for this reason, bus-based networks are sometimes considered to be difﬁcult to operate and maintain, especially when the cable is long and there are many places where it can break. such a bus-based topology was used in early ethernet networks. a third organisation of a computer network is a star topology. in such topologies, hosts have a single physical interface and there is one physical link between each host and the center of the star. the node at the center of the star can be either a piece of equipment that ampliﬁes an electrical signal, or an active device, such as a piece
2 in this book, we focus on networks that are used on earth. these networks sometimes include satellite links. besides the network technologies that are used on earth, researchers develop networking techniques that could be used between nodes located on different planets. such an inter planetary internet requires different techniques than the ones discussed in this book. see rfc 4838 and the references therein for information about these techniques.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
in the example above, the mta running on mta.example.org opens a tcp connection to the smtp server on host smtp.example.com. the lines preﬁxed with s: (resp. c:) are the responses sent by the server (resp. the commands sent by the client). the server sends its greetings as soon as the tcp connection has been established. the client then sends the ehlo command with its fully qualiﬁed domain name. the server replies with reply-code 250 and sends its greetings. the smtp association can now be used to exchange an email. to send an email, the client must ﬁrst provide the address of the recipient with rcpt to:. then it uses the mail from: with the address of the sender. both the recipient and the sender are accepted by the server. the client can now issue the data command to start the transfer of the email message. after having received the 354 reply code, the client sends the headers and the body of its email message. the client indicates the end of the message by sending a line containing only the . (dot) character 15. the server conﬁrms that the email message has been queued for delivery or transmission with a reply code of 250. the client issues the quit command to close the session and the server conﬁrms with reply-code 221, before closing the tcp connection.
note: open smtp relays and spam since its creation in 1971, email has been a very useful tool that is used by many users to exchange lots of information. in the early days, all smtp servers were open and anyone could use them to forward emails towards their ﬁnal destination. unfortunately, over the years, some unscrupulous users have found ways to use email for marketing purposes or to send malware. the ﬁrst documented abuse of email for marketing purposes occurred in 1978 when a marketer who worked for a computer vendor sent a marketing email to many arpanet users. at that time, the arpanet could only be used for research purposes and this was an abuse of the acceptable use policy. unfortunately, given the extremely low cost of sending emails, the problem of unsolicited emails has not stopped. unsolicited emails are now called spam and a study carried out by enisa in 2009 reveals that 95% of email was spam and this number seems to continue to grow. this places a burden on the email infrastructure of internet service providers and large companies that need to process many useless messages. given the amount of spam messages, smtp servers are no longer open rfc 5068. several extensions to smtp have been developed in recent years to deal with this problem. for example, the smtp authentication scheme deﬁned in rfc 4954 can be used by an smtp server to authenticate a client. several techniques have also been proposed to allow smtp servers to authenticate the messages sent by their users rfc 4870 rfc 4871 .
when the ﬁrst versions of smtp were designed, the internet was composed of minicomputers that were used by an entire university department or research lab. these minicomputers were used by many users at the same time. email was mainly used to send messages from a user on a given host to another user on a remote host. at that time, smtp was the only protocol involved in the delivery of the emails as all hosts attached to the network were running an smtp server. on such hosts, an email destined to local users was delivered by placing the email in a special directory or ﬁle owned by the user. however, the introduction of personal computers in the 1980s, changed this environment. initially, users of these personal computers used applications such as telnet to open a remote session on the local minicomputer to read their email. this was not user-friendly. a better solution appeared with the development of user friendly email client applications on personal computers. several protocols were designed to allow these client applications to retrieve the email messages destined to a user from his/her server. two of these protocols became popular and are still used today. the post ofﬁce protocol (pop), deﬁned in rfc 1939, is the simplest one. it allows a client to download all the messages destined to a given user from his/her email server. we describe pop brieﬂy in this section. the second protocol is the internet message access protocol (imap), deﬁned in rfc 3501. imap is more powerful, but also more complex than pop. imap was designed to allow client applications to efﬁciently access in real-time to messages stored in various folders on servers. imap
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
in the example above, the mta running on mta.example.org opens a tcp connection to the smtp server on host smtp.example.com. the lines preﬁxed with s: (resp. c:) are the responses sent by the server (resp. the commands sent by the client). the server sends its greetings as soon as the tcp connection has been established. the client then sends the ehlo command with its fully qualiﬁed domain name. the server replies with reply-code 250 and sends its greetings. the smtp association can now be used to exchange an email. to send an email, the client must ﬁrst provide the address of the recipient with rcpt to:. then it uses the mail from: with the address of the sender. both the recipient and the sender are accepted by the server. the client can now issue the data command to start the transfer of the email message. after having received the 354 reply code, the client sends the headers and the body of its email message. the client indicates the end of the message by sending a line containing only the . (dot) character 15. the server conﬁrms that the email message has been queued for delivery or transmission with a reply code of 250. the client issues the quit command to close the session and the server conﬁrms with reply-code 221, before closing the tcp connection.
note: open smtp relays and spam since its creation in 1971, email has been a very useful tool that is used by many users to exchange lots of information. in the early days, all smtp servers were open and anyone could use them to forward emails towards their ﬁnal destination. unfortunately, over the years, some unscrupulous users have found ways to use email for marketing purposes or to send malware. the ﬁrst documented abuse of email for marketing purposes occurred in 1978 when a marketer who worked for a computer vendor sent a marketing email to many arpanet users. at that time, the arpanet could only be used for research purposes and this was an abuse of the acceptable use policy. unfortunately, given the extremely low cost of sending emails, the problem of unsolicited emails has not stopped. unsolicited emails are now called spam and a study carried out by enisa in 2009 reveals that 95% of email was spam and this number seems to continue to grow. this places a burden on the email infrastructure of internet service providers and large companies that need to process many useless messages. given the amount of spam messages, smtp servers are no longer open rfc 5068. several extensions to smtp have been developed in recent years to deal with this problem. for example, the smtp authentication scheme deﬁned in rfc 4954 can be used by an smtp server to authenticate a client. several techniques have also been proposed to allow smtp servers to authenticate the messages sent by their users rfc 4870 rfc 4871 .
when the ﬁrst versions of smtp were designed, the internet was composed of minicomputers that were used by an entire university department or research lab. these minicomputers were used by many users at the same time. email was mainly used to send messages from a user on a given host to another user on a remote host. at that time, smtp was the only protocol involved in the delivery of the emails as all hosts attached to the network were running an smtp server. on such hosts, an email destined to local users was delivered by placing the email in a special directory or ﬁle owned by the user. however, the introduction of personal computers in the 1980s, changed this environment. initially, users of these personal computers used applications such as telnet to open a remote session on the local minicomputer to read their email. this was not user-friendly. a better solution appeared with the development of user friendly email client applications on personal computers. several protocols were designed to allow these client applications to retrieve the email messages destined to a user from his/her server. two of these protocols became popular and are still used today. the post ofﬁce protocol (pop), deﬁned in rfc 1939, is the simplest one. it allows a client to download all the messages destined to a given user from his/her email server. we describe pop brieﬂy in this section. the second protocol is the internet message access protocol (imap), deﬁned in rfc 3501. imap is more powerful, but also more complex than pop. imap was designed to allow client applications to efﬁciently access in real-time to messages stored in various folders on servers. imap
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
or permanent error in routing tables 7. consider for example the situation depicted in the ﬁgure below where destination d uses address 11.0.0.56. if s sends a packet towards this destination, the packet is forwarded to router b which forwards it to router c that forwards it back to router a, etc.
unfortunately, such loops can occur for two reasons in ip networks. first, if the network uses static routing, the loop can be caused by a simple conﬁguration error. second, if the network uses dynamic routing, such a loop can occur transiently, for example during the convergence of the routing protocol after a link or router failure. the ttl ﬁeld of the ipv4 header ensures that even if there are forwarding loops in the network, packets will not loop forever. hosts send their ipv4 packets with a positive ttl (usually 64 or more 8). when a router receives an ipv4 packet, it ﬁrst decrements the ttl by one. if the ttl becomes 0, the packet is discarded and a message is sent back to the packet’s source (see section icmp). otherwise, the router performs a lookup in its forwarding table to forward the packet. a second problem for ipv4 is the heterogeneity of the datalink layer. ipv4 is used above many very different datalink layers. each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterised by a maximum frame size. from ip’s point of view, a datalink layer interface is characterised by its maximum transmission unit (mtu). the mtu of an interface is the largest ipv4 packet (including header) that it can send. the table below provides some common mtu sizes 9.
although ipv4 can send 64 kbytes long packets, few datalink layer technologies that are used today are able to send a 64 kbytes ipv4 packet inside a frame. furthermore, as illustrated in the ﬁgure below, another problem is that a host may send a packet that would be too large for one of the datalink layers used by the intermediate routers.
7 the initial ip speciﬁcation in rfc 791 suggested that routers would decrement the ttl at least once every second. this would ensure that a packet would never remain for more than ttl seconds in the network. however, in practice most router implementations simply chose to decrement the ttl by one.
in comparison with ipv4, the ipv6 packets are much simpler and easier to process by routers. a ﬁrst important difference is that there is no checksum inside the ipv6 header. this is mainly because all datalink layers and transport protocols include a checksum or a crc to protect their frames/segments against transmission errors. adding a checksum in the ipv6 header would have forced each router to recompute the checksum of all packets, with limited beneﬁt in detecting errors. in practice, an ip checksum allows for catching errors that occur inside routers (e.g. due to memory corruption) before the packet reaches its destination. however, this beneﬁt was found to be too small given the reliability of current memories and the cost of computing the checksum on each router. a second difference with ipv4 is that the ipv6 header does not support fragmentation and reassembly. experience with ipv4 has shown that fragmenting packets in routers was costly [km1995] and the developers of ipv6 have decided that routers would not fragment packets anymore. if a router receives a packet that is too long to be forwarded, the packet is dropped and the router returns an icmpv6 messages to inform the sender of the problem. the sender can then either fragment the packet or perform path mtu discovery. in ipv6, packet fragmentation is performed only by the source by using ipv6 options. the third difference are the ipv6 options, which are simpler and easier to process than the ipv4 options.
note: header compression on low bandwidth links given the size of the ipv6 header, it can cause huge overhead on low bandwidth links, especially when small packets are exchanged such as for voice over ip applications. in such environments, several techniques can be used to reduce the overhead. a ﬁrst solution is to use data compression in the datalink layer to compress all the information exchanged [thomborson1992]. these techniques are similar to the data compression algorithms used in tools such as compress(1) or gzip(1) rfc 1951. they compress streams of bits without taking advantage of the fact that these streams contain ip packets with a known structure. a second solution is to compress the ip and tcp header. these header compression techniques, such as the one deﬁned in rfc 2507 take advantage of the redundancy found in successive packets from the same ﬂow to signiﬁcantly reduce the size of the protocol headers. another solution is to deﬁne a compressed encoding of the ipv6 header that matches the capabilities of the underlying datalink layer rfc 4944.
in ipv6, each option is considered as one header containing a multiple of 8 bytes to ensure that ipv6 options in a packet are aligned on 64 bit boundaries. ipv6 deﬁnes several type of options :
• the hop-by-hop options are options that must be processed by the routers on the packet’s path • the type 0 routing header, which is similar to the ipv4 loose source routing option • the fragmentation option, which is used when fragmenting an ipv6 packet • the destination options • the security options that allow ipv6 hosts to exchange packets with cryptographic authentication (ah
rfc 2460 provides lots of detail on the encodings of the different types of options. in this section, we only discus some of them. the reader may consult rfc 2460 for more information about the other options. the ﬁrst point to note is that each option contains a next header ﬁeld, which indicates the type of header that follows the option. a second point to note is that in order to allow routers to efﬁciently parse ipv6 packets, the options that must be processed by routers (hop-by-hop options and type 0 routing header) must appear ﬁrst in the packet. this allows the router to process a packet without being forced to analyse all the packet’s options. a third point to note is that hop-by-hop and destination options are encoded using a type length value format. furthermore, the type ﬁeld contains bits that indicate whether a router that does not understand this option should ignore the option or discard the packet. this allows the introduction of new options into the network without forcing all devices to be upgraded to support them at the same time. two hop-by-hop options have been deﬁned. rfc 2675 speciﬁes the jumbogram that enables ipv6 to support packets containing a payload larger than 65535 bytes. these jumbo packets have their payload length set to 0 and
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
another utilisation of tcp options during connection establishment is to enable tcp extensions. for example, consider rfc 1323 (which is discussed in tcp reliable data transfer). rfc 1323 deﬁnes tcp extensions to support timestamps and larger windows. if the client supports rfc 1323, it adds a rfc 1323 option to its syn if the server understands this rfc 1323 option and wishes to use it, it replies with an rfc 1323 segment. option in the syn+ack segment and the extension deﬁned in rfc 1323 is used throughout the tcp connection. otherwise, if the server’s syn+ack does not contain the rfc 1323 option, the client is not allowed to use this extension and the corresponding tcp header options throughout the tcp connection. tcp’s option mechanism is ﬂexible and it allows the extension of tcp while maintaining compatibility with older implementations. the tcp options are encoded by using a type length value format where :
• the ﬁrst byte indicates the type of the option. • the second byte indicates the total length of the option (including the ﬁrst two bytes) in bytes • the last bytes are speciﬁc for each type of option
rfc 793 deﬁnes the maximum segment size (mss) tcp option that must be understood by all tcp implementations. this option (type 2) has a length of 4 bytes and contains a 16 bits word that indicates the mss supported by the sender of the syn segment. the mss option can only be used in tcp segments having the syn ﬂag set. rfc 793 also deﬁnes two special options that must be supported by all tcp implementations. the ﬁrst option is end of option. it is encoded as a single byte having value 0x00 and can be used to ensure that the tcp header extension ends on a 32 bits boundary. the no-operation option, encoded as a single byte having value 0x01, can be used when the tcp header extension contains several tcp options that should be aligned on 32 bit boundaries. all other options 14 are encoded by using the tlv format.
note: the robustness principle the handling of the tcp options by tcp implementations is one of the many applications of the robustness principle which is usually attributed to jon postel and is often quoted as “be liberal in what you accept, and conservative in what you send” rfc 1122 concerning the tcp options, the robustness principle implies that a tcp implementation should be able to accept tcp options that it does not understand, in particular in received syn segments, and that it should be able to parse any received segment without crashing, even if the segment contains an unknown tcp option. furthermore, a server should not send in the syn+ack segment or later, options that have not been proposed by the client in the syn segment.
• graceful connection release, where each tcp user can release its own direction of data transfer • abrupt connection release, where either one user closes both directions of data transfer or one tcp entity is forced to close the connection (e.g. because the remote host does not reply anymore or due to lack of resources)
the abrupt connection release mechanism is very simple and relies on a single segment having the rst bit set. a tcp segment containing the rst bit can be sent for the following reasons :
• a non-syn segment was received for a non-existing tcp connection rfc 793 • by extension, some implementations respond with an rst segment to a segment that is received on an existing connection but with an invalid header rfc 3360. this causes the corresponding connection to be closed and has caused security attacks rfc 4953
• by extension, some implementations send an rst segment when they need to close an existing tcp connection (e.g. because there are not enough resources to support this connection or because the remote host is considered to be unreachable). measurements have shown that this usage of tcp rst was widespread [aw05]
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
the simple mail transfer protocol (smtp) deﬁned in rfc 5321 is a client-server protocol. the smtp speciﬁcation distinguishes between ﬁve types of processes involved in the delivery of email messages. email messages are composed on a mail user agent (mua). the mua is usually either an email client or a webmail. the mua sends the email message to a mail submission agent (msa). the msa processes the received email and forwards it to the mail transmission agent (mta). the mta is responsible for the transmission of the email, directly or via intermediate mtas to the mta of the destination domain. this destination mta will then forward the message to the mail delivery agent (mda) where it will be accessed by the recipient’s mua. smtp is used for the interactions between mua and msa 13, msa-mta and mta-mta. smtp is a text-based protocol like many other application-layer protocols on the internet. it relies on the bytestream service. servers listen on port 25. clients send commands that are each composed of one line of ascii text terminated by cr+lf. servers reply by sending ascii lines that contain a three digit numerical error/success code and optional comments. the smtp protocol, like most text-based protocols, is speciﬁed as a bnf. the full bnf is deﬁned in rfc 5321. the main smtp commands are deﬁned by the bnf rules shown in the ﬁgure below.
in this bnf, atext corresponds to printable ascii characters. this bnf rule is deﬁned in rfc 5322. the ﬁve main commands are ehlo, mail from:, rcpt to:, data and quit 14. postmaster is the alias of the system administrator who is responsible for a given domain or smtp server. all domains must have a postmaster alias. the smtp responses are deﬁned by the bnf shown in the ﬁgure below.
14 the ﬁrst versions of smtp used helo as the ﬁrst command sent by a client to a smtp server. when smtp was extended to support newer features such as 8 bits characters, it was necessary to allow a server to recognise whether it was interacting with a client that supported the extensions or not. ehlo became mandatory with the publication of rfc 2821.
in the example above, the mta running on mta.example.org opens a tcp connection to the smtp server on host smtp.example.com. the lines preﬁxed with s: (resp. c:) are the responses sent by the server (resp. the commands sent by the client). the server sends its greetings as soon as the tcp connection has been established. the client then sends the ehlo command with its fully qualiﬁed domain name. the server replies with reply-code 250 and sends its greetings. the smtp association can now be used to exchange an email. to send an email, the client must ﬁrst provide the address of the recipient with rcpt to:. then it uses the mail from: with the address of the sender. both the recipient and the sender are accepted by the server. the client can now issue the data command to start the transfer of the email message. after having received the 354 reply code, the client sends the headers and the body of its email message. the client indicates the end of the message by sending a line containing only the . (dot) character 15. the server conﬁrms that the email message has been queued for delivery or transmission with a reply code of 250. the client issues the quit command to close the session and the server conﬁrms with reply-code 221, before closing the tcp connection.
note: open smtp relays and spam since its creation in 1971, email has been a very useful tool that is used by many users to exchange lots of information. in the early days, all smtp servers were open and anyone could use them to forward emails towards their ﬁnal destination. unfortunately, over the years, some unscrupulous users have found ways to use email for marketing purposes or to send malware. the ﬁrst documented abuse of email for marketing purposes occurred in 1978 when a marketer who worked for a computer vendor sent a marketing email to many arpanet users. at that time, the arpanet could only be used for research purposes and this was an abuse of the acceptable use policy. unfortunately, given the extremely low cost of sending emails, the problem of unsolicited emails has not stopped. unsolicited emails are now called spam and a study carried out by enisa in 2009 reveals that 95% of email was spam and this number seems to continue to grow. this places a burden on the email infrastructure of internet service providers and large companies that need to process many useless messages. given the amount of spam messages, smtp servers are no longer open rfc 5068. several extensions to smtp have been developed in recent years to deal with this problem. for example, the smtp authentication scheme deﬁned in rfc 4954 can be used by an smtp server to authenticate a client. several techniques have also been proposed to allow smtp servers to authenticate the messages sent by their users rfc 4870 rfc 4871 .
when the ﬁrst versions of smtp were designed, the internet was composed of minicomputers that were used by an entire university department or research lab. these minicomputers were used by many users at the same time. email was mainly used to send messages from a user on a given host to another user on a remote host. at that time, smtp was the only protocol involved in the delivery of the emails as all hosts attached to the network were running an smtp server. on such hosts, an email destined to local users was delivered by placing the email in a special directory or ﬁle owned by the user. however, the introduction of personal computers in the 1980s, changed this environment. initially, users of these personal computers used applications such as telnet to open a remote session on the local minicomputer to read their email. this was not user-friendly. a better solution appeared with the development of user friendly email client applications on personal computers. several protocols were designed to allow these client applications to retrieve the email messages destined to a user from his/her server. two of these protocols became popular and are still used today. the post ofﬁce protocol (pop), deﬁned in rfc 1939, is the simplest one. it allows a client to download all the messages destined to a given user from his/her email server. we describe pop brieﬂy in this section. the second protocol is the internet message access protocol (imap), deﬁned in rfc 3501. imap is more powerful, but also more complex than pop. imap was designed to allow client applications to efﬁciently access in real-time to messages stored in various folders on servers. imap
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
another very useful debugging tool is traceroute(8). the traceroute man page describes this tool as “print the route packets take to network host”. traceroute uses the ttl exceeded icmp messages to discover the intermediate routers on the path towards a destination. the principle behind traceroute is very simple. when a router receives an ip packet whose ttl is set to 1 it decrements the ttl and is forced to return to the sending host a ttl exceeded icmp message containing the header and the ﬁrst bytes of the discarded ip packet. to discover all routers on a network path, a simple solution is to ﬁrst send a packet whose ttl is set to 1, then a packet whose ttl is set to 2, etc. a sample traceroute output is shown below.
cshalles3.sri.ucl.ac.be (192.168.251.230) cthalles.sri.ucl.ac.be (192.168.251.229) ctpythagore.sri.ucl.ac.be (130.104.254.230) fe.m20.access.lln.belnet.net (193.191.11.9) 10ge.cr2.brueve.belnet.net (193.191.16.22) 212.3.237.13 (212.3.237.13) 5.347 ms ae-11-11.car1.brussels1.level3.net (4.69.136.249) ae-6-6.ebr1.london1.level3.net (4.69.136.246) ae-100-100.ebr2.london1.level3.net (4.69.141.166)
ae-41-41.ebr1.newyork1.level3.net (4.69.137.66) ae-43-43.ebr1.newyork1.level3.net (4.69.137.74) ae-42-42.ebr1.newyork1.level3.net (4.69.137.70) ae-2-2.ebr1.newark1.level3.net (4.69.132.98) ae-14-51.car4.newark1.level3.net (4.68.99.8) ex1-tg2-0.eqnwnj.sbcglobal.net (151.164.89.249) 151.164.95.190 (151.164.95.190) ded-p10-0.pltn13.sbcglobal.net (151.164.191.243) ams-1152322.cust-rtr.swbell.net (75.61.192.10) mail.ietf.org (64.170.98.32) 158.427 ms
the above traceroute(8) output shows a 17 hops path between a host at uclouvain and one of the main ietf servers. for each hop, traceroute provides the ipv4 address of the router that sent the icmp message and the measured round-trip-time between the source and this router. traceroute sends three probes with each ttl value. in some cases, such as at the 10th hop above, the icmp messages may be received from different addresses. this is usually because different packets from the same source have followed different paths 11 in the network. another important utilisation of icmp messages is to discover the maximum mtu that can be used to reach a destination without fragmentation. as explained earlier, when an ipv4 router receives a packet that is larger than the mtu of the outgoing link, it must fragment the packet. unfortunately, fragmentation is a complex operation and routers cannot perform it at line rate [km1995]. furthermore, when a tcp segment is transported in an ip packet that is fragmented in the network, the loss of a single fragment forces tcp to retransmit the entire segment (and thus all the fragments). if tcp was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. in addition, ip reassembly causes several challenges at high speed as discussed in rfc 4963. using ip fragmentation to allow udp applications to exchange large messages raises several security issues [kps2003]. icmp, combined with the don’t fragment (df) ipv4 ﬂag, is used by tcp implementations to discover the largest mtu size that is allowed to reach a destination host without causing network fragmentation. this is the path mtu discovery mechanism deﬁned in rfc 1191. a tcp implementation that includes path mtu discovery (most do) requests the ipv4 layer to send all segments inside ipv4 packets having the df ﬂag set. this prohibits intermediate routers from fragmenting these packets. if a router needs to forward an unfragmentable packet over a link with a smaller mtu, it returns a fragmentation needed icmp message to the source, indicating the mtu of its outgoing link. this icmp message contains in the mtu of the router’s outgoing link in its data ﬁeld. upon reception of this icmp message, the source tcp implementation adjusts its maximum segment size (mss) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.
2 minutes, this implies that the maximum bandwidth to a given destination is limited to roughly 286 mbps. with a more realistic 1500 bytes mtu, that bandwidth drops to 6.4 mbps rfc 4963 if fragmentation must be possible 17. this is very low and is another reason why hosts are highly encouraged to avoid fragmentation. if; despite all of this, the mtu of the outgoing interface is smaller than the packet’s length, the packet is fragmented. finally, the packet’s checksum is computed before transmission. when a host receives an ipv4 packet destined to itself, there are several operations that it must perform. first, it must check the packet’s checksum. if the checksum is incorrect, the packet is discarded. then, it must check whether the packet has been fragmented. if yes, the packet is passed to the reassembly algorithm described earlier. otherwise, the packet must be passed to the upper layer. this is done by looking at the protocol ﬁeld (6 for tcp, 17 for udp). if the host does not implement the transport layer protocol corresponding to the received protocol ﬁeld, it sends a protocol unreachable icmp message to the sending host. if the received packet contains an icmp message (protocol ﬁeld set to 1), the processing is more complex. an echo-request icmp message triggers the transmission of an icmp echo-reply message. the other types of icmp messages indicate an error that was caused by a previously transmitted packet. these icmp messages are usually forwarded to the transport protocol that sent the erroneous packet. this can be done by inspecting the contents of the icmp message that includes the header and the ﬁrst 64 bits of the erroneous packet. if the ip packet did not contain options, which is the case for most ipv4 packets, the transport protocol can ﬁnd in the ﬁrst 32 bits of the transport header the source and destination ports to determine the affected transport ﬂow. this is important for path mtu discovery for example. when a router receives an ipv4 packet, it must ﬁrst check the packet’s checksum. if the checksum is invalid, it is discarded. otherwise, the router must check whether the destination address is one of the ipv4 addresses assigned to the router. if so, the router must behave as a host and process the packet as described above. although routers mainly forward ipv4 packets, they sometimes need to be accessed as hosts by network operators or network management software. if the packet is not addressed to the router, it must be forwarded on an outgoing interface according to the router’s routing table. the router ﬁrst decrements the packet’s ttl. if the ttl reaches 0, a ttl exceeded icmp message is sent back to the source. as the packet header has been modiﬁed, the checksum must be recomputed. fortunately, as ipv4 uses an arithmetic checksum, a router can incrementally update the packet’s checksum as described in rfc 1624. then, the router performs a longest preﬁx match for the packet’s destination address in its forwarding if no match is found, the router must return a destination unreachable icmp message to the source. table. otherwise, the lookup returns the interface over which the packet must be forwarded. before forwarding the packet over this interface, the router must ﬁrst compare the length of the packet with the mtu of the outgoing interface. if the packet is smaller than the mtu, it is forwarded. otherwise, a fragmentation needed icmp message is sent if the df ﬂag was sent or the packet is fragmented if the df was not set.
note: longest preﬁx match in ip routers performing the longest preﬁx match at line rate on routers requires highly tuned data structures and algorithms. consider for example an implementation of the longest match based on a radix tree on a router with a 10 gbps link. on such a link, a router can receive 31,250,000 40 bytes ipv4 packets every second. to forward the packets at line rate, the router must process one ipv4 packet every 32 nanoseconds. this cannot be achieved by a software implementation. for a hardware implementation, the main difﬁculty lies in the number of memory accesses that are necessary to perform the longest preﬁx match. 32 nanoseconds is very small compared to the memory accesses that are required by a naive longest preﬁx match implement. additional information about faster longest preﬁx match algorithms may be found in [varghese2005].
in the late 1980s and early 1990s the growth of the internet was causing several operational problems on routers. many of these routers had a single cpu and up to 1 mbyte of ram to store their operating system, packet buffers and routing tables. given the rate of allocation of ipv4 preﬁxes to companies and universities willing to join the internet, the routing tables where growing very quickly and some feared that all ipv4 preﬁxes would quickly be allocated. in 1987, a study cited in rfc 1752, estimated that there would be 100,000 networks in the near future. in august 1990, estimates indicated that the class b space would be exhausted by march 1994. two types of
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
denial of service attacks when a tcp entity opens a tcp connection, it creates a transmission control block (tcb). the tcb contains the entire state that is maintained by the tcp entity for each tcp connection. during connection establishment, the tcb contains the local ip address, the remote ip address, the local port number, the remote port number, the current local sequence number, the last sequence number received from the remote entity. until the mid 1990s, tcp implementations had a limit on the number of tcp connections that could be in the syn rcvd state at a given time. many implementations set this limit to about 100 tcbs. this limit was considered sufﬁcient even for heavily load http servers given the small delay between the reception of a syn segment and the reception of the ack segment that terminates the establishment of the tcp connection. when the limit of 100 tcbs in the syn rcvd state is reached, the tcp entity discards all received tcp syn segments that do not correspond to an existing tcb. this limit of 100 tcbs in the syn rcvd state was chosen to protect the tcp entity from the risk of overloading its memory with too many tcbs in the syn rcvd state. however, it was also the reason for a new type of denial of service (dos) attack rfc 4987. a dos attack is deﬁned as an attack where an attacker can render a resource unavailable in the network. for example, an attacker may cause a dos attack on a 2 mbps link used by a company by sending more than 2 mbps of packets through this link. in this case, the dos attack was more subtle. as a tcp entity discards all received syn segments as soon as it has 100 tcbs in the syn rcvd state, an attacker simply had to send a few 100 syn segments every second to a server and never reply to the received syn+ack segments. to avoid being caught, attackers were of course sending these syn segments with a different address than their own ip address a. on most tcp implementations, once a tcb entered the syn rcvd state, it remained in this state for several seconds, waiting for a retransmission of the initial syn segment. this attack was later called a syn ﬂood attack and the servers of the isp named panix were among the ﬁrst to be affected by this attack. to avoid the syn ﬂood attacks, recent tcp implementations no longer enter the syn rcvd state upon reception of a syn segment. instead, they reply directly with a syn+ack segment and wait until the reception of a valid ack. this implementation trick is only possible if the tcp implementation is able to verify that the received ack segment acknowledges the syn+ack segment sent earlier without storing the initial sequence number of this syn+ack segment in a tcb. the solution to solve this problem, which is known as syn cookies is to compute the 32 bits of the isn as follows :
• the high order bits contain the low order bits of a counter that is incremented slowly • the low order bits contain a hash value computed over the local and remote ip addresses and ports and
the advantage of the syn cookies is that by using them, the server does not need to create a tcb upon reception of the syn segment and can still check the returned ack segment by recomputing the syn cookie.
retransmitting the ﬁrst syn segment as ip provides an unreliable connectionless service, the syn and syn+ack segments sent to open a tcp connection could be lost. current tcp implementations start a retransmission timer when they send the ﬁrst syn segment. this timer is often set to three seconds for the ﬁrst retransmission and then doubles after each retransmission rfc 2988. tcp implementations also enforce a maximum number of retransmissions for the initial syn segment.
as explained earlier, tcp segments may contain an optional header extension. in the syn and syn+ack segments, these options are used to negotiate some parameters and the utilisation of extensions to the basic tcp speciﬁcation. the ﬁrst parameter which is negotiated during the establishment of a tcp connection is the maximum segment size (mss). the mss is the size of the largest segment that a tcp entity is able to process. according to rfc 879, all tcp implementations must be able to receive tcp segments containing 536 bytes of payload. however, most tcp implementations are able to process larger segments. such tcp implementations use the tcp mss option in the syn/syn+ack segment to indicate the largest segment they are able to process. the mss value indicates the maximum size of the payload of the tcp segments. the client (resp. server) stores in its tcb the mss value announced by the server (resp. the client).
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
hot potato routing allows as1 to minimise the cost of forwarding packets towards as2. however, there are situations where this is not desirable. for example, assume that as1 and as2 are domains with routers on both the east and the west coast of the us. in these two domains, the high metric associated to links r6-r8 and r0-r2 correspond to the cost of forwarding a packet across the usa. if as2 is a customer that pays as1, it would prefer to receive the packets destined to 1.0.0.0/8 via the r2-r6 link instead of the r7-r3 link. this is the objective of cold potato routing. cold potato routing is implemented using the multi-exit discriminator (med) attribute. this attribute is an optional bgp attribute that may be set 37 by border routers when advertising a bgp route over an ebgp session. the med attribute is usually used to indicate over an ebgp session the cost to reach the bgp nexthop for the advertised route. the med attribute is set by the router that advertises a route over an ebgp session. in the example above, router r2 sends u(1.0.0.0/8,r2,as2,med=1) while r3 sends u(1.0.0.0/8,r3,as2,med=98). assume that the bgp session r7-3 is the ﬁrst to be established. r7 sends u(1.0.0.0/8,r3,as2,med=98) to both r8 and r6. at this point, all routers inside as1 send the packets towards 1.0.0.0/8 via r7-r3. then, the r6r2 bgp session is established and router r6 receives u(1.0.0.0/8,r2,as2,med=1). router r6 runs its decision process for destination 1.0.0.0/8 and selects the route via r2 as its chosen route to reach this preﬁx since this is the only route that it knows. r6 sends u(1.0.0.0/8,r2,as2,med=1) to routers r8 and r7. they both run their decision process and prefer the route advertised by r6, as it contains the smallest med. now, all routers inside as1 forward the packets to 1.0.0.0/8 via link r6-r2 as expected by as2. as router r7 no longer uses the bgp route learned via r3, it must stop advertising it over ibgp sessions and sends w(1.0.0.0/8) over its ibgp sessions with r6 and r8. however, router r7 still keeps the route learned from r3 inside its adj-rib-in. if the r6-r2 link fails, r6 sends w(1.0.0.0/8) over its ibgp sessions and router r7 responds by sending u(1.0.0.0/8,r3,as2,med=98) over its ibgp sessions. in practice, the ﬁfth step of the bgp decision process is slightly more complex, as the routes towards a given preﬁx can be learned from different ases. for example, assume that in ﬁgure hot and cold potato routing, 1.0.0.0/8 is also advertised by as3 (not shown in the ﬁgure) that has peering links with routers r6 and r8. if as3 advertises a route whose med attribute is set to 2 and another with a med set to 3, how should as1‘s router compare the four bgp routes towards 1.0.0.0/8 ? is a med value of 1 from as2 better than a med value of 2 from as3 ? the ﬁfth step of the bgp decision process solves this problem by only comparing the med attribute of the routes learned from the same neighbour as. additional details about the med attribute may be found in rfc 4451. it should be noted that using the med attribute may cause some problems in bgp networks as explained in [gw2002]. in practice, the med attribute is not used on ebgp sessions unless the two domains agree to enable it. the last step of the bgp decision allows the selection of a single route when a bgp router has received several routes that are considered as equal by the ﬁrst six steps of the decision process. this can happen for example in a dual-homed stub attached to two different providers. as shown in the ﬁgure below, router r1 receives two equally good bgp routes towards 1.0.0.0/8. to break the ties, each router is identiﬁed by a unique router-id which in practice is one of the ip addresses assigned to the router. on some routers, the lowest router id step in the bgp decision process is replaced by the selection of the oldest route rfc 5004. preferring the oldest route when breaking ties is used to prefer stable paths over unstable paths. however, a drawback of this approach is that the selection of the bgp routes depends on the arrival times of the corresponding messages. this makes the bgp selection process non-deterministic and can lead to problems that are difﬁcult to debug.
[rfc4193] hinden, r. and haberman, b., unique local ipv6 unicast addresses, rfc 4193, oct. 2005 [rfc4251] ylonen, t. and lonvick, c., the secure shell (ssh) protocol architecture, rfc 4251, jan. 2006 [rfc4264] grifﬁn, t. and huston, g., bgp wedgies, rfc 4264, nov. 2005 [rfc4271] rekhter, y. and li, t. and hares, s., a border gateway protocol 4 (bgp-4), rfc 4271, jan. 2006 [rfc4291] hinden, r. and deering, s., ip version 6 addressing architecture, rfc 4291, feb. 2006 [rfc4301] kent, s. and seo, k., security architecture for the internet protocol, rfc 4301, dec. 2005 [rfc4302] kent, s., ip authentication header, rfc 4302, dec. 2005 [rfc4303] kent, s., ip encapsulating security payload (esp), rfc 4303, dec. 2005 [rfc4340] kohler, e. and handley, m. and floyd, s., datagram congestion control protocol (dccp), rfc
[rfc4648] josefsson, s., the base16, base32, and base64 data encodings, rfc 4648, oct. 2006 [rfc4822] atkinson, r. and fanto, m., ripv2 cryptographic authentication, rfc 4822, feb. 2007 [rfc4838] cerf, v. and burleigh, s. and hooke, a. and torgerson, l. and durst, r. and scott, k. and fall, k.
[rfc4952] klensin, j. and ko, y., overview and framework for internationalized email, rfc 4952, july 2007 [rfc4953] touch, j., defending tcp against spooﬁng attacks, rfc 4953, july 2007 [rfc4954] simeborski, r. and melnikov, a., smtp service extension for authentication, rfc 4954, july 2007 [rfc4963] heffner, j. and mathis, m. and chandler, b., ipv4 reassembly errors at high data rates, rfc 4963,
[rfc4987] eddy, w., tcp syn flooding attacks and common mitigations, rfc 4987, aug. 2007 [rfc5004] chen, e. and sangli, s., avoid bgp best path transitions from one external to another, rfc 5004,
the best solution to allow bgp routers to distribute, inside an as, all the routes learned over bgp sessions is to establish bgp sessions among all the bgp routers inside the as. in practice, there are two types of bgp sessions :
in practice, each bgp router inside a domain maintains an ibgp session with every other bgp router in the domain 34. this creates a full-mesh of ibgp sessions among all bgp routers of the domain. ibgp sessions, like ebgp sessions run over tcp connections. note that in contrast with ebgp sessions that are established between directly connected routers, ibgp sessions are often established between routers that are not directly connected. an important point to note about ibgp sessions is that a bgp router only advertises a route over an ibgp session provided that :
a bgp router does not advertise a route that it has learned over an ibgp session over another ibgp session. note that a router can, of course, advertise over an ebgp session a route that it has learned over an ibgp session. this difference between the behaviour of a bgp router over ibgp and ebgp session is due to the utilisation of a full-mesh of ibgp sessions. consider a network containing three bgp routers : a, b and c interconnected via a full-mesh of ibgp sessions. if router a learns a route towards preﬁx p from router b, router a does not need to advertise the received route to router c since router c also learns the same route over the c-b ibgp session. let us consider what happens when router r1 sends to understand the utilisation of an ibgp session, u(194.100.0.0/23,195.100.0.1,as10) in the network shown below. this bgp message is processed by r2 which advertises it over its ibgp session with r4. the bgp update sent by r2 contains the same nexthop and the same as-path as in the bgp update received by r2. r4 then sends u(194.100.0.0/23,195.100.0.5,as20:as10) to r3. note that the bgp nexthop and the as-path are only updated 35 when a bgp route is advertised over an ebgp session.
note: loopback interfaces and ibgp sessions in addition to their physical interfaces, routers can also be conﬁgured with a special loopback interface. a loopback interface is a software interface that is always up. when a loopback interface is conﬁgured on a router, the address associated to this interface is advertised by the intradomain routing protocol. consider for example
34 using a full-mesh of ibgp sessions is suitable in small networks. however, this solution does not scale in large networks containing ibgp sessions must be established in a domain containing n bgp routers. large domains use either
hundreds or more routers since n×(n−1) route reﬂection rfc 4456 or confederations rfc 5065 to scale their ibgp, but this goes beyond this introduction.
as20as30as10194.100.2.0/23195.100.0.1195.100.0.2195.100.0.6195.100.0.0/30195.100.0.4/30194.100.4.0/23195.100.0.8/30195.100.0.9195.100.0.10ebgpebgpibgp194.100.0.0/23195.100.0.5r1r4r2r3saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
in the example above, the mta running on mta.example.org opens a tcp connection to the smtp server on host smtp.example.com. the lines preﬁxed with s: (resp. c:) are the responses sent by the server (resp. the commands sent by the client). the server sends its greetings as soon as the tcp connection has been established. the client then sends the ehlo command with its fully qualiﬁed domain name. the server replies with reply-code 250 and sends its greetings. the smtp association can now be used to exchange an email. to send an email, the client must ﬁrst provide the address of the recipient with rcpt to:. then it uses the mail from: with the address of the sender. both the recipient and the sender are accepted by the server. the client can now issue the data command to start the transfer of the email message. after having received the 354 reply code, the client sends the headers and the body of its email message. the client indicates the end of the message by sending a line containing only the . (dot) character 15. the server conﬁrms that the email message has been queued for delivery or transmission with a reply code of 250. the client issues the quit command to close the session and the server conﬁrms with reply-code 221, before closing the tcp connection.
note: open smtp relays and spam since its creation in 1971, email has been a very useful tool that is used by many users to exchange lots of information. in the early days, all smtp servers were open and anyone could use them to forward emails towards their ﬁnal destination. unfortunately, over the years, some unscrupulous users have found ways to use email for marketing purposes or to send malware. the ﬁrst documented abuse of email for marketing purposes occurred in 1978 when a marketer who worked for a computer vendor sent a marketing email to many arpanet users. at that time, the arpanet could only be used for research purposes and this was an abuse of the acceptable use policy. unfortunately, given the extremely low cost of sending emails, the problem of unsolicited emails has not stopped. unsolicited emails are now called spam and a study carried out by enisa in 2009 reveals that 95% of email was spam and this number seems to continue to grow. this places a burden on the email infrastructure of internet service providers and large companies that need to process many useless messages. given the amount of spam messages, smtp servers are no longer open rfc 5068. several extensions to smtp have been developed in recent years to deal with this problem. for example, the smtp authentication scheme deﬁned in rfc 4954 can be used by an smtp server to authenticate a client. several techniques have also been proposed to allow smtp servers to authenticate the messages sent by their users rfc 4870 rfc 4871 .
when the ﬁrst versions of smtp were designed, the internet was composed of minicomputers that were used by an entire university department or research lab. these minicomputers were used by many users at the same time. email was mainly used to send messages from a user on a given host to another user on a remote host. at that time, smtp was the only protocol involved in the delivery of the emails as all hosts attached to the network were running an smtp server. on such hosts, an email destined to local users was delivered by placing the email in a special directory or ﬁle owned by the user. however, the introduction of personal computers in the 1980s, changed this environment. initially, users of these personal computers used applications such as telnet to open a remote session on the local minicomputer to read their email. this was not user-friendly. a better solution appeared with the development of user friendly email client applications on personal computers. several protocols were designed to allow these client applications to retrieve the email messages destined to a user from his/her server. two of these protocols became popular and are still used today. the post ofﬁce protocol (pop), deﬁned in rfc 1939, is the simplest one. it allows a client to download all the messages destined to a given user from his/her email server. we describe pop brieﬂy in this section. the second protocol is the internet message access protocol (imap), deﬁned in rfc 3501. imap is more powerful, but also more complex than pop. imap was designed to allow client applications to efﬁciently access in real-time to messages stored in various folders on servers. imap
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
the jumbogram option contains the packet length as a 32 bits ﬁeld. such packets can only be sent from a source to a destination if all the routers on the path support this option. however, as of this writing it does not seem that the jumbogram option has been implemented. the router alert option deﬁned in rfc 2711 is the second example of a hop-by-hop option. the packets that contain this option should be processed in a special way by intermediate routers. this option is used for ip packets that carry resource reservation protocol (rsvp) messages. its usage is explained later. the type 0 routing header deﬁned in rfc 2460 is an example of an ipv6 option that must be processed by some routers. this option is encoded as shown below.
the type 0 routing option was intended to allow a host to indicate a loose source route that should be followed by a packet by specifying the addresses of some of the routers that must forward this packet. unfortunately, further work with this routing header, including an entertaining demonstration with scapy [be2007] , revealed some severe security problems with this routing header. for this reason, loose source routing with the type 0 routing header has been removed from the ipv6 speciﬁcation rfc 5095. in ipv6, fragmentation is performed exclusively by the source host and relies on the fragmentation header. this 64 bits header is composed of six ﬁelds :
• a next header ﬁeld that indicates the type of the header that follows the fragmentation header • a reserved ﬁeld set to 0. • the fragment offset is a 13-bit unsigned integer that contains the offset, in 8 bytes units, of the data following
• the more ﬂag, which is set to 0 in the last fragment of a packet and to 1 in all other fragments. • the 32 bits identiﬁcation ﬁeld indicates to which original packet a fragment belongs. when a host sends fragmented packets, it should ensure that it does not reuse the same identiﬁcation ﬁeld for packets sent to the same destination during a period of msl seconds. this is easier with the 32 bits identiﬁcation used in the ipv6 fragmentation header, than with the 16 bits identiﬁcation ﬁeld of the ipv4 header.
some ipv6 implementations send the fragments of a packet in increasing fragment offset order, starting from the ﬁrst fragment. others send the fragments in reverse order, starting from the last fragment. the latter solution can be advantageous for the host that needs to reassemble the fragments, as it can easily allocate the buffer required to
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
the easiest way to understand the operation of arp is to consider the simple network shown above and assume that host 10.0.1.22/24 needs to send an ipv4 packet to host 10.0.1.8. as this ip address belongs to the same subnet, the packet must be sent directly to its destination via the datalink layer service. to use this service, the sending host must ﬁnd the datalink layer address that is attached to host 10.0.1.8. each ipv4 host maintains an arp cache containing the list of all mappings between ipv4 addresses and datalink layer addresses that it knows. when an ipv4 hosts boots, its arp cache is empty. 10.0.1.22 thus ﬁrst consults its arp cache. as the cache does not contain the requested mapping, host 10.0.1.22 sends a broadcast arp query frame on the lan. the frame contains the datalink layer address of the sending host (a) and the requested ipv4 address (10.0.1.8). this broadcast frame is received by all devices on the lan and only the host that owns the requested ipv4 address replies by returning a unicast arp reply frame with the requested mapping. upon reception of this reply, the sending host updates its arp cache and sends the ipv4 packet by using the datalink layer service. to deal with devices that move or whose addresses are reconﬁgured, most arp implementations remove the cache entries that have not been used for a few minutes. some implementations re-validate arp cache entries from time to time by sending arp queries 13.
note: security issues with the address resolution protocol arp is an old and widely used protocol that was unfortunately designed when security issues were not a concern. arp is almost insecure by design. hosts using arp can be subject to several types of attack. first, a malicious host could create a denial of service attack on a lan by sending random replies to the received arp queries. this would pollute the arp cache of the other hosts on the same lan. on a ﬁxed network, such attacks can be detected by the system administrator who can physically remove the malicious hosts from the lan. on a wireless network, removing a malicious host is much more difﬁcult. a second type of attack are the man-in-the-middle attacks. this name is used for network attacks where the attacker is able to read and possibly modify all the messages sent by the attacked devices. such an attack is possible in a lan. assume, in the ﬁgure above, that host 10.0.1.9 is malicious and would like to receive and modify all the packets sent by host 10.0.1.22 to host 10.0.1.8. this can be achieved easily if host 10.0.1.9 manages, by sending fake arp replies, to convince host 10.0.1.22 (resp. 10.0.1.8) that its own datalink layer address must be used to reach 10.0.1.8 (resp. 10.0.1.22).
arp is used by all devices that are connected to a lan and implement ipv4. both routers and endhosts implement arp. when a host needs to send an ipv4 packet to a destination outside of its local subnet, it must ﬁrst send the packet to one of the routers that reside on this subnet. consider for example the network shown in the ﬁgure below. each host is conﬁgured with an ipv4 address in the 10.0.1.0/24 subnet and uses 10.0.1.1 as its default router. to send a packet to address 1.2.3.4, host 10.0.1.8 will ﬁrst need to know the datalink layer of the default router. it will thus send an arp request for 10.0.1.1. upon reception of the arp reply, host 10.0.1.8 updates its arp table and sends its packet in a frame to its default router. the router will then forward the packet towards its ﬁnal destination.
in the early days of the internet, ip addresses were manually conﬁgured on both hosts and routers and almost never changed. however, this manual conﬁguration can be complex 14 and often causes errors that are sometimes difﬁcult to debug. recent tcp/ip implementations are able to detect some of these misconﬁgurations. for example, if two hosts are attached to the same subnet with the same ipv4 address they will be unable to communicate. to detect this problem hosts send an arp request for their conﬁgured address each time their addressed is changed rfc 5227. if they receive an answer to this arp request, they trigger an alarm or inform the system administrator.
13 see chapter 28 of [benvenuti2005] for a description of the implementation of arp in the linux kernel. 14 for example, consider all the options that can be speciﬁed for the ifconﬁg utility<http://en.wikipedia.org/wiki/ifconﬁg> on unix hosts.
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
in addition, the ascii table also deﬁnes several non-printable or control characters. these characters were designed to allow an application to control a printer or a terminal. these control characters include cr and lf, that are used to terminate a line, and the bell character which causes the terminal to emit a sound.
the ascii characters are encoded as a seven bits ﬁeld, but transmitted as an eight-bits byte whose high order bit is usually set to 0. bytes are always transmitted starting from the high order or most signiﬁcant bit. most applications exchange strings that are composed of ﬁxed or variable numbers of characters. a common solution to deﬁne the character strings that are acceptable is to deﬁne them as a grammar using a backus-naur form (bnf) such as the augmented bnf deﬁned in rfc 5234. a bnf is a set of production rules that generate all valid character strings. for example, consider a networked application that uses two commands, where the user can supply a username and a password. the bnf for this application could be deﬁned as shown in the ﬁgure below.
the example above deﬁnes several terminals and two commands : usercommand and passwordcommand. the alpha terminal contains all letters in upper and lower case. in the alpha rule, %x41 corresponds to ascii character code 41 in hexadecimal, i.e. capital a. the cr and lf terminals correspond to the carriage return and linefeed control characters. the crlf rule concatenates these two terminals to match the standard end of line termination. the digit terminal contains all digits. the sp terminal corresponds to the white space characters. the usercommand is composed of two strings separated by white space. in the abnf rules that deﬁne the messages used by internet applications, the commands are case-insensitive. the rule “user” corresponds to all possible cases of the letters that compose the word between brackets, e.g. user, user, user, user, ... a username contains at least one letter and up to 8 letters. user names are case-sensitive as they are not deﬁned as a string between brackets. the password rule indicates that a password starts with a letter and can contain any number of letters or digits. the white space and the control characters cannot appear in a password deﬁned by the above rule. besides character strings, some applications also need to exchange 16 bits and 32 bits ﬁelds such as integers. a naive solution would have been to send the 16- or 32-bits ﬁeld as it is encoded in the host’s memory. unfortunately, there are different methods to store 16- or 32-bits ﬁelds in memory. some cpus store the most signiﬁcant byte of a 16-bits ﬁeld in the ﬁrst address of the ﬁeld while others store the least signiﬁcant byte at this location. when networked applications running on different cpus exchange 16 bits ﬁelds, there are two possibilities to transfer them over the transport service :
• send the most signiﬁcant byte followed by the least signiﬁcant byte • send the least signiﬁcant byte followed by the most signiﬁcant byte
the ﬁrst possibility was named big-endian in a note written by cohen [cohen1980] while the second was named little-endian. vendors of cpus that used big-endian in memory insisted on using big-endian encoding in networked applications while vendors of cpus that used little-endian recommended the opposite. several studies were written on the relative merits of each type of encoding, but the discussion became almost a religious issue [cohen1980]. eventually, the internet chose the big-endian encoding, i.e. multi-byte ﬁelds are always transmitted by sending the most signiﬁcant byte ﬁrst, rfc 791 refers to this encoding as the network-byte order. most
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
the simple mail transfer protocol (smtp) deﬁned in rfc 5321 is a client-server protocol. the smtp speciﬁcation distinguishes between ﬁve types of processes involved in the delivery of email messages. email messages are composed on a mail user agent (mua). the mua is usually either an email client or a webmail. the mua sends the email message to a mail submission agent (msa). the msa processes the received email and forwards it to the mail transmission agent (mta). the mta is responsible for the transmission of the email, directly or via intermediate mtas to the mta of the destination domain. this destination mta will then forward the message to the mail delivery agent (mda) where it will be accessed by the recipient’s mua. smtp is used for the interactions between mua and msa 13, msa-mta and mta-mta. smtp is a text-based protocol like many other application-layer protocols on the internet. it relies on the bytestream service. servers listen on port 25. clients send commands that are each composed of one line of ascii text terminated by cr+lf. servers reply by sending ascii lines that contain a three digit numerical error/success code and optional comments. the smtp protocol, like most text-based protocols, is speciﬁed as a bnf. the full bnf is deﬁned in rfc 5321. the main smtp commands are deﬁned by the bnf rules shown in the ﬁgure below.
in this bnf, atext corresponds to printable ascii characters. this bnf rule is deﬁned in rfc 5322. the ﬁve main commands are ehlo, mail from:, rcpt to:, data and quit 14. postmaster is the alias of the system administrator who is responsible for a given domain or smtp server. all domains must have a postmaster alias. the smtp responses are deﬁned by the bnf shown in the ﬁgure below.
14 the ﬁrst versions of smtp used helo as the ﬁrst command sent by a client to a smtp server. when smtp was extended to support newer features such as 8 bits characters, it was necessary to allow a server to recognise whether it was interacting with a client that supported the extensions or not. ehlo became mandatory with the publication of rfc 2821.
the reply code indicates whether the command was successful or not. a reply code of 2xy indicates that the command has been accepted. a reply code of 3xy indicates that the command has been accepted, but additional information from the client is expected. a reply code of 4xy indicates a transient negative reply. this means that for some reason, which is indicated by either the other digits or the comment, the command cannot be processed immediately, but there is some hope that the problem will only be transient. this is basically telling the client to try the same command again later. in contrast, a reply code of 5xy indicates a permanent failure or error. in this case, it is useless for the client to retry the same command later. other application layer protocols such as ftp rfc 959 or http rfc 2616 use a similar structure for their reply codes. additional details about the other reply codes may be found in rfc 5321. examples of smtp reply codes include the following :
syntax error, command unrecognized syntax error in parameters or arguments command not implemented bad sequence of commands <domain> service ready <domain> service closing transmission channel <domain> service not available, closing transmission channel requested mail action okay, completed requested mail action not taken: mailbox unavailable requested action not taken: insufficient system storage requested action not taken: mailbox unavailable start mail input; end with <crlf>.<crlf>
the ﬁrst four reply codes correspond to errors in the commands sent by the client. the fourth reply code would be sent by the server when the client sends commands in an incorrect order (e.g. the client tries to send an email before providing the destination address of the message). reply code 220 is used by the server as the ﬁrst message when it agrees to interact with the client. reply code 221 is sent by the server before closing the underlying transport connection. reply code 421 is returned when there is a problem (e.g. lack of memory/disk resources) that prevents the server from accepting the transport connection. reply code 250 is the standard positive reply that indicates the success of the previous command. reply codes 450 and 452 indicate that the destination mailbox is temporarily unavailable, for various reasons, while reply code 550 indicates that the mailbox does not exist or cannot be used for policy reasons. reply code 354 indicates that the client can start transmitting its email message. the transfer of an email message is performed in three phases. during the ﬁrst phase, the client opens a transport connection with the server. once the connection has been established, the client and the server exchange greetings messages (ehlo command). most servers insist on receiving valid greeting messages and some of them drop the underlying transport connection if they do not receive a valid greeting. once the greetings have been exchanged, the email transfer phase can start. during this phase, the client transfers one or more email messages by indicating the email address of the sender (mail from: command), the email address of the recipient (rcpt to: command) followed by the headers and the body of the email message (data command). once the client has ﬁnished sending all its queued email messages to the smtp server, it terminates the smtp association (quit command). a successful transfer of an email message is shown below
s: 220 smtp.example.com esmtp mta information c: ehlo mta.example.org s: 250 hello mta.example.org, glad to meet you c: mail from:<alice@example.org> s: 250 ok c: rcpt to:<bob@example.com> s: 250 ok c: data s: 354 end data with <cr><lf>.<cr><lf> c: from: "alice doe" <alice@example.org> c: to: bob smith <bob@example.com> c: date: mon, 9 mar 2010 18:22:32 +0100 c: subject: hello c: c: hello bob c: this is a small message containing 4 lines of text. c: best regards,
12. the dns protocol can run over udp and over tcp. most dns servers prefer to use udp because it consumes fewer resources on the server. however, tcp is useful when a large answer is expected or when a large answer must. you can force the utilisation of tcp by using dig +tcp. use tcp and udp to query a root dns server. is it faster to receive an answer via tcp or via udp ?
many internet protocols are ascii-based protocols where the client sends requests as one line of ascii text terminated by crlf and the server replies with one of more lines of ascii text. using such ascii messages has several advantages compared to protocols that rely on binary encoded messages
• it is often easy to write a small prototype that implements a part of the protocol • it is possible to test a server manually by using telnet telnet is a protocol that allows to obtain a terminal on a remote server. for this, telnet opens a tcp connection with the remote server on port 23. however, most telnet implementations allow the user to specify an alternate port as telnet hosts port when used with a port number as parameter, telnet opens a tcp connection to the remote host on the speciﬁed port. telnet can thus be used to test any server using an ascii-based protocol on top of tcp. note that if you need to stop a running telnet session, ctrl-c will not work as it will be sent by telnet to the remote host over the tcp connection. on many telnet implementations you can type ctrl-] to freeze the tcp connection and return to the telnet interface.
2. same question when alice sends an email to her friend trudy, trudy@gmail.com. 3. before the advent of webmail and feature rich mailers, email was written and read by using command line tools on servers. using your account on sirius.info.ucl.ac.be use the /bin/mail command line tool to send an email to yourself on this host. this server stores local emails in the /var/mail directory with one ﬁle per user. check with /bin/more the content of your mail ﬁle and try to understand which lines have been added by the server in the header of your email.
4. use your preferred email tool to send an email message to yourself containing a single line of text. most email tools have the ability to show the source of the message, use this function to look at the message that you sent and the message that you received. can you ﬁnd an explanation for all the lines that have been added to your single line email 24 ?
6. when using smtp, how do you recognise a positive reply from a negative one ? 7. a smtp server is a daemon process that can fail due to a bug or lack of resources (e.g. memory). network administrators often install tools 26 that regularly connect to their servers to check that they are operating correctly. a simple solution is to open a tcp connection on port 25 to the smtp server’s host 27 . if the connection is established, this implies that there is a process listening. what is the reply sent by the smtp server when you type the following command ? telnet cnp3.info.ucl.ac.be 25
24 since rfc 821, smtp has evolved a lot due notably to the growing usage of email and the need to protect the email system against spammers. it is unlikely that you will be able to explain all the additional lines that you will ﬁnd in email headers, but we’ll discuss them together.
25 a shorter description of the smtp protocol may be found on wikipedia at http://en.wikipedia.org/wiki/simple_mail_transfer_protocol 26 there are many monitoring tools available. nagios is a very popular open source monitoring system. 27 note that using telnet to connect to a remote host on port 25 may not work in all networks. due to the spam problem, many isp networks do not allow their customers to use port tcp 25 directly and force them to use the isp’s mail relay to forward their email. thanks to this, if a software sending spam has been installed on the pc of one of the isp’s customers, this software will not be able to send a huge amount of spam. if you connect to nostromo.info.ucl.ac.be from the ﬁxed stations in ingi’s lab, you should not be blocked.
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
• client software, that allows users to easily create and read email messages • software, that allows servers to efﬁciently exchange email messages
we will ﬁrst discuss the format of email messages followed by the protocols that are used on today’s internet to exchange and retrieve emails. other email systems have been developed in the past [bush1993] [genilloud1990] [gc2000], but today most email solutions have migrated to the internet email. information about the software that is used to compose and deliver emails may be found on wikipedia among others, for both email clients and email servers. more detailed information about the full internet mail architecture may be found in rfc 5598. email messages, like postal mail, are composed of two parts :
• a header that plays the same role as the letterhead in regular mail. it contains metadata about the message. • the body that contains the message itself.
email messages are entirely composed of lines of ascii characters. each line can contain up to 998 characters and is terminated by the cr and lf control characters rfc 5322. the lines that compose the header appear before the message body. an empty line, containing only the cr and lf characters, marks the end of the header. this is illustrated in the ﬁgure below.
the email header contains several lines that all begin with a keyword followed by a colon and additional information. the format of email messages and the different types of header lines are deﬁned in rfc 5322. two of these header lines are mandatory and must appear in all email messages :
• the sender address. this header line starts with from:. this contains the (optional) name of the sender followed by its email address between < and >. email addresses are always composed of a username followed by the @ sign and a domain name.
• the date. this header line starts with date:. rfc 5322 precisely deﬁnes the format used to encode a date. other header lines appear in most email messages. the subject: header line allows the sender to indicate the topic discussed in the email. three types of header lines can be used to specify the recipients of a message :
• the cc: header line is used by the sender to provide a list of email addresses that must receive a carbon copy of the message. several addresses can be listed in this header line, separated by commas. all recipients of the email message receive the to: and cc: header lines.
• the bcc: header line is used by the sender to provide a list of comma separated email addresses that must receive a blind carbon copy of the message. the bcc: header line is not delivered to the recipients of the email message.
from: bob smith <bob@machine.example> to: alice doe <alice@example.net>, alice smith <alice@machine.example> subject: hello date: mon, 8 mar 2010 19:55:06 -0600
note the empty line after the date: header line; this empty line contains only the cr and lf characters, and marks the boundary between the header and the body of the message. several other optional header lines are deﬁned in rfc 5322 and elsewhere 12. furthermore, many email clients and servers deﬁne their own header lines starting from x-. several of the optional header lines deﬁned in rfc 5322 are worth being discussed here :
• the message-id: header line is used to associate a “unique” identiﬁer to each email. email identiﬁers are usually structured like string@domain where string is a unique character string or sequence number chosen by the sender of the email and domain the domain name of the sender. since domain names are unique, a host can generate globally unique message identiﬁers concatenating a locally unique identiﬁer with its domain name.
• the received: header line is used when an email message is processed by several servers before reaching its destination. each intermediate email server adds a received: header line. these header lines are useful to debug problems in delivering email messages.
the ﬁgure below shows the header lines of one email message. the message originated at a host named wira.ﬁrstpr.com.au and was received by smtp3.sgsi.ucl.ac.be. the received: lines have been wrapped for readability.
by mmp.sipr-dc.ucl.ac.be (sun java(tm) system messaging server 7u3-15.01 64bit (built feb 12 2010)) with esmtp id <0kyy00l85li5jle0@mmp.sipr-dc.ucl.ac.be>; mon, 08 mar 2010 11:37:17 +0100 (cet)
by localhost (core3.amsl.com [127.0.0.1]) (amavisd-new, port 10024) with esmtp id erw8ih2v8vqa for <rrg@core3.amsl.com>; mon, 08 mar 2010 02:36:36 -0800 (pst)
date: mon, 08 mar 2010 21:36:38 +1100 from: robin whittle <rw@firstpr.com.au> subject: re: [rrg] recommendation and what happens next in-reply-to: <c7b9c21a.4fab%tony.li@tony.li> to: rrg <rrg@irtf.org> message-id: <4b94d336.7030504@firstpr.com.au>
the simple mail transfer protocol (smtp) deﬁned in rfc 5321 is a client-server protocol. the smtp speciﬁcation distinguishes between ﬁve types of processes involved in the delivery of email messages. email messages are composed on a mail user agent (mua). the mua is usually either an email client or a webmail. the mua sends the email message to a mail submission agent (msa). the msa processes the received email and forwards it to the mail transmission agent (mta). the mta is responsible for the transmission of the email, directly or via intermediate mtas to the mta of the destination domain. this destination mta will then forward the message to the mail delivery agent (mda) where it will be accessed by the recipient’s mua. smtp is used for the interactions between mua and msa 13, msa-mta and mta-mta. smtp is a text-based protocol like many other application-layer protocols on the internet. it relies on the bytestream service. servers listen on port 25. clients send commands that are each composed of one line of ascii text terminated by cr+lf. servers reply by sending ascii lines that contain a three digit numerical error/success code and optional comments. the smtp protocol, like most text-based protocols, is speciﬁed as a bnf. the full bnf is deﬁned in rfc 5321. the main smtp commands are deﬁned by the bnf rules shown in the ﬁgure below.
in this bnf, atext corresponds to printable ascii characters. this bnf rule is deﬁned in rfc 5322. the ﬁve main commands are ehlo, mail from:, rcpt to:, data and quit 14. postmaster is the alias of the system administrator who is responsible for a given domain or smtp server. all domains must have a postmaster alias. the smtp responses are deﬁned by the bnf shown in the ﬁgure below.
14 the ﬁrst versions of smtp used helo as the ﬁrst command sent by a client to a smtp server. when smtp was extended to support newer features such as 8 bits characters, it was necessary to allow a server to recognise whether it was interacting with a client that supported the extensions or not. ehlo became mandatory with the publication of rfc 2821.
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
note: a note on timers the ﬁrst rip implementations sent their distance vector exactly every 30 seconds. this worked well in most networks, but some researchers noticed that routers were sometimes overloaded because they were processing too many distance vectors at the same time [fj1994]. they collected packet traces in these networks and found that after some time the routers’ timers became synchronised, i.e. almost all routers were sending their distance vectors at almost the same time. this synchronisation of the transmission times of the distance vectors caused an overload on the routers’ cpu but also increased the convergence time of the protocol in some cases. this was mainly due to the fact that all routers set their timers to the same expiration time after having processed the received distance vectors. sally floyd and van jacobson proposed in [fj1994] a simple solution to solve this synchronisation problem. instead of advertising their distance vector exactly after 30 seconds, a router should send its next distance vector after a delay chosen randomly in the [15,45] interval rfc 2080. this randomisation of the delays prevents the synchronisation that occurs with a ﬁxed delay and is now a recommended practice for protocol designers.
link-state routing protocols are used in ip networks. open shortest path first (ospf), deﬁned in rfc 2328, is the link state routing protocol that has been standardised by the ietf. the last version of ospf, which supports ipv6, is deﬁned in rfc 5340. ospf is frequently used in enterprise networks and in some isp networks. however, isp networks often use the is-is link-state routing protocol [iso10589] , which was developed for the iso clnp protocol but was adapted to be used in ip rfc 1195 networks before the ﬁnalisation of the standardisation of ospf. a detailed analysis of isis and ospf may be found in [bmo2006] and [perlman2000]. additional information about ospf may be found in [moy1998]. compared to the basics of link-state routing protocols that we discussed in section link state routing, there are some particularities of ospf that are worth discussing. first, in a large network, ﬂooding the information about all routers and links to thousands of routers or more may be costly as each router needs to store all the information about the entire network. a better approach would be to introduce hierarchical routing. hierarchical routing divides the network into regions. all the routers inside a region have detailed information about the topology of the region but only learn aggregated information about the topology of the other regions and their interconnections. ospf supports a restricted variant of hierarchical routing. in ospf’s terminology, a region is called an area. ospf imposes restrictions on how a network can be divided into areas. an area is a set of routers and links that are grouped together. usually, the topology of an area is chosen so that a packet sent by one router inside the area can reach any other router in the area without leaving the area 23 . an ospf area contains two types of routers rfc 2328:
• internal router : a router whose directly connected networks belong to the area • area border routers : a router that is attached to several areas.
for example, the network shown in the ﬁgure below has been divided into three areas : area 1, containing routers r1, r3, r4, r5 and ra, area 2 containing r7, r8, r9, r10, rb and rc. ospf areas are identiﬁed by a 32 bit integer, which is sometimes represented as an ip address. among the ospf areas, area 0, also called the backbone area has a special role. the backbone area groups all the area border routers (routers ra, rb and rc in the ﬁgure below) and the routers that are directly connected to the backbone routers but do not belong to another area (router
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
• client software, that allows users to easily create and read email messages • software, that allows servers to efﬁciently exchange email messages
we will ﬁrst discuss the format of email messages followed by the protocols that are used on today’s internet to exchange and retrieve emails. other email systems have been developed in the past [bush1993] [genilloud1990] [gc2000], but today most email solutions have migrated to the internet email. information about the software that is used to compose and deliver emails may be found on wikipedia among others, for both email clients and email servers. more detailed information about the full internet mail architecture may be found in rfc 5598. email messages, like postal mail, are composed of two parts :
• a header that plays the same role as the letterhead in regular mail. it contains metadata about the message. • the body that contains the message itself.
email messages are entirely composed of lines of ascii characters. each line can contain up to 998 characters and is terminated by the cr and lf control characters rfc 5322. the lines that compose the header appear before the message body. an empty line, containing only the cr and lf characters, marks the end of the header. this is illustrated in the ﬁgure below.
the email header contains several lines that all begin with a keyword followed by a colon and additional information. the format of email messages and the different types of header lines are deﬁned in rfc 5322. two of these header lines are mandatory and must appear in all email messages :
• the sender address. this header line starts with from:. this contains the (optional) name of the sender followed by its email address between < and >. email addresses are always composed of a username followed by the @ sign and a domain name.
• the date. this header line starts with date:. rfc 5322 precisely deﬁnes the format used to encode a date. other header lines appear in most email messages. the subject: header line allows the sender to indicate the topic discussed in the email. three types of header lines can be used to specify the recipients of a message :
• the cc: header line is used by the sender to provide a list of email addresses that must receive a carbon copy of the message. several addresses can be listed in this header line, separated by commas. all recipients of the email message receive the to: and cc: header lines.
• the bcc: header line is used by the sender to provide a list of comma separated email addresses that must receive a blind carbon copy of the message. the bcc: header line is not delivered to the recipients of the email message.
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
tcp connection on port 80 and check that the tcp connection is accepted by the remote host. however, as http is an ascii-based protocol, it is also very easy to write a small script that downloads a web page on the server and compares its content with the expected one. use telnet to verify that a web server is running on host rembrandt.info.ucl.ac.be 31
3. instead of using telnet on port 80, it is also possible to use a command-line tool such as curl use curl with the –trace-ascii traceﬁle option to store in traceﬁle all the information exchanged by curl when accessing the server.
• what is the version of http used by curl ? • can you explain the different headers placed by curl in the request ? • can you explain the different headers found in the response ?
4. http 1.1, speciﬁed in rfc 2616 forces the client to use the host: in all its requests. http 1.0 does not deﬁne the host: header, by most implementations support it. by using telnet and curl retrieve the ﬁrst page of the http://totem.info.ucl.ac.be webserver by sending http requests with and without the host: header. explain the difference between the two 32 .
7. the headers sent in a http request allow the client to provide additional information to the server. one of these headers is the language header that allows to indicate the preferred language of the client 33. for example, curl -haccept-language:en http://www.google.be’ will send to ‘http://www.google.be a http request indicating english (en) as the preferred language. does google provide a different page in french (fr) and walloon (wa) ? same question for http://www.uclouvain.be (given the size of the homepage, use diff to compare the different pages retrieved from www.uclouvain.be)
9. what is a http cookie ? list some advantages and drawbacks of using cookies on web servers. 10. you are now responsible for the http://www.belgium.be. the government has built two datacenters containing 1000 servers each in antwerp and namur. this website contains static information and your objective is to balance the load between the different servers and ensures that the service remains up even if one of the datacenters is disconnected from the internet due to ﬂooding or other natural disasters. what are the techniques that you can use to achieve this goal ?
31 the minimum command sent to a http server is get / http/1.0 followed by crlf and a blank line 32 use dig to ﬁnd the ip address used by totem.info.ucl.ac.be 33 the list of available language tags can be found at http://www.loc.gov/standards/iso639-2/php/code_list.php additional information about
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
tcp uses the segment losses as an indication of congestion. when there are no losses, the network is assumed to be not congested. this implies that congestion is the main cause of packet losses. this is true in wired networks, but unfortunately not always true in wireless networks. another solution is to rely on explicit feedback. this is the solution proposed in the decbit congestion control scheme [rj1995] and used in frame relay and atm networks. this explicit feedback can be implemented in two ways. a ﬁrst solution would be to deﬁne a special message that could be sent by routers to hosts when they are congested. unfortunately, generating such messages may increase the amount of congestion in the network. such a congestion indication packet is thus discouraged rfc 1812. a better approach is to allow the intermediate routers to indicate, in the packets that they forward, their current congestion status. binary feedback can be encoded by using one bit in the packet header. with such a scheme, congested routers set a special bit in the packets that they forward while non-congested routers leave this bit unmodiﬁed. the destination host returns the congestion status of the network in the acknowledgements that it sends. details about such a solution in ip networks may be found in rfc 3168. unfortunately, as of this writing, this solution is still not deployed despite its potential beneﬁts.
the tcp congestion control scheme was initially proposed by van jacobson in [jacobson1988]. the current speciﬁcation may be found in rfc 5681. tcp relies on additive increase and multiplicative decrease (aimd). to implement aimd, a tcp host must be able to control its transmission rate. a ﬁrst approach would be to use timers and adjust their expiration times in function of the rate imposed by aimd. unfortunately, maintaining such timers for a large number of tcp connections can be difﬁcult. instead, van jacobson noted that the rate of tcp congestion can be artiﬁcially controlled by constraining its sending window. a tcp connection cannot send data rtt where window is the maximum between the host’s sending window and the window advertised faster than window by the receiver. tcp’s congestion control scheme is based on a congestion window. the current value of the congestion window (cwnd) is stored in the tcb of each tcp connection and the window that can be used by the sender is constrained by min(cwnd, rwin, swin) where swin is the current sending window and rwin the last received receive window. the additive increase part of the tcp congestion control increments the congestion window by mss bytes every round-trip-time. in the tcp literature, this phase is often called the congestion avoidance phase. the multiplicative decrease part of the tcp congestion control divides the current value of the congestion window once congestion has been detected. when a tcp connection begins, the sending host does not know whether the part of the network that it uses to reach the destination is congested or not. to avoid causing too much congestion, it must start with a small congestion window. [jacobson1988] recommends an initial window of mss bytes. as the additive increase part of the tcp congestion control scheme increments the congestion window by mss bytes every round-trip-time, the tcp connection may have to wait many round-trip-times before being able to efﬁciently use the available bandwidth. this is especially important in environments where the bandwidth × rtt product is high. to avoid waiting too many round-trip-times before reaching a congestion window that is large enough to efﬁciently utilise the network, the tcp congestion control scheme includes the slow-start algorithm. the objective of the tcp slow-start is to quickly reach an acceptable value for the cwnd. during slow-start, the congestion window is doubled every round-trip-time. the slow-start algorithm uses an additional variable in the tcb : sshtresh (slowstart threshold). the ssthresh is an estimation of the last value of the cwnd that did not cause congestion. it is initialised at the sending window and is updated after each congestion event. in practice, a tcp implementation considers the network to be congested once its needs to retransmit a segment. the tcp congestion control scheme distinguishes between two types of congestion :
• mild congestion. tcp considers that the network is lightly congested if it receives three duplicate acknowledgements and performs a fast retransmit. if the fast retransmit is successful, this implies that only one segment has been lost. in this case, tcp performs multiplicative decrease and the congestion window is divided by 2. the slow-start threshold is set to the new value of the congestion window.
• severe congestion. tcp considers that the network is severely congested when its retransmission timer expires. in this case, tcp retransmits the ﬁrst segment, sets the slow-start threshold to 50% of the congestion window. the congestion window is reset to its initial value and tcp performs a slow-start.
the ﬁgure below illustrates the evolution of the congestion window when there is severe congestion. at the beginning of the connection, the sender performs slow-start until the ﬁrst segments are lost and the retransmission timer expires. at this time, the ssthresh is set to half of the current congestion window and the congestion window is reset at one segment. the lost segments are retransmitted as the sender again performs slow-start until the
congestion window reaches the sshtresh. it then switches to congestion avoidance and the congestion window increases linearly until segments are lost and the retransmission timer expires ...
the ﬁgure below illustrates the evolution of the congestion window when the network is lightly congested and all lost segments can be retransmitted using fast retransmit. the sender begins with a slow-start. a segment is lost but successfully retransmitted by a fast retransmit. the congestion window is divided by 2 and the sender immediately enters congestion avoidance as this was a mild congestion.
most tcp implementations update the congestion window when they receive an acknowledgement. if we assume that the receiver acknowledges each received segment and the sender only sends mss sized segments, the tcp congestion control scheme can be implemented using the simpliﬁed pseudo-code 29 below
2. perform the same experiment, but now send a syn segment towards port 7. this port is the default port for the discard service (see services(5)) launched by xinetd(8)). what segment does the server sends in reply ? what happens upon reception of this segment ? explain your answer.
12. the linux tcp/ip stack can be easily conﬁgured by using sysctl(8) to change kernel conﬁguration variables. see http://fasterdata.es.net/tcp-tuning/ip-sysctl-2.6.txt for a recent list of the sysctl variables on the linux tcp/ip stack. try to disable the selective acknowledgements and the rfc1323 timestamp and large window options and open a tcp connection on port 7 on the server by using :manpage:telnet‘(1)‘. check by using tcpdump(1) the effect of these kernel variables on the segments sent by the linux stack in netkit.
13. network administrators sometimes need to verify which networking daemons are active on a server. when logged on the server, several tools can be used to verify this. a ﬁrst solution is to use the netstat(8) command. this command allows you to extract various statistics from the networking stack on the linux kernel. for tcp, netstat can list all the active tcp connections with the state of their fsm. netstat supports the following options that could be useful during this exercises :
• -t requests information about the tcp connections • -n requests numeric output (by default, netstat sends dns queries to resolve ip addresses in hosts and uses /etc/services to convert port number in service names, -n is recommended on netkit machines)
• -e provides more information about the state of the tcp connections • -o provides information about the timers • -a provides information about all tcp connections, not only those in the established state
on the netkit lab, launch a daemon and start a tcp connection by using telnet(1) and use netstat(8) to verify the state of these connections. a second solution to determine which network daemons are running on a server is to use a tool like nmap(1). nmap(1) can be run remotely and thus can provide information about a host on which the system administrator cannot login. use tcpdump(1) to collect the segments sent by nmap(1) running on the client and explain how nmap(1) operates.
the emulated network is composed of three uml machines 32: a client, a server and a router. the client and the server are connected via the router. the client sends data to the server. the link between the router and the client is controlled by using the netem linux kernel module. this module allows us to insert additional delays, reduce the link bandwidth and insert random packet losses.
31 with an emulated network, it is more difﬁcult to obtain quantitative results than with a real network since all the emulated machines need to share the same cpu and memory. this creates interactions between the different emulated machines that do not happen in the real world. however, since the objective of this exercise is only to allow the students to understand the behaviour of the tcp congestion control mechanism, this is not a severe problem. about
see http://linuxgazette.net/135/pfeiffer.html and http://www.cs.helsinki.ﬁ/research/iwtcp/papers/linuxtcp.pdf or the source code of a recent linux. a description of some of the sysctl variables that allow to tune the tcp implementation in the linux kernel may be found in http://fasterdata.es.net/tcp-tuning/linux.html. for this exercise, we have conﬁgured the linux kernel to use the newreno scheme rfc 3782 that is very close to the ofﬁcial standard deﬁned in rfc 5681
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
the longest preﬁx match can be implemented by using different data structures. one possibility is to use a trie. the ﬁgure below shows a trie that encodes six routes having different outgoing interfaces.
note: special ipv4 addresses most unicast ipv4 addresses can appear as source and destination addresses in packets on the global internet. however, it is worth noting that some blocks of ipv4 addresses have a special usage, as described in rfc 5735. these include :
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
the ﬁrst solution to transport ip packets over a serial line was proposed in rfc 1055 and is known as serial line ip (slip). slip is a simple character stufﬁng technique applied to ip packets. slip deﬁnes two special characters : end (decimal 192) and esc (decimal 219). end appears at the beginning and at the end of each transmitted ip packet and the sender adds esc before each end character inside each transmitted ip packet. slip only supports the transmission of ip packets and it assumes that the two communicating hosts/routers have been manually conﬁgured with each other’s ip address. slip was mainly used over links offering bandwidth of often less than 20 kbps. on such a low bandwidth link, sending 20 bytes of ip header followed by 20 bytes of tcp header for each tcp segment takes a lot of time. this initiated the development of a family of compression techniques to efﬁciently compress the tcp/ip headers. the ﬁrst header compression technique proposed in rfc 1144 was designed to exploit the redundancy between several consecutive segments that belong to the same tcp connection. in all these segments, the ip addresses and port numbers are always the same. furthermore, ﬁelds such as the sequence and acknowledgement numbers do not change in a random way. rfc 1144 deﬁned simple techniques to reduce the redundancy found in successive segments. the development of header compression techniques continued and there are still improvements being developed now rfc 5795. while slip was implemented and used in some environments, it had several limitations discussed in rfc 1055. the point-to-point protocol (ppp) was designed shortly after and is speciﬁed in rfc 1548. ppp aims to support ip and other network layer protocols over various types of serial lines. ppp is in fact a family of three protocols that are used together :
1. the point-to-point protocol deﬁnes the framing technique to transport network layer packets. 2. the link control protocol that is used to negotiate options and authenticate the session by using username
3. the network control protocol that is speciﬁc for each network layer protocol. it is used to negotiate options that are speciﬁc for each protocol. for example, ipv4’s ncp rfc 1548 can negotiate the ipv4 address to be used, the ipv4 address of the dns resolver. ipv6’s ncp is deﬁned in rfc 5072.
the ppp framing rfc 1662 was inspired by the datalink layer protocols standardised by itu-t and iso. a typical ppp frame is composed of the ﬁelds shown in the ﬁgure below. a ppp frame starts with a one byte ﬂag containing 01111110. ppp can use bit stufﬁng or character stufﬁng depending on the environment where the protocol is used. the address and control ﬁelds are present for backward compatibility reasons. the 16 bit protocol ﬁeld contains the identiﬁer 3 of the network layer protocol that is carried in the ppp frame. 0x002d is used for an ipv4 packet compressed with rfc 1144 while 0x002f is used for an uncompressed ipv4 packet. 0xc021 is used by the link control protocol, 0xc023 is used by the password authentication protocol (pap). 0x0057 is used for ipv6 packets. ppp supports variable length packets, but lcp can negotiate a maximum packet length. the ppp frame ends with a frame check sequence. the default is a 16 bits crc, but some implementations can negotiate a 32 bits crc. the frame ends with the 01111110 ﬂag.
ppp played a key role in allowing internet service providers to provide dial-up access over modems in the late 1990s and early 2000s. isps operated modem banks connected to the telephone network. for these isps, a key issue was to authenticate each user connected through the telephone network. this authentication was performed by using the extensible authentication protocol (eap) deﬁned in rfc 3748. eap is a simple, but extensible protocol that was initially used by access routers to authenticate the users connected through dialup lines. several authentication methods, starting from the simple username/password pairs to more complex schemes have been
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
[gw2002] grifﬁn, t. and wilfong, g. t., analysis of the med oscillation problem in bgp. in proceedings of the 10th ieee international conference on network protocols (november 12 - 15, 2002). icnp. ieee computer society, washington, dc, 90-99
[gast2002] gast, m., 802.11 wireless networks : the deﬁnitive guide, o’reilly, 2002 [gill2004] gill, v. , lack of priority queuing considered harmful, acm queue, december 2004 [goralski2009] goralski, w., the illustrated network : how tcp/ip works in a modern network, morgan kauf-
[iso10589] information technology — telecommunications and information exchange between systems — intermediate system to intermediate system intra-domain routeing information exchange protocol for use in conjunction with the protocol for providing the connectionless-mode network service (iso 8473), 2002
[jacobson1988] jacobson, v., congestion avoidance and control. in symposium proceedings on communications architectures and protocols (stanford, california, united states, august 16 - 18, 1988). v. cerf, ed. sigcomm ‘88. acm, new york, ny, 314-329.
[kerrisk2010] kerrisk, m., the linux programming interface, no starch press, 2010 [km1995] kent, c. a. and mogul, j. c., fragmentation considered harmful. sigcomm comput. commun. rev.
[kps2003] kaufman, c., perlman, r., and sommerfeld, b. dos protection for udp-based protocols. in proceedings of the 10th acm conference on computer and communications security (washington d.c., usa, october 27 - 30, 2003). ccs ‘03. acm, new york, ny, 2-7.
[kt1975] kleinrock, l., tobagi, f., packet switching in radio channels: part i–carrier sense multiple-access modes and their throughput-delay characteristics, ieee transactions on communications, vol. com-23, no. 12, pp. 1400-1416, december 1975.
[kw2009] katz, d., ward, d., bidirectional forwarding detection, rfc 5880, june 2010 [kz1989] khanna, a. and zinky, j. 1989. the revised arpanet routing metric. sigcomm comput. commun.
each top-level domain is managed by an organisation that decides how sub-domain names can be registered. most top-level domain names use a ﬁrst-come ﬁrst served system, and allow anyone to register domain names, but there are some exceptions. for example, .gov is reserved for the us government, .int is reserved for international organisations and names in the .ca are mainly reserved for companies or users who are present in canada.
rfc 1035 recommended the following bnf for fully qualiﬁed domain names, to allow host names with a syntax which works with all applications (the domain names themselves have a much richer syntax).
this grammar speciﬁes that a host name is an ordered list of labels separated by the dot (.) character. each label can contain letters, numbers and the hyphen character (-) 4. fully qualiﬁed domain names are read from left to right. the ﬁrst label is a hostname or a domain name followed by the hierarchy of domains and ending with the root implicitly at the right. the top-level domain name must be one of the registered tlds 5. for example, in the above ﬁgure, www.whitehouse.gov corresponds to a host named www inside the whitehouse domain that belongs to the gov top-level domain. info.ucl.ac.be corresponds to the info domain inside the ucl domain that is included in the ac sub-domain of the be top-level domain. this hierarchical naming scheme is a key component of the domain name system (dns). the dns is a distributed database that contains mappings between fully qualiﬁed domain names and ip addresses. the dns uses the client-server model. the clients are hosts that need to retrieve the mapping for a given name. each nameserver stores part of the distributed database and answers the queries sent by clients. there is at least one nameserver that is responsible for each domain. in the ﬁgure below, domains are represented by circles and there are three hosts inside domain dom (h1, h2 and h3) and three hosts inside domain a.sdom1.dom. as shown in the ﬁgure below, a sub-domain may contain both host names and sub-domains.
the content-type: header can also be used inside a mime part. in this case, it indicates the type of data placed in this part. each data type is speciﬁed as a type followed by a subtype. a detailed description may be found in rfc 2046. some of the most popular content-type: header lines are :
• text. the message part contains information in textual format. there are several subtypes : text/plain for regular ascii text, text/html deﬁned in rfc 2854 for documents in html format or the text/enriched format deﬁned in rfc 1896. the content-type: header line may contain a second parameter that speciﬁes the character set used to encode the text. charset=us-ascii is the standard ascii character table. other frequent character sets include charset=utf8 or charset=iso-8859-1. the list of standard character sets is maintained by iana
• application. the message part contains binary information that was produced by the particular application listed as the subtype. email clients use the subtype to launch the application that is able to decode the received binary information.
note: from ascii to unicode the ﬁrst computers used different techniques to represent characters in memory and on disk. during the 1960s, computers began to exchange information via tape or telephone lines. unfortunately, each vendor had its own proprietary character set and exchanging data between computers from different vendors was often difﬁcult. the 7 bits ascii character table rfc 20 set was adopted by several vendors and by many internet protocols. however, ascii became a problem with the internationalisation of the internet and the desire of more and more users to use character sets that support their own written language. a ﬁrst attempt at solving this problem was the deﬁnition of the iso-8859 character sets by iso. this family of standards speciﬁed various character sets that allowed the representation of many european written languages by using 8 bits characters. unfortunately, an 8-bits character set is not sufﬁcient to support some widely used languages, such as those used in asian countries. fortunately, at the end of the 1980s, several computer scientists proposed to develop a standard that supports all written languages used on earth today. the unicode standard [unicode] has now been adopted by most computer and software vendors. for example, java uses unicode natively to manipulate characters, python can handle both ascii and unicode characters. internet applications are slowly moving towards complete support for the unicode character sets, but moving from ascii to unicode is an important change that can have a huge impact on current deployed implementations. see for example, the work to completely internationalise email rfc 4952 and domain names rfc 5890.
the last mime header line is content-transfer-encoding:. this header line is used after the content-type: header line, within a message part, and speciﬁes how the message part has been encoded. the default encoding is to use 7 bits ascii. the most frequent encodings are quoted-printable and base64. both support encoding a sequence of bytes into a set of ascii lines that can be safely transmitted by email servers. quoted-printable is deﬁned in rfc 2045. we brieﬂy describe base64 which is deﬁned in rfc 2045 and rfc 4648. base64 divides the sequence of bytes to be encoded into groups of three bytes (with the last group possibly being partially ﬁlled). each group of three bytes is then divided into four six-bit ﬁelds and each six bit ﬁeld is encoded as a character from the table below.
share information on the web. they were also extended by other developers who contributed to new features. for example, ncsa added support for images in their mosaic browser that was eventually used to create netscape communications.
the ﬁrst components of the world wide web are the uniform resource identiﬁers (uri), deﬁned in rfc 3986. a uri is a character string that unambiguously identiﬁes a resource on the world wide web. here is a subset of the bnf for uris
= scheme ":" "//" authority path [ "?" query ] [ "#" fragment ] = alpha *( alpha / digit / "+" / "-" / "." ) = [ userinfo "@" ] host [ ":" port ] = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" )
= unreserved / pct-encoded / sub-delims / ":" / "@" = *( pchar / "/" / "?" ) = *( pchar / "/" / "?" ) = "%" hexdig hexdig = alpha / digit / "-" / "." / "_" / "~" = gen-delims / sub-delims = ":" / "/" / "?" / "#" / "[" / "]" / "@" = "!" / "$" / "&" / "’" / "(" / ")" / "*" / "+" / "," / ";" / "="
the ﬁrst component of a uri is its scheme. a scheme can be seen as a selector, indicating the meaning of the ﬁelds after it. in practice, the scheme often identiﬁes the application-layer protocol that must be used by the client to retrieve the document, but it is not always the case. some schemes do not imply a protocol at all and some do not indicate a retrievable document 17. the most frequent scheme is http that will be described later. a uri scheme can be deﬁned for almost any application layer protocol [#furilist]_. the characters ‘: and // follow the scheme of any uri. the second part of the uri is the authority. with retrievable uri, this includes the dns name or the ip address of the server where the document can be retrieved using the protocol speciﬁed via the scheme. this name can be preceded by some information about the user (e.g. a user name) who is requesting the information. earlier deﬁnitions of the uri allowed the speciﬁcation of a user name and a password before the @ character ( rfc 1738), but this is now deprecated as placing a password inside a uri is insecure. the host name can be followed by the semicolon character and a port number. a default port number is deﬁned for some protocols and the port number should only be included in the uri if a non-default port number is used (for other protocols, techniques like service dns records are used). the third part of the uri is the path to the document. this path is structured as ﬁlenames on a unix host (but it does not imply that the ﬁles are indeed stored this way on the server). if the path is not speciﬁed, the server will return a default document. the last two optional parts of the uri are used to provide a query and indicate a speciﬁc part (e.g. a section in an article) of the requested document. sample uris are shown below.
http://tools.ietf.org/html/rfc3986.html mailto:infobot@example.com?subject=current-issue http://docs.python.org/library/basehttpserver.html?highlight=http#basehttpserver.basehttprequesthandler telnet://[2001:6a8:3080:3::2]:80/ ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
the ﬁrst uri corresponds to a document named rfc3986.html that is stored on the server named tools.ietf.org and can be accessed by using the http protocol on its default port. the second uri corresponds to an email message, with subject current-issue, that will be sent to user infobot in domain example.com. the mailto: uri scheme is deﬁned in rfc 6068. the third uri references the portion basehttpserver.basehttprequesthandler of the document basehttpserver.html that is stored in the library directory on server docs.python.org. this document can be retrieved by using the http protocol. the query highlight=http is associated to this uri. the fourth example is a server that operates the telnet protocol, uses ipv6 address 2001:6a8:3080:3::2 and is reachable on port 80. the last uri is somewhat special. most users will assume that it corresponds to a document stored on the cnn.example.com
17 an example of a non-retrievable uri is urn:isbn:0-380-81593-1 which is an unique identiﬁer for a book, through the urn scheme (see rfc 3187). of course, any uri can be make retrievable via a dedicated server or a new protocol but this one has no explicit protocol. same thing for the scheme tag (see rfc 4151), often used in web syndication (see rfc 4287 about the atom syndication format). even when the scheme is retrievable (for instance with http‘), it is often used only as an identiﬁer, not as a way to get a resource. see http://norman.walsh.name/2006/07/25/namesandaddresses for a good explanation.
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
indicate its preferred languages. unfortunately, in practice this header is usually set based on the default language of the browser and it is not possible for a user to indicate the language it prefers to use by selecting options on each visited web server. the third, and widely adopted, solution are http cookies. http cookies were initially developed as a private extension by netscape. they are now part of the standard rfc 6265. in a nutshell, a cookie is a short string that is chosen by a server to represent a given client. two http headers are used : cookie: and set-cookie:. when a server receives an http request from a new client (i.e. an http request that does not contain the cookie: header), it generates a cookie for the client and includes it in the set-cookie: header of the returned http response. the set-cookie: header contains several additional parameters including the domain names for which the cookie is valid. the client stores all received cookies on disk and every time it sends a http request, it veriﬁes whether it already knows a cookie for this domain. if so, it attaches the cookie: header to the http request. this is illustrated in the ﬁgure below with http 1.1, but cookies also work with http 1.0.
note: privacy issues with http cookies the http cookies introduced by netscape are key for large e-commerce websites. however, they have also raised many discussions concerning their potential misuses. consider ad.com, a company that delivers lots of advertisements on web sites. a web site that wishes to include ad.com‘s advertisements next to its content will add links to ad.com inside its html pages. if ad.com is used by many web sites, ad.com could be able to track the interests of all the users that visit its client websites and use this information to provide targeted advertisements. privacy advocates have even sued online advertisement companies to force them to comply with the privacy regulations. more recent related technologies also raise privacy concerns
networked applications were usually implemented by using the socket api. this api was designed when tcp/ip was ﬁrst implemented in the unix bsd operating system [sechrest] [lfjlmt], and has served as the model for many apis between applications and the networking stack in an operating system. although the socket api is very popular, other apis have also been developed. for example, the streams api has been added to several unix system v variants [rago1993]. the socket api is supported by most programming languages and several textbooks have been devoted to it. users of the c language can consult [dc2009], [stevens1998], [sfr2004] or [kerrisk2010]. the java implementation of the socket api is described in [cd2008] and in the java tutorial. in this section, we will use the python implementation of the socket api to illustrate the key concepts. additional information about this api may be found in the socket section of the python documentation .
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
time during which the fragments of a packet are stored in its buffer while the packet is being reassembled. this can be implemented by starting a timer when the ﬁrst fragment of a packet is received. if the packet has not been reassembled upon expiration of the timer, all fragments are discarded and the packet is considered to be lost. the original ip speciﬁcation, in rfc 791, deﬁned several types of options that can be added to the ip header. each option is encoded using a type length value format. they are not widely used today and are thus only brieﬂy described. additional details may be found in rfc 791. the most interesting options in ipv4 are the three options that are related to routing. the record route option was deﬁned to allow network managers to determine the path followed by a packet. when the record route option was present, routers on the packet’s path had to insert their ip address in the option. this option was implemented, but as the optional part of the ipv4 header can only contain 44 bytes, it is impossible to discover an entire path on the global internet. traceroute(8), despite its limitations, is a better solution to record the path towards a destination. the other routing options are the strict source route and the loose source route option. the main idea behind these options is that a host may want, for any reason, to specify the path to be followed by the packets that it sends. the strict source route option allows a host to indicate inside each packet the exact path to be followed. the strict source route option contains a list of ipv4 address and a pointer to indicate the next address in the list. when a router receives a packet containing this option, it does not lookup the destination address in its routing table but forwards the packet directly to the next router in the list and advances the pointer. this is illustrated in the ﬁgure below where s forces its packets to follow the ra-rb-rd path.
the maximum length of the optional part of the ipv4 header is a severe limitation for the strict source route option as for the record route option. the loose source route option does not suffer from this limitation. this option allows the sending host to indicate inside its packet some of the routers that must be traversed to reach the destination. this is shown in the ﬁgure below. s sends a packet containing a list of addresses and a pointer to the next router in the list. initially, this pointer points to rb. when ra receives the packet sent by s, it looks up in its forwarding table the address pointed in the loose source route option and not the destination address. the packet is then forwarded to router rb that recognises its address in the option and advances the pointer. as there is no address listed in the loose source route option anymore, rb and other downstream routers forward the packet by performing a lookup for the destination address.
[rfc5072] varada, s. and haskins, d. and allen, e., ip version 6 over ppp, rfc 5072, sept. 2007 [rfc5095] abley, j. and savola, p. and neville-neil, g., deprecation of type 0 routing headers in ipv6, rfc
[rfc5227] cheshire, s., ipv4 address conﬂict detection, rfc 5227, july 2008 [rfc5234] crocker, d. and overell, p., augmented bnf for syntax speciﬁcations: abnf, rfc 5234, jan. 2008 [rfc5321] klensin, j., simple mail transfer protocol, rfc 5321, oct. 2008 [rfc5322] resnick, p., internet message format, rfc 5322, oct. 2008 [rfc5340] coltun, r. and ferguson, d. and moy, j. and lindem, a., ospf for ipv6, rfc 5340, july 2008 [rfc5598] crocker, d., internet mail architecture, rfc 5598, july 2009 [rfc5646] phillips, a. and davis, m., tags for identifying languages, rfc 5646, sept. 2009 [rfc5681] allman, m. and paxson, v. and blanton, e., tcp congestion control, rfc 5681, sept. 2009 [rfc5735] cotton, m. and vegoda, l., special use ipv4 addresses, rfc 5735, january 2010 [rfc5795] sandlund, k. and pelletier, g. and jonsson, l-e., the robust header compression (rohc) frame-
[rfc6068] duerst, m., masinter, l. and zawinski, j., the ‘mailto’ uri scheme , rfc 6068, october 2010 [rfc6144] baker, f. and li, x. and bao, x. and yin, k., framework for ipv4/ipv6 translation, rfc 6144, april
[rfc6265] barth, a., http state management mechanism, rfc 6265, april 2011 [rfc6274] gont, f., security assessment of the internet protocol version 4, rfc 6274, july 2011 [rg2010] rhodes, b. and goerzen, j., foundations of python network programming: the comprehensive guide
[rj1995] ramakrishnan, k. k. and jain, r., a binary feedback scheme for congestion avoidance in computer networks with a connectionless network layer. sigcomm comput. commun. rev. 25, 1 (jan. 1995), 138156.
[sao1990] sidhu, g., andrews, r., oppenheimer, a., inside appletalk, addison-wesley, 1990 [sark2002] subramanian, l., agarwal, s., rexford, j., katz, r.. characterizing the internet hierarchy from
the user datagram protocol (udp) is deﬁned in rfc 768. it provides an unreliable connectionless transport service on top of the unreliable network layer connectionless service. the main characteristics of the udp service are :
• the udp service cannot deliver sdus that are larger than 65507 bytes 7 • the udp service does not guarantee the delivery of sdus (losses and desquencing can occur) • the udp service will not deliver a corrupted sdu to the destination
compared to the connectionless network layer service, the main advantage of the udp service is that it allows several applications running on a host to exchange sdus with several other applications running on remote hosts. let us consider two hosts, e.g. a client and a server. the network layer service allows the client to send information to the server, but if an application running on the client wants to contact a particular application running on the server, then an additional addressing mechanism is required other than the ip address that identiﬁes a host, in order to differentiate the application running on a host. this additional addressing is provided by port numbers. when a server using udp is enabled on a host, this server registers a port number. this port number will be used by the clients to contact the server process via udp. the ﬁgure below shows a typical usage of the udp port numbers. the client process uses port number 1234 while the server process uses port number 5678. when the client sends a request, it is identiﬁed as originating from port number 1234 on the client host and destined to port number 5678 on the server host. when the server process replies to this request, the server’s udp implementation will send the reply as originating from port 5678 on the server host and destined to port 1234 on the client host. udp uses a single segment format shown in the ﬁgure below. the udp header contains four ﬁelds :
as the port numbers are encoded as a 16 bits ﬁeld, there can be up to only 65535 different server processes that are bound to a different udp port at the same time on a given server. in practice, this limit is never reached. however, it is worth noticing that most implementations divide the range of allowed udp port numbers into three different ranges :
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
once a router has discovered its neighbours, it must reliably distribute its local links to all routers in the network to allow them to compute their local view of the network topology. for this, each router builds a link-state packet (lsp) containing the following information :
• lsp.router : identiﬁcation (address) of the sender of the lsp • lsp.age : age or remaining lifetime of the lsp • lsp.seq : sequence number of the lsp • lsp.links[] : links advertised in the lsp. each directed link is represented with the following information
these lsps must be reliably distributed inside the network without using the router’s routing table since these tables can only be computed once the lsps have been received. the flooding algorithm is used to efﬁciently distribute the lsps of all routers. each router that implements ﬂooding maintains a link state database (lsdb) containing the most recent lsp sent by each router. when a router receives an lsp, it ﬁrst veriﬁes whether this lsp is already stored inside its lsdb. if so, the router has already distributed the lsp earlier and it does not need to forward it. otherwise, the router forwards the lsp on all links except the link over which the lsp was received. reliable ﬂooding can be implemented by using the following pseudo-code.
in this pseudo-code, lsdb(r) returns the most recent lsp originating from router r that is stored in the lsdb. newer(lsp1,lsp2) returns true if lsp1 is more recent than lsp2. see the note below for a discussion on how newer can be implemented.
note: which is the most recent lsp ? a router that implements ﬂooding must be able to detect whether a received lsp is newer than the stored lsp. this requires a comparison between the sequence number of the received lsp and the sequence number of the lsp stored in the link state database. the arpanet routing protocol [mrr1979] used a 6 bits sequence number and implemented the comparison as follows rfc 789
this comparison takes into account the modulo 26 arithmetic used to increment the sequence numbers. intuitively, the comparison divides the circle of all sequence numbers into two halves. usually, the sequence number of the received lsp is equal to the sequence number of the stored lsp incremented by one, but sometimes the sequence numbers of two successive lsps may differ, e.g. if one router has been disconnected from the network for some time. the comparison above worked well until october 27, 1980. on this day, the arpanet crashed completely. the crash was complex and involved several routers. at one point, lsp 40 and lsp 44 from one of the routers were stored in the lsdb of some routers in the arpanet. as lsp 44 was the newest, it should have replaced by lsp 40 on all routers. unfortunately, one of the arpanet routers suffered from a memory problem and sequence number 40 (101000 in binary) was replaced by 8 (001000 in binary) in the buggy router and ﬂooded. three lsps were present in the network and 44 was newer than 40 which is newer than 8, but unfortunately 8 was considered to be newer than 44... all routers started to exchange these three link state packets for ever and the only solution to recover from this problem was to shutdown the entire network rfc 789. current link state routing protocols usually use 32 bits sequence numbers and include a special mechanism in the unlikely case that a sequence number reaches the maximum value (using a 32 bits sequence number space takes 136 years if a link state packet is generated every second).
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
in addition, the ascii table also deﬁnes several non-printable or control characters. these characters were designed to allow an application to control a printer or a terminal. these control characters include cr and lf, that are used to terminate a line, and the bell character which causes the terminal to emit a sound.
the ascii characters are encoded as a seven bits ﬁeld, but transmitted as an eight-bits byte whose high order bit is usually set to 0. bytes are always transmitted starting from the high order or most signiﬁcant bit. most applications exchange strings that are composed of ﬁxed or variable numbers of characters. a common solution to deﬁne the character strings that are acceptable is to deﬁne them as a grammar using a backus-naur form (bnf) such as the augmented bnf deﬁned in rfc 5234. a bnf is a set of production rules that generate all valid character strings. for example, consider a networked application that uses two commands, where the user can supply a username and a password. the bnf for this application could be deﬁned as shown in the ﬁgure below.
the example above deﬁnes several terminals and two commands : usercommand and passwordcommand. the alpha terminal contains all letters in upper and lower case. in the alpha rule, %x41 corresponds to ascii character code 41 in hexadecimal, i.e. capital a. the cr and lf terminals correspond to the carriage return and linefeed control characters. the crlf rule concatenates these two terminals to match the standard end of line termination. the digit terminal contains all digits. the sp terminal corresponds to the white space characters. the usercommand is composed of two strings separated by white space. in the abnf rules that deﬁne the messages used by internet applications, the commands are case-insensitive. the rule “user” corresponds to all possible cases of the letters that compose the word between brackets, e.g. user, user, user, user, ... a username contains at least one letter and up to 8 letters. user names are case-sensitive as they are not deﬁned as a string between brackets. the password rule indicates that a password starts with a letter and can contain any number of letters or digits. the white space and the control characters cannot appear in a password deﬁned by the above rule. besides character strings, some applications also need to exchange 16 bits and 32 bits ﬁelds such as integers. a naive solution would have been to send the 16- or 32-bits ﬁeld as it is encoded in the host’s memory. unfortunately, there are different methods to store 16- or 32-bits ﬁelds in memory. some cpus store the most signiﬁcant byte of a 16-bits ﬁeld in the ﬁrst address of the ﬁeld while others store the least signiﬁcant byte at this location. when networked applications running on different cpus exchange 16 bits ﬁelds, there are two possibilities to transfer them over the transport service :
• send the most signiﬁcant byte followed by the least signiﬁcant byte • send the least signiﬁcant byte followed by the most signiﬁcant byte
the ﬁrst possibility was named big-endian in a note written by cohen [cohen1980] while the second was named little-endian. vendors of cpus that used big-endian in memory insisted on using big-endian encoding in networked applications while vendors of cpus that used little-endian recommended the opposite. several studies were written on the relative merits of each type of encoding, but the discussion became almost a religious issue [cohen1980]. eventually, the internet chose the big-endian encoding, i.e. multi-byte ﬁelds are always transmitted by sending the most signiﬁcant byte ﬁrst, rfc 791 refers to this encoding as the network-byte order. most
microseconds and after each connection establishment 11. when a client host wants to open a tcp connection with a server host, it creates a tcp segment with :
• the syn ﬂag set • the sequence number set to the current value of the 32 bits counter of the server host’s tcp entity • the ack ﬂag set • the acknowledgment number set to the sequence number of the received syn segment incremented by 1 ( mod 232). when a tcp entity sends a segment having x+1 as acknowledgment number, this indicates that it has received all data up to and including sequence number x and that it is expecting data having sequence number x+1. as the syn ﬂag was set in a segment having sequence number x, this implies that setting the syn ﬂag in a segment consumes one sequence number.
this segment is often called a syn+ack segment. the acknowledgment conﬁrms to the client that the server has correctly received the syn segment. the sequence number of the syn+ack segment is used by the server host to verify that the client has received the segment. upon reception of the syn+ack segment, the client host replies with a segment containing :
at this point, the tcp connection is open and both the client and the server are allowed to send tcp segments containing data. this is illustrated in the ﬁgure below. in the ﬁgure above, the connection is considered to be established by the client once it has received the syn+ack segment, while the server considers the connection to be established upon reception of the ack segment. the ﬁrst data segment sent by the client (server) has its sequence number set to x+1 (resp. y+1).
note: computing tcp’s initial sequence number in the original tcp speciﬁcation rfc 793, each tcp entity maintained a clock to compute the initial sequence number (isn) placed in the syn and syn+ack segments. this made the isn predictable and caused a security issue. the typical security problem was the following. consider a server that trusts a host based on its ip address
depicted below which is similar to the one discussed in [jacobson1988] and rfc 896. in this network, we assume that the buffers of the router are inﬁnite to ensure that no packet is lost.
if many tcp senders are attached to the left part of the network above, they all send a window full of segments. these segments are stored in the buffers of the router before being transmitted towards their destination. if there are many senders on the left part of the network, the occupancy of the buffers quickly grows. a consequence of the buffer occupancy is that the round-trip-time, measured by tcp, between the sender and the receiver increases. consider a network where 10,000 bits segments are sent. when the buffer is empty, such a segment requires 1 millisecond to be transmitted on the 10 mbps link and 5 milliseconds to be the transmitted on the 2 mbps link. thus, the round-trip-time measured by tcp is roughly 6 milliseconds if we ignore the propagation delay on the links. most routers manage their buffers as a fifo queue 25. if the buffer contains 100 segments, the round-triptime becomes 1 + 100 × 5 + 5 milliseconds as new segments are only transmitted on the 2 mbps link once all previous segments have been transmitted. unfortunately, tcp uses a retransmission timer and performs go-back-n to recover from transmission errors. if the buffer occupancy is high, tcp assumes that some segments have been lost and retransmits a full window of segments. this increases the occupancy of the buffer and the delay through the buffer... furthermore, the buffer may store and send on the low bandwidth links several retransmissions of the same segment. this problem is called congestion collapse. it occurred several times in the late 1980s. for example, [jacobson1988] notes that in 1986, the usable bandwidth of a 32 kbits link dropped to 40 bits per second due to congestion collapse 26 ! the congestion collapse is a problem that all heterogeneous networks face. different mechanisms have been proposed in the scientiﬁc literature to avoid or control network congestion. some of them have been implemented and deployed in real networks. to understand this problem in more detail, let us ﬁrst consider a simple network with two hosts attached to a high bandwidth link that are sending segments to destination c attached to a low bandwidth link as depicted below.
to avoid congestion collapse, the hosts must regulate their transmission rate 27 by using a congestion control mechanism. such a mechanism can be implemented in the transport layer or in the network layer. in tcp/ip networks, it is implemented in the transport layer, but other technologies such as asynchronous transfer mode (atm) or frame relay include congestion control mechanisms in lower layers. let us ﬁrst consider the simple problem of a set of i hosts that share a single bottleneck link as shown in the example above. in this network, the congestion control scheme must achieve the following objectives [cj1989] :
25 we discuss in another chapter other possible organisations of the router’s buffers. 26 at this time, tcp implementations were mainly following rfc 791. the round-trip-time estimations and the retransmission mechanisms
27 in this section, we focus on congestion control mechanisms that regulate the transmission rate of the hosts. other types of mechanisms have been proposed in the literature. for example, credit-based ﬂow-control has been proposed to avoid congestion in atm networks [kr1995]. with a credit-based mechanism, hosts can only send packets once they have received credits from the routers and the credits depend on the occupancy of the router’s buffers.
designed when most point-to-point links were telephone lines with modems. since then, ip has been able to use local area networks (ethernet, token ring, fddi, ...), new wide area data link layer technologies (x.25, atm, frame relay, ...) and more recently wireless networks (802.11, 802.15, umts, gprs, ...). the ﬂexibility of ip and its ability to use various types of underlying data link layer technologies is one of its key advantages.
the current version of ip is version 4 speciﬁed in rfc 791. we ﬁrst describe this version and later explain ip version 6, which is expected to replace ip version 4 in the not so distant future.
ip version 4 is the data plane protocol of the network layer in the tcp/ip protocol suite. the design of ip version 4 was based on the following assumptions :
• ip operates with the datagram transmission mode • ip addresses have a ﬁxed size of 32 bits • ip must be usable above different types of datalink layers • ip hosts exchange variable length packets
the addresses are an important part of any network layer protocol. in the late 1970s, the developers of ipv4 designed ipv4 for a research network that would interconnect some research labs and universities. for this utilisation, 32 bits wide addresses were much larger than the expected number of hosts on the network. furthermore, 32 bits was a nice address size for software-based routers. none of the developers of ipv4 were expecting that ipv4 would become as widely used as it is today. ipv4 addresses are encoded as a 32 bits ﬁeld. ipv4 addresses are often represented in dotted-decimal format as a sequence of four integers separated by a dot. the ﬁrst integer is the decimal representation of the most signiﬁcant byte of the 32 bits ipv4 address, ... for example,
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
subnet 130.100.0.0/16 130.101.0.0/16 university of akron, usa 130.102.0.0/16 130.103.0.0/16 130.104.0.0/16 universite catholique de louvain, belgium 130.105.0.0/16 open software foundation, usa
however, the internet was a victim of its own success and in the late 1980s, many organisations were requesting blocks of ipv4 addresses and started connecting to the internet. most of these organisations requested class b address blocks, as class a address blocks were too large and in limited supply while class c address blocks were considered to be too small. unfortunately, there were only 16,384 different class b address blocks and this address space was being consumed quickly. as a consequence, the routing tables maintained by the routers were growing quickly and some routers had difﬁculties maintaining all these routes in their limited memory 5.
faced with these two problems, the internet engineering task force decided to develop the classless interdomain routing (cidr) architecture rfc 1518. this architecture aims at allowing ip routing to scale better than the class-based architecture. cidr contains three important modiﬁcations compared to rfc 791.
1. ip address classes are deprecated. all ip equipment must use and support variable-length subnets. 2. ip address blocks are no longer allocated on a ﬁrst-come-ﬁrst-served basis. instead, cidr introduces a
the last two modiﬁcations were introduced to improve the scalability of the ip routing system. the main drawback of the ﬁrst-come-ﬁrst-served address block allocation scheme was that neighbouring address blocks were allocated to very different organisations and conversely, very different address blocks were allocated to similar organisations. with cidr, address blocks are allocated by regional ip registries (rir) in an aggregatable manner. a rir is responsible for a large block of addresses and a region. for example, ripe is the rir that is responsible for europe. a rir allocates smaller address blocks from its large block to internet service providers rfc 2050. internet service providers then allocate smaller address blocks to their customers. when an organisation requests an address block, it must prove that it already has or expects to have in the near future, a number of hosts or customers that is equivalent to the size of the requested address block. the main advantage of this hierarchical address block allocation scheme is that it allows the routers to maintain fewer routes. for example, consider the address blocks that were allocated to some of the belgian universities as shown in the table below.
• 127.0.0.0/8, which is reserved for loopback addresses. each host implementing ipv4 must have a loopback interface (that is not attached to a datalink layer). by convention, ipv4 address 127.0.0.1 is assigned to this interface. this allows processes running on a host to use tcp/ip to contact other processes running on the same host. this can be very useful for testing purposes.
now that we have clariﬁed the allocation of ipv4 addresses and the utilisation of the longest preﬁx match to forward ipv4 packets, we can have a more detailed look at ipv4 by starting with the format of the ipv4 packets. the ipv4 packet format was deﬁned in rfc 791. apart from a few clariﬁcations and some backward compatible changes, the ipv4 packet format did not change signiﬁcantly since the publication of rfc 791. all ipv4 packets use the 20 bytes header shown below. some ipv4 packets contain an optional header extension that is described later.
• a 4 bits ip header length (ihl) that indicates the length of the ip header in 32 bits words. this ﬁeld allows ipv4 to use options if required, but as it is encoded as a 4 bits ﬁeld, the ipv4 header cannot be longer than 64 bytes.
• an 8 bits ds ﬁeld that is used for quality of service and whose usage is described later. • an 8 bits protocol ﬁeld that indicates the transport layer protocol that must process the packet’s payload at
• a 32 bits source address ﬁeld that contains the ipv4 address of the source host • a 32 bits destination address ﬁeld that contains the ipv4 address of the destination host • a 16 bits checksum that protects only the ipv4 header against transmission errors
the other ﬁelds of the ipv4 header are used for speciﬁc purposes. the ﬁrst is the 8 bits time to live (ttl) ﬁeld. this ﬁeld is used by ipv4 to avoid the risk of having an ipv4 packet caught in an inﬁnite loop due to a transient
or permanent error in routing tables 7. consider for example the situation depicted in the ﬁgure below where destination d uses address 11.0.0.56. if s sends a packet towards this destination, the packet is forwarded to router b which forwards it to router c that forwards it back to router a, etc.
unfortunately, such loops can occur for two reasons in ip networks. first, if the network uses static routing, the loop can be caused by a simple conﬁguration error. second, if the network uses dynamic routing, such a loop can occur transiently, for example during the convergence of the routing protocol after a link or router failure. the ttl ﬁeld of the ipv4 header ensures that even if there are forwarding loops in the network, packets will not loop forever. hosts send their ipv4 packets with a positive ttl (usually 64 or more 8). when a router receives an ipv4 packet, it ﬁrst decrements the ttl by one. if the ttl becomes 0, the packet is discarded and a message is sent back to the packet’s source (see section icmp). otherwise, the router performs a lookup in its forwarding table to forward the packet. a second problem for ipv4 is the heterogeneity of the datalink layer. ipv4 is used above many very different datalink layers. each datalink layer has its own characteristics and as indicated earlier, each datalink layer is characterised by a maximum frame size. from ip’s point of view, a datalink layer interface is characterised by its maximum transmission unit (mtu). the mtu of an interface is the largest ipv4 packet (including header) that it can send. the table below provides some common mtu sizes 9.
although ipv4 can send 64 kbytes long packets, few datalink layer technologies that are used today are able to send a 64 kbytes ipv4 packet inside a frame. furthermore, as illustrated in the ﬁgure below, another problem is that a host may send a packet that would be too large for one of the datalink layers used by the intermediate routers.
7 the initial ip speciﬁcation in rfc 791 suggested that routers would decrement the ttl at least once every second. this would ensure that a packet would never remain for more than ttl seconds in the network. however, in practice most router implementations simply chose to decrement the ttl by one.
to ease the attachment of hosts to subnets, most networks now support the dynamic host conﬁguration protocol (dhcp) rfc 2131. dhcp allows a host to automatically retrieve its assigned ipv4 address. a dhcp server is associated to each subnet 15. each dhcp server manages a pool of ipv4 addresses assigned to the subnet. when a host is ﬁrst attached to the subnet, it sends a dhcp request message in a udp segment (the dhcp server listens on port 67). as the host knows neither its ipv4 address nor the ipv4 address of the dhcp server, this udp segment is sent inside an ipv4 packet whose source and destination addresses are respectively 0.0.0.0 and 255.255.255.255. the dhcp request may contain various options such as the name of the host, its datalink layer address, etc. the server captures the dhcp request and selects an unassigned address in its address pool. it then sends the assigned ipv4 address in a dhcp reply message which contains the datalink layer address of the host and additional information such as the subnet mask of the ipv4 address, the address of the default router or the address of the dns resolver. this dhcp reply message is sent in an ipv4 packet whose source and destination addresses are respectively the ipv4 address of the dhcp server and the 255.255.255.255 broadcast address. the dhcp reply also speciﬁes the lifetime of the address allocation. this forces the host to renew its address allocation once it expires. thanks to the limited lease time, ip addresses are automatically returned to the pool of addresses hosts are powered off. this reduces the waste of ipv4 addresses. in an nbma network, the interactions between ipv4 and the datalink layer are more complex as the arp protocol cannot be used as in a lan. such nbma networks use special servers that store the mappings between ip addresses and the corresponding datalink layer address. asynchronous transfer mode (atm) networks for example can use either the atmarp protocol deﬁned in rfc 2225 or the nexthop resolution protocol (nhrp) deﬁned in rfc 2332. atm networks are less frequently used today and we will not describe the detailed operation of these servers.
at this point of the description of ipv4, it is useful to have a detailed look at how an ipv4 implementation sends, receives and forwards ipv4 packets. the simplest case is when a host needs to send a segment in an ipv4 packet. the host performs two operations. first, it must decide on which interface the packet will be sent. second it must create the corresponding ip packet(s). to simplify the discussion in this section, we ignore the utilisation of ipv4 options. this is not a severe limitation as today ipv4 packets rarely contain options. details about the processing of the ipv4 options may be found in the relevant rfcs, such as rfc 791. furthermore, we also assume that only point-to-point links are used. we defer the explanation of the operation of ipv4 over local area networks until the next chapter. an ipv4 host having n datalink layer interfaces manages n + 1 ipv4 addresses :
• the 127.0.0.1/32 ipv4 address assigned by convention to its loopback address • one a.b.c.d/p ipv4 address assigned to each of its n datalink layer interfaces
such a host maintains a routing table containing one entry for its loopback address and one entry for each subnet identiﬁer assigned to its interfaces. furthermore, the host usually uses one of its interfaces as the default interface when sending packets that are not addressed to a directly connected destination. this is represented by the default route : 0.0.0.0/0 that is associated to one interface. when a transport protocol running on the host requests the transmission of a segment, it usually provides the ipv4 destination address to the ipv4 layer in addition to the segment 16. the ipv4 implementation ﬁrst performs a longest preﬁx match with the destination address in its routing table. the lookup returns the identiﬁcation of the interface that must be used to send the packet. the host can then create the ipv4 packet containing the segment. the source ipv4 address of the packet is the ipv4 address of the host on the interface returned by the longest preﬁx match. the protocol ﬁeld of the packet is set to the identiﬁcation of the local transport protocol which created the segment. the ttl ﬁeld of the packet is set to the default ttl used by the host. the host must now choose the packet’s identiﬁcation. this identiﬁcation is important if the packet becomes fragmented in the network, as it ensures that the destination is able to reassemble the received fragments. ideally, a sending host should never send a packet twice with the same identiﬁcation to the same destination host, in order to ensure that all fragments are correctly reassembled by the destination. unfortunately, with a 16 bits identiﬁcation ﬁeld and an expected msl of
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
it is sometimes necessary for intermediate routers or the destination host to inform the sender of the packet of a problem that occurred while processing a packet. in the tcp/ip protocol suite, this reporting is done by the internet control message protocol (icmp). icmp is deﬁned in rfc 792. icmp messages are carried as the payload of ip packets (the protocol value reserved for icmp is 1). an icmp message is composed of an 8 byte header and a variable length payload that usually contains the ﬁrst bytes of the packet that triggered the transmission of the icmp message.
in the icmp header, the type and code ﬁelds indicate the type of problem that was detected by the sender of the icmp message. the checksum protects the entire icmp message against transmission errors and the data ﬁeld contains additional information for some icmp messages. the main types of icmp messages are :
• destination unreachable : a destination unreachable icmp message is sent when a packet cannot be delivered to its destination due to routing problems. different types of unreachability are distinguished :
– host unreachable : this icmp message is sent by a router that is attached to the subnet that contains the destination address of the packet, but this destination address cannot be reached at this time
– protocol unreachable : this icmp message is sent by a destination host that has received a packet, but does not support the transport protocol indicated in the packet’s protocol ﬁeld – port unreachable : this icmp message is sent by a destination host that has received a
• redirect : this icmp message can be sent when there are two routers on the same lan. consider a lan with one host and two routers : r1 and r2. assume that r1 is also connected to subnet 130.104.0.0/16 while r2 is connected to subnet 138.48.0.0/16. if a host on the lan sends a packet towards 130.104.1.1 to r2, r2 needs to forward the packet again on the lan to reach r1. this is not optimal as the packet is sent twice on the same lan. in this case, r2 could send an icmp redirect message to the host to inform it that it should have sent the packet directly to r1. this allows the host to send the other packets to 130.104.1.1 directly via r1.
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
to deal with this problem, transport protocols combine two solutions. first, they use 32 bits or more to encode the sequence number in the segment header. this increases the overhead, but also increases the delay between the transmission of two different segments having the same sequence number. second, transport protocols require the network layer to enforce a maximum segment lifetime (msl). the network layer must ensure that no packet remains in the network for more than msl seconds. in the internet the msl is assumed 6 to be 2 minutes rfc 793. note that this limits the maximum bandwidth of a transport protocol. if it uses n bits to encode its sequence numbers, then it cannot send more than 2n segments every msl seconds. transport protocols often need to send data in both directions. to reduce the overhead caused by the acknowledgements, most transport protocols use piggybacking. thanks to this technique, a transport entity can place inside the header of the data segments that it sends, the acknowledgements and the receive window that it advertises for the opposite direction of the data ﬂow. the main advantage of piggybacking is that it reduces the overhead as it is not necessary to send a complete segment to carry an acknowledgement. this is illustrated in the ﬁgure below where the acknowledgement number is underlined in the data segments. piggybacking is only used when data ﬂows in both directions. a receiver will generate a pure acknowledgement when it does not send data in the opposite direction as shown in the bottom of the ﬁgure.
6 as we will see in the next chapter, the internet does not strictly enforce this msl. however, it is reasonable to expect that most packets on the internet will not remain in the network during more than 2 minutes. there are a few exceptions to this rule, such as rfc 1149 whose implementation is described in http://www.blug.linux.no/rfc1149/ but there are few real links supporting rfc 1149 in the internet.
a udp application that is often used in the wide area. however, in local area networks, many distributed systems rely on remote procedure call (rpc) that is often used on top of udp. in unix environments, the network file system (nfs) is built on top of rpc and runs frequently on top of udp. a second class of udp-based applications are the interactive computer games that need to frequently exchange small messages, such as the player’s location or their recent actions. many of these games use udp to minimise the delay and can recover from losses. a third class of applications are multimedia applications such as interactive voice over ip or interactive video over ip. these interactive applications expect a delay shorter than about 200 milliseconds between the sender and the receiver and can recover from losses directly inside the application.
the transmission control protocol (tcp) was initially deﬁned in rfc 793. several parts of the protocol have been improved since the publication of the original protocol speciﬁcation 9. however, the basics of the protocol remain and an implementation that only supports rfc 793 should inter-operate with today’s implementation. tcp provides a reliable bytestream, connection-oriented transport service on top of the unreliable connectionless network service provided by ip. tcp is used by a large number of applications, including :
• email (smtp, pop, imap) • world wide web ( http, ...) • most ﬁle transfer protocols ( ftp, peer-to-peer ﬁle sharing applications , ...) • remote computer access : telnet, ssh, x11, vnc, ... • non-interactive multimedia applications : ﬂash
on the global internet, most of the applications used in the wide area rely on tcp. many studies 10 have reported that tcp was responsible for more than 90% of the data exchanged in the global internet. to provide this service, tcp relies on a simple segment format that is shown in the ﬁgure below. each tcp segment contains a header described below and, optionally, a payload. the default length of the tcp header is twenty bytes, but some tcp headers contain options.
• source and destination ports. the source and destination ports play an important role in tcp, as they allow the identiﬁcation of the connection to which a tcp segment belongs. when a client opens a tcp connection, it typically selects an ephemeral tcp port number as its source port and contacts the server by using the server’s port number. all the segments that are sent by the client on this connection have the same source and destination ports. the server sends segments that contain as source (resp. destination port, the
these studies have been performed by collecting all transmitted over a given link during a period of a few hours or days and then analysing their headers recent studies include http://www.caida.org/research/trafﬁc-analysis/tcpudpratio/, https://research.sprintlabs.com/packstat/packetoverview.php or http://www.nanog.org/meetings/nanog43/presentations/labovitz_internetstats_n43.pdf
microseconds and after each connection establishment 11. when a client host wants to open a tcp connection with a server host, it creates a tcp segment with :
• the syn ﬂag set • the sequence number set to the current value of the 32 bits counter of the server host’s tcp entity • the ack ﬂag set • the acknowledgment number set to the sequence number of the received syn segment incremented by 1 ( mod 232). when a tcp entity sends a segment having x+1 as acknowledgment number, this indicates that it has received all data up to and including sequence number x and that it is expecting data having sequence number x+1. as the syn ﬂag was set in a segment having sequence number x, this implies that setting the syn ﬂag in a segment consumes one sequence number.
this segment is often called a syn+ack segment. the acknowledgment conﬁrms to the client that the server has correctly received the syn segment. the sequence number of the syn+ack segment is used by the server host to verify that the client has received the segment. upon reception of the syn+ack segment, the client host replies with a segment containing :
at this point, the tcp connection is open and both the client and the server are allowed to send tcp segments containing data. this is illustrated in the ﬁgure below. in the ﬁgure above, the connection is considered to be established by the client once it has received the syn+ack segment, while the server considers the connection to be established upon reception of the ack segment. the ﬁrst data segment sent by the client (server) has its sequence number set to x+1 (resp. y+1).
note: computing tcp’s initial sequence number in the original tcp speciﬁcation rfc 793, each tcp entity maintained a clock to compute the initial sequence number (isn) placed in the syn and syn+ack segments. this made the isn predictable and caused a security issue. the typical security problem was the following. consider a server that trusts a host based on its ip address
another utilisation of tcp options during connection establishment is to enable tcp extensions. for example, consider rfc 1323 (which is discussed in tcp reliable data transfer). rfc 1323 deﬁnes tcp extensions to support timestamps and larger windows. if the client supports rfc 1323, it adds a rfc 1323 option to its syn if the server understands this rfc 1323 option and wishes to use it, it replies with an rfc 1323 segment. option in the syn+ack segment and the extension deﬁned in rfc 1323 is used throughout the tcp connection. otherwise, if the server’s syn+ack does not contain the rfc 1323 option, the client is not allowed to use this extension and the corresponding tcp header options throughout the tcp connection. tcp’s option mechanism is ﬂexible and it allows the extension of tcp while maintaining compatibility with older implementations. the tcp options are encoded by using a type length value format where :
• the ﬁrst byte indicates the type of the option. • the second byte indicates the total length of the option (including the ﬁrst two bytes) in bytes • the last bytes are speciﬁc for each type of option
rfc 793 deﬁnes the maximum segment size (mss) tcp option that must be understood by all tcp implementations. this option (type 2) has a length of 4 bytes and contains a 16 bits word that indicates the mss supported by the sender of the syn segment. the mss option can only be used in tcp segments having the syn ﬂag set. rfc 793 also deﬁnes two special options that must be supported by all tcp implementations. the ﬁrst option is end of option. it is encoded as a single byte having value 0x00 and can be used to ensure that the tcp header extension ends on a 32 bits boundary. the no-operation option, encoded as a single byte having value 0x01, can be used when the tcp header extension contains several tcp options that should be aligned on 32 bit boundaries. all other options 14 are encoded by using the tlv format.
note: the robustness principle the handling of the tcp options by tcp implementations is one of the many applications of the robustness principle which is usually attributed to jon postel and is often quoted as “be liberal in what you accept, and conservative in what you send” rfc 1122 concerning the tcp options, the robustness principle implies that a tcp implementation should be able to accept tcp options that it does not understand, in particular in received syn segments, and that it should be able to parse any received segment without crashing, even if the segment contains an unknown tcp option. furthermore, a server should not send in the syn+ack segment or later, options that have not been proposed by the client in the syn segment.
• graceful connection release, where each tcp user can release its own direction of data transfer • abrupt connection release, where either one user closes both directions of data transfer or one tcp entity is forced to close the connection (e.g. because the remote host does not reply anymore or due to lack of resources)
the abrupt connection release mechanism is very simple and relies on a single segment having the rst bit set. a tcp segment containing the rst bit can be sent for the following reasons :
• a non-syn segment was received for a non-existing tcp connection rfc 793 • by extension, some implementations respond with an rst segment to a segment that is received on an existing connection but with an invalid header rfc 3360. this causes the corresponding connection to be closed and has caused security attacks rfc 4953
• by extension, some implementations send an rst segment when they need to close an existing tcp connection (e.g. because there are not enough resources to support this connection or because the remote host is considered to be unreachable). measurements have shown that this usage of tcp rst was widespread [aw05]
the corresponding tcb. after having sent the last ack segment, a tcp connection enters the time_wait and remains in this state for 2 ∗ m sl seconds. during this period, the tcb of the connection is maintained. this ensures that the tcp entity that sent the last ack maintains enough state to be able to retransmit this segment if this ack segment is lost and the remote host retransmits its last fin segment or another one. the delay of 2 ∗ m sl seconds ensures that any duplicate segments on the connection would be handled correctly without causing the transmission of an rst segment. without the time_wait state and the 2 ∗ m sl seconds delay, the connection release would not be graceful when the last ack segment is lost.
note: time_wait on busy tcp servers the 2 ∗ m sl seconds delay in the time_wait state is an important operational problem on servers having thousands of simultaneously opened tcp connections [fty99]. consider for example a busy web server that processes 10.000 tcp connections every second. if each of these connections remain in the time_wait state for 4 minutes, this implies that the server would have to maintain more than 2 million tcbs at any time. for this reason, some tcp implementations prefer to perform an abrupt connection release by sending a rst segment to close the connection [aw05] and immediately discard the corresponding tcb. however, if the rst segment is lost, the remote host continues to maintain a tcb for a connection no longer exists. this optimisation reduces the number of tcbs maintained by the host sending the rst segment but at the potential cost of increased processing on the remote host when the rst segment is lost.
the original tcp data transfer mechanisms were deﬁned in rfc 793. based on the experience of using tcp on the growing global internet, this part of the tcp speciﬁcation has been updated and improved several times, always while preserving the backward compatibility with older tcp implementations. in this section, we review the main data transfer mechanisms used by tcp. tcp is a window-based transport protocol that provides a bi-directional byte stream service. this has several implications on the ﬁelds of the tcp header and the mechanisms used by tcp. the three ﬁelds of the tcp header are :
• acknowledgement number. tcp uses cumulative positive acknowledgements. each tcp segment contains the sequence number of the next byte that the sender of the acknowledgement expects to receive from the remote host. in theory, the acknowledgement number is only valid if the ack ﬂag of the tcp header is set. in practice almost all 15 tcp segments have their ack ﬂag set.
note: the transmission control block for each established tcp connection, a tcp implementation must maintain a transmission control block (tcb). a tcb contains all the information required to send and receive segments on this connection rfc 793. this includes 16 :
• the local ip address • the remote ip address • the local tcp port number • the remote tcp port number • the current state of the tcp fsm • the maximum segment size (mss)
15 in practice, only the syn segment do not have their ack ﬂag set. 16 a complete tcp implementation contains additional information in its tcb, notably to support the urgent pointer. however, this part of
the ﬁrst rule ensures that a tcp connection used for bulk data transfer always sends full tcp segments. the second rule sends one partially ﬁlled tcp segment every round-trip-time. this algorithm, called the nagle algorithm, takes a few lines of code in all tcp implementations. these lines of code have a huge impact on the packets that are exchanged in tcp/ip networks. researchers have analysed the distribution of the packet sizes by capturing and analysing all the packets passing through a given link. these studies have shown several important results :
• in tcp/ipv4 networks, most of the bytes are exchanged in long packets, usually packets containing up to 1460 bytes of payload which is the default mss for hosts attached to an ethernet network, the most popular type of lan
the ﬁgure below provides a distribution of the packet sizes measured on a link. it shows a three-modal distribution of the packet size. 50% of the packets contain pure tcp acknowledgements and occupy 40 bytes. about 20% of the packets contain about 500 bytes 18 of user data and 12% of the packets contain 1460 bytes of user data. however, most of the user data is transported in large packets. this packet size distribution has implications on the design of routers as we discuss in the next chapter.
recent measurements indicate that these packet size distributions are still valid in today’s internet, although the packet distribution tends to become bimodal with small packets corresponding to tcp pure acks (40-64 bytes depending on the utilisation of tcp options) and large 1460-bytes packets carrying most of the user data.
from a performance point of view, one of the main limitations of the original tcp speciﬁcation is the 16 bits window ﬁeld in the tcp header. as this ﬁeld indicates the current size of the receive window in bytes, it limits the tcp receive window at 65535 bytes. this limitation was not a severe problem when tcp was designed since at that time high-speed wide area networks offered a maximum bandwidth of 56 kbps. however, in today’s network, this limitation is not acceptable anymore. the table below provides the rough 19 maximum throughput that can be achieved by a tcp connection with a 64 kbytes window in function of the connection’s round-trip-time
to solve this problem, a backward compatible extension that allows tcp to use larger receive windows was proposed in rfc 1323. today, most tcp implementations support this option. the basic idea is that instead of
18 when these measurements were taken, some hosts had a default mss of 552 bytes (e.g. bsd unix derivatives) or 536 bytes (the default mss speciﬁed in rfc 793). today, most tcp implementation derive the mss from the maximum packet size of the lan interface they use (ethernet in most cases).
however, when a data segment is lost, as illustrated in the bottom part of the ﬁgure, the measurement is ambiguous as the sender cannot determine whether the received acknowledgement was triggered by the ﬁrst transmission of segment 123 or its retransmission. using incorrect round-trip-time estimations could lead to incorrect values of the retransmission timeout. for this reason, phil karn and craig partridge proposed, in [kp91], to ignore the round-trip-time measurements performed during retransmissions. to avoid this ambiguity in the estimation of the round-trip-time when segments are retransmitted, recent tcp implementations rely on the timestamp option deﬁned in rfc 1323. this option allows a tcp sender to place two 32 bit timestamps in each tcp segment that it sends. the ﬁrst timestamp, ts value (tsval) is chosen by the sender of the segment. it could for example be the current value of its real-time clock 22. the second value, ts echo reply (tsecr), is the last tsval that was received from the remote host and stored in the tcb. the ﬁgure below shows how the utilization of this timestamp option allows for the disambiguation of the round-trip-time measurement when there are retransmissions.
once the round-trip-time measurements have been collected for a given tcp connection, the tcp entity must compute the retransmission timeout. as the round-trip-time measurements may change during the lifetime of a connection, the retransmission timeout may also change. at the beginning of a connection 23 , the tcp entity that sends a syn segment does not know the round-trip-time to reach the remote host and the initial retransmission timeout is usually set to 3 seconds rfc 2988. the original tcp speciﬁcation proposed in rfc 793 to include two additional variables in the tcb :
• srtt : the smoothed round-trip-time computed as srrt = (α × srtt) + ((1 − α) × rtt) where rtt is the round-trip-time measured according to the above procedure and α a smoothing factor (e.g. 0.8 or 0.9)
23 as a tcp client often establishes several parallel or successive connections with the same server, rfc 2140 has proposed to reuse for a new connection some information that was collected in the tcb of a previous connection, such as the measured rtt. however, this solution has not been widely implemented.
• rto : the retransmission timeout is computed as rto = min(60, max(1, β × srtt)) where β is used to take into account the delay variance (value : 1.3 to 2.0). the 60 and 1 constants are used to ensure that the rto is not larger than one minute nor smaller than 1 second.
however, in practice, this computation for the retransmission timeout did not work well. the main problem was that the computed rto did not correctly take into account the variations in the measured round-trip-time. van jacobson proposed in his seminal paper [jacobson1988] an improved algorithm to compute the rto and implemented it in the bsd unix distribution. this algorithm is now part of the tcp standard rfc 2988. jacobson’s algorithm uses two state variables, srtt the smoothed rtt and rttvar the estimation of the variance of the rtt and two parameters : α and β. when a tcp connection starts, the ﬁrst rto is set to 3 seconds. when a ﬁrst estimation of the rtt is available, the srtt, rttvar and rto are computed as
the proposed values for the parameters are α = 1 4. this allows a tcp implementation, implemented in the kernel, to perform the rtt computation by using shift operations instead of the more costly ﬂoating point operations [jacobson1988]. the ﬁgure below illustrates the computation of the rto upon rtt changes.
the default go-back-n retransmission strategy was deﬁned in rfc 793. when the retransmission timer expires, tcp retransmits the ﬁrst unacknowledged segment (i.e. the one having sequence number snd.una). after each expiration of the retransmission timeout, rfc 2988 recommends to double the value of the retransmission timeout. this is called an exponential backoff. this doubling of the retransmission timeout after a retransmission was included in tcp to deal with issues such as network/receiver overload and incorrect initial estimations of the retransmission timeout. if the same segment is retransmitted several times, the retransmission timeout is doubled after every retransmission until it reaches a conﬁgured maximum. rfc 2988 suggests a maximum retransmission timeout of at least 60 seconds. once the retransmission timeout reaches this conﬁgured maximum, the remote host is considered to be unreachable and the tcp connection is closed. this retransmission strategy has been reﬁned based on the experience of using tcp on the internet. the ﬁrst reﬁnement was a clariﬁcation of the strategy used to send acknowledgements. as tcp uses piggybacking, the
7. a tcp implementation maintains a transmission control block (tcb) for each tcp connection. this tcb is a data structure that contains the complete “state” of each tcp connection. the tcb is described in rfc 793. it contains ﬁrst the identiﬁcation of the tcp connection :
• localip : the ip address of the local host • remoteip : the ip address of the remote host • remoteport : the tcp port used for this connection on the remote host • localport : the tcp port used for this connection on the local host. note that when a client opens a tcp connection, the local port will often be chosen in the ephemeral port range ( 49152 <= localport <= 65535 ).
the sequence number of the next byte that your implementation expects to receive from the remote host. for this exercise, you do not need to maintain a receive buffer and your implementation can discard the out-of-sequence segments that it receives
using the exercises/traces/trace.sirius.info.ucl.ac.be.pcap packet trace, what is the tcb of the connection on host 130.104.78.8 when it sends the third segment of the trace ?
8. the tcpdump packet trace exercises/traces/trace.maps.google.com was collected by containing a popular web site that provides mapping information. how many tcp connections were used to retrieve the information from this server ?
9. some network monitoring tools such as ntop collect all the tcp segments sent and received by a host or a group of hosts and provide interesting statistics such as the number of tcp connections, the number of bytes exchanged over each tcp connection, ... assuming that you can capture all the tcp segments sent by a host, propose the pseudo-code of an application that would list all the tcp connections established and accepted by this host and the number of bytes exchanged over each connection. do you need to count the number of bytes contained inside each segment to report the number of bytes exchanged over each tcp connection ?
10. there are two types of ﬁrewalls 30 : special devices that are placed at the border of campus or enterprise networks and software that runs on endhosts. software ﬁrewalls typically analyse all the packets that are received by a host and decide based on the packet’s header and contents whether it can be processed by the host’s network stack or must be discarded. system administrators often conﬁgure ﬁrewalls on laptop or student machines to prevent students from installing servers on their machines. how would you design a simple ﬁrewall that blocks all incoming tcp connections but still allows the host to establish tcp connections to any remote server ?
11. using the netkit lab explained above, perform some tests by using hping3(8). hping3(8) is a command line tool that allows anyone (having system administrator privileges) to send special ip packets and tcp segments. hping3(8) can be used to verify the conﬁguration of ﬁrewalls 33 or diagnose problems. we will use it to test the operation of the linux tcp stack running inside netkit.
1. on the server host, launch tcpdump(1) with -vv as parameter to collect all packets received from the client and display them. using hping3(8) on the client host, send a valid syn segment to one unused port on the server host (e.g. 12345). what are the contents of the segment returned by the server ?
30 a ﬁrewall is a software or hardware device that analyses tcp/ip packets and decides, based on a set of rules, to accept or discard the packets received or sent. the rules used by a ﬁrewall usually depend on the value of some ﬁelds of the packets (e.g. type of transport protocols, ports, ...). we will discuss in more details the operation of ﬁrewalls in the network layer chapter.
in a large ip network such as the global internet, routers need to exchange routing information. the internet is an interconnection of networks, often called domains, that are under different responsibilities. as of this writing, the internet is composed on more than 30,000 different domains and this number is still growing. a domain can be a small enterprise that manages a few routers in a single building, a larger enterprise with a hundred routers at multiple locations, or a large internet service provider managing thousands of routers. two classes of routing protocols are used to allow these domains to efﬁciently exchange routing information.
the ﬁrst class of routing protocols are the intradomain routing protocols (sometimes also called the interior gateway protocols or igp). an intradomain routing protocol is used by all routers inside a domain to exchange routing information about the destinations that are reachable inside the domain. there are several intradomain routing protocols. some domains use rip, which is a distance vector protocol. other domains use link-state routing protocols such as ospf or is-is. finally, some domains use static routing or proprietary protocols such as igrp or eigrp. these intradomain routing protocols usually have two objectives. first, they distribute routing information that corresponds to the shortest path between two routers in the domain. second, they should allow the routers to quickly recover from link and router failures. the second class of routing protocols are the interdomain routing protocols (sometimes also called the exterior gateway protocols or egp). the objective of an interdomain routing protocol is to distribute routing information between domains. for scalability reasons, an interdomain routing protocol must distribute aggregated routing information and considers each domain as a black box. a very important difference between intradomain and interdomain routing are the routing policies that are used by each domain. inside a single domain, all routers are considered equal, and when several routes are available to reach a given destination preﬁx, the best route is selected based on technical criteria such as the route with the shortest delay, the route with the minimum number of hops or the route with the highest bandwidth. when we consider the interconnection of domains that are managed by different organisations, this is no longer true. each domain implements its own routing policy. a routing policy is composed of three elements : an import ﬁlter that speciﬁes which routes can be accepted by a domain, an export ﬁlter that speciﬁes which routes can be advertised by a domain and a ranking algorithm that selects the best route when a domain knows several routes towards the same destination preﬁx. as we will see later, another important difference is that the objective of the interdomain routing protocol is to ﬁnd the cheapest route towards each destination. there is only one interdomain routing protocol : bgp.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
when an rst segment is sent by a tcp entity, it should contain the current value of the sequence number for the connection (or 0 if it does not belong to any existing connection) and the acknowledgement number should be set to the next expected in-sequence sequence number on this connection.
note: tcp rst wars tcp implementers should ensure that two tcp entities never enter a tcp rst war where host a is sending a rst segment in response to a previous rst segment that was sent by host b in response to a tcp rst segment sent by host a ... to avoid such an inﬁnite exchange of rst segments that do not carry data, a tcp entity is never allowed to send a rst segment in response to another rst segment.
the normal way of terminating a tcp connection is by using the graceful tcp connection release. this mechanism uses the fin ﬂag of the tcp header and allows each host to release its own direction of data transfer. as for the syn ﬂag, the utilisation of the fin ﬂag in the tcp header consumes one sequence number. the ﬁgure fsm for tcp connection release shows the part of the tcp fsm used when a tcp connection is released.
starting from the established state, there are two main paths through this fsm. the ﬁrst path is when the host receives a segment with sequence number x and the fin ﬂag set. the utilisation of the fin ﬂag indicates that the byte before sequence number x was the last byte of the byte stream sent by the remote host. once all of the data has been delivered to the user, the tcp entity sends an ack segment whose ack ﬁeld is set to (x + 1) mod 232 to acknowledge the fin segment. the fin segment is subject to the same retransmission mechanisms as a normal tcp segment. in particular, its transmission is protected by the retransmission timer. at this point, the tcp connection enters the close_wait state. in this state, the host can still send data to the remote host. once all its data have been sent, it sends a fin segment and enter the last_ack state. in this state, the tcp entity waits for the acknowledgement of its fin segment. it may still retransmit unacknowledged data segments e.g. if the retransmission timer expires. upon reception of the acknowledgement for the fin segment, the tcp connection is completely closed and its tcb can be discarded. the second path is when the host decides ﬁrst to send a fin segment. in this case, it enters the fin_wait1 state. it this state, it can retransmit unacknowledged segments but cannot send new data segments. it waits for an acknowledgement of its fin segment, but may receive a fin segment sent by the remote host. in the ﬁrst case, the tcp connection enters the fin_wait2 state. in this state, new data segments from the remote host are still accepted until the reception of the fin segment. the acknowledgement for this fin segment is sent once all data received before the fin segment have been delivered to the user and the connection enters the time_wait state. in the second case, a fin segment is received and the connection enters the closing state once all data received from the remote host have been delivered to the user. in this state, no new data segments can be sent and the host waits for an acknowledgement of its fin segment before entering the time_wait state. the time_wait state is different from the other states of the tcp fsm. a tcp entity enters this state after having sent the last ack segment on a tcp connection. this segment indicates to the remote host that all the data that it has sent have been correctly received and that it can safely release the tcp connection and discard
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
in a large ip network such as the global internet, routers need to exchange routing information. the internet is an interconnection of networks, often called domains, that are under different responsibilities. as of this writing, the internet is composed on more than 30,000 different domains and this number is still growing. a domain can be a small enterprise that manages a few routers in a single building, a larger enterprise with a hundred routers at multiple locations, or a large internet service provider managing thousands of routers. two classes of routing protocols are used to allow these domains to efﬁciently exchange routing information.
the ﬁrst class of routing protocols are the intradomain routing protocols (sometimes also called the interior gateway protocols or igp). an intradomain routing protocol is used by all routers inside a domain to exchange routing information about the destinations that are reachable inside the domain. there are several intradomain routing protocols. some domains use rip, which is a distance vector protocol. other domains use link-state routing protocols such as ospf or is-is. finally, some domains use static routing or proprietary protocols such as igrp or eigrp. these intradomain routing protocols usually have two objectives. first, they distribute routing information that corresponds to the shortest path between two routers in the domain. second, they should allow the routers to quickly recover from link and router failures. the second class of routing protocols are the interdomain routing protocols (sometimes also called the exterior gateway protocols or egp). the objective of an interdomain routing protocol is to distribute routing information between domains. for scalability reasons, an interdomain routing protocol must distribute aggregated routing information and considers each domain as a black box. a very important difference between intradomain and interdomain routing are the routing policies that are used by each domain. inside a single domain, all routers are considered equal, and when several routes are available to reach a given destination preﬁx, the best route is selected based on technical criteria such as the route with the shortest delay, the route with the minimum number of hops or the route with the highest bandwidth. when we consider the interconnection of domains that are managed by different organisations, this is no longer true. each domain implements its own routing policy. a routing policy is composed of three elements : an import ﬁlter that speciﬁes which routes can be accepted by a domain, an export ﬁlter that speciﬁes which routes can be advertised by a domain and a ranking algorithm that selects the best route when a domain knows several routes towards the same destination preﬁx. as we will see later, another important difference is that the objective of the interdomain routing protocol is to ﬁnd the cheapest route towards each destination. there is only one interdomain routing protocol : bgp.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
another problem faced by wireless networks is often called the hidden station problem. in a wireless network, radio signals are not always propagated same way in all directions. for example, two devices separated by a wall may not be able to receive each other’s signal while they could both be receiving the signal produced by a third host. this is illustrated in the ﬁgure below, but it can happen in other environments. for example, two devices that are on different sides of a hill may not be able to receive each other’s signal while they are both able to receive the signal sent by a station at the top of the hill. furthermore, the radio propagation conditions may change with time. for example, a truck may temporarily block the communication between two nearby devices.
to avoid collisions in these situations, csma/ca allows devices to reserve the transmission channel for some time. this is done by using two control frames : request to send (rts) and clear to send (cts). both are very short frames to minimize the risk of collisions. to reserve the transmission channel, a device sends a rts frame to the intended recipient of the data frame. the rts frame contains the duration of the requested reservation. the recipient replies, after a sifs delay, with a cts frame which also contains the duration of the reservation. as the duration of the reservation has been sent in both rts and cts, all hosts that could collide with either the sender or the reception of the data frame are informed of the reservation. they can compute the total duration of the transmission and defer their access to the transmission channel until then. this is illustrated in the ﬁgure below where host a reserves the transmission channel to send a data frame to host b. host c notices the reservation and defers its transmission.
the utilization of the reservations with csma/ca is an optimisation that is useful when collisions are frequent. if there are few collisions, the time required to transmit the rts and cts frames can become signiﬁcant and in particular when short frames are exchanged. some devices only turn on rts/cts after transmission errors.
most 802.11 deployments use a maximum payload size of 1500 bytes as they are used in infrastructure networks attached to ethernet lans. an 802.11 data frame is shown below.
the ﬁrst part of the 802.11 header is the 16 bit frame control ﬁeld. this ﬁeld contains ﬂags that indicate the type of frame (data frame, rts/cts, acknowledgement, management frames, etc), whether the frame is sent to or from a ﬁxed lan, etc [802.11]. the duration is a 16 bit ﬁeld that is used to reserve the transmission channel. in data frames, the duration ﬁeld is usually set to the time required to transmit one acknowledgement frame after a sifs delay. note that the duration ﬁeld must be set to zero in multicast and broadcast frames. as these frames are not acknowledged, there is no need to reserve the transmission channel after their transmission. the sequence control ﬁeld contains a 12 bits sequence number that is incremented for each data frame. the astute reader may have noticed that the 802.11 data frames contain three 48-bits address ﬁelds 12 . this is surprising compared to other protocols in the network and datalink layers whose headers only contain a source and a destination address. the need for a third address in the 802.11 header comes from the infrastructure networks. in such a network, frames are usually exchanged between routers and servers attached to the lan and wifi devices attached to one of the access points. the role of the three address ﬁelds is speciﬁed by bit ﬂags in the frame control ﬁeld. when a frame is sent from a wifi device to a server attached to the same lan as the access point, the ﬁrst address of the frame is set to the mac address of the access point, the second address is set to the mac address of the source wifi device and the third address is the address of the ﬁnal destination on the lan. when the server replies, it sends an ethernet frame whose source address is its mac address and the destination address is the mac address of the wifi device. this frame is captured by the access point that converts the ethernet header into an 802.11 frame header. the 802.11 frame sent by the access point contains three addresses : the ﬁrst address is the mac address of the destination wifi device, the second address is the mac address of the access point and the third address the mac address of the server that sent the frame. 802.11 control frames are simpler than data frames. they contain a frame control, a duration ﬁeld and one or two addresses. the acknowledgement frames are very small. they only contain the address of the destination of the acknowledgement. there is no source address and no sequence control ﬁeld in the acknowledgement frames. this is because the acknowledgement frame can easily be associated to the previous frame that it acknowledges. indeed, each unicast data frame contains a duration ﬁeld that is used to reserve the transmission channel to ensure that no collision will affect the acknowledgement frame. the sequence control ﬁeld is mainly used by the receiver to remove duplicate frames. duplicate frames are detected as follows. each data frame contains a 12 bits sequence control ﬁeld and the frame control ﬁeld contains the retry bit ﬂag that is set when a frame is transmitted. each 802.11 receiver stores the most recent sequence number received from each source address in frames whose retry bit is reset. upon reception of a frame with the retry bit set, the receiver veriﬁes its sequence number to determine whether it is a duplicated frame or not. 802.11 rts/cts frames are used to reserve the transmission channel, in order to transmit one data frame and its acknowledgement. the rts frames contain a duration and the transmitter and receiver addresses. the duration
throughout this book, we will deﬁne a service as a set of capabilities provided by a system (and its underlying elements) to its user. a user interacts with a service through a service access point. note that as shown in the ﬁgure above, users interact with one service provider. in practice, the service provider is distributed over several hosts, but these are implementation details that are not important at this stage. these interactions between a user and a service provider are expressed in [x200] by using primitives, as show in the ﬁgure below. these primitives are an abstract representation of the interactions between a user and a service provider. in practice, these interactions could be implemented as system calls for example.
• x.request. this type of primitive corresponds to a request issued by a user to a service provider • x.indication. this type of primitive is generated by the network provider and delivered to a user (often
• x.response. this type of primitive is generated by a user to answer to an earlier x.indication primitive • x.conﬁrm. this type of primitive is delivered by the service provide to conﬁrm to a user that a previous
primitives can be combined to model different types of services. the simplest service in computer networks is called the connectionless service 3. this service can be modelled by using two primitives :
• data.request(source,destination,sdu). this primitive is issued by a user that speciﬁes, as parameters, its (source) address, the address of the recipient of the message and the message itself. we will use service data unit (sdu) to name the message that is exchanged transparently between two users of a service. • data.indication(source,destination,sdu). this primitive is delivered by a service provider to a user.
it contains as parameters a service data unit as well as the addresses of the sender and the destination users. when discussing the service provided in a computer network, it is often useful to be able to describe the interactions between the users and the provider graphically. a frequently used representation is the time-sequence diagram. in this chapter and later throughout the book, we will often use diagrams such as the ﬁgure below. a time-sequence diagram describes the interactions between two users and a service provider. by convention, the users are represented in the left and right parts of the diagram while the service provider occupies the middle of the diagram. in such a time-sequence diagram, time ﬂows from the top, to the bottom of the diagram. each primitive
user auser bservice provider ("the network")service access pointprimitivesuser auser bservice provider ("the network")x.indicationx.responsex.confirmx.requestsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
contains information about its origin and its destination, and usually passes through several intermediate devices called routers on its way from its origin to its destination.
most realisations of the network layer, including the internet, do not provide a reliable service. however, many applications need to exchange information reliably and so using the network layer service directly would be very difﬁcult for them. ensuring the reliable delivery of the data produced by applications is the task of the transport layer. transport layer entities exchange segments. a segment is a ﬁnite sequence of bytes that are transported inside one or more packets. a transport layer entity issues segments (or sometimes part of segments) as data.request to the underlying network layer entity. there are different types of transport layers. the most widely used transport layers on the internet are tcp ,that provides a reliable connection-oriented bytestream transport service, and udp ,that provides an unreliable connection-less transport service.
the upper layer of our architecture is the application layer. this layer includes all the mechanisms and data structures that are necessary for the applications. we will use application data unit (adu) to indicate the data exchanged between two entities of the application layer.
in contrast with osi, the tcp/ip community did not spend a lot of effort deﬁning a detailed reference model; in fact, the goals of the internet architecture were only documented after tcp/ip had been deployed [clark88]. rfc 1122 , which deﬁnes the requirements for internet hosts, mentions four different layers. starting from the top, these are :
• an application layer • a transport layer • an internet layer which is equivalent to the network layer of our reference model • a link layer which combines the functionalities of the physical and datalink layers of our ﬁve-layer reference
physical layerdatalinknetworkphysical layerdatalinknetworkphysical layerdatalinknetworkpacketspacketsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportsegmentsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportaduapplicationapplicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
a selective repeat receiver maintains a sliding window of w segments and stores in a buffer the out-of-sequence segments that it receives. the ﬁgure below shows a ﬁve segment receive window on a receiver that has already received segments 7 and 9.
a selective repeat receiver discards all segments having an invalid crc, and maintains the variable lastack as the sequence number of the last in-sequence segment that it has received. the receiver always includes the value of lastack in the acknowledgements that it sends. some protocols also allow the selective repeat receiver to acknowledge the out-of-sequence segments that it has received. this can be done for example by placing the list of the sequence numbers of the correctly received, but out-of-sequence segments in the acknowledgements together with the lastack value. when a selective repeat receiver receives a data segment, it ﬁrst veriﬁes whether the segment is inside its receiving window. if yes, the segment is placed in the receive buffer. if not, the received segment is discarded and an acknowledgement containing lastack is sent to the sender. the receiver then removes all consecutive segments starting at lastack (if any) from the receive buffer. the payloads of these segments are delivered to the user, lastack and the receiving window are updated, and an acknowledgement acknowledging the last segment received in sequence is sent. the selective repeat sender maintains a sending buffer that can store up to w unacknowledged segments. these segments are sent as long as the sending buffer is not full. several implementations of a selective repeat sender are possible. a simple implementation is to associate a retransmission timer to each segment. the timer is started when the segment is sent and cancelled upon reception of an acknowledgement that covers this segment. when a retransmission timer expires, the corresponding segment is retransmitted and this retransmission timer is restarted. when an acknowledgement is received, all the segments that are covered by this acknowledgement are removed from the sending buffer and the sliding window is updated. the ﬁgure below illustrates the operation of selective repeat when segments are lost. in this ﬁgure, c(ok,x) is used to indicate that all segments, up to and including sequence number x have been received correctly.
pure cumulative acknowledgements work well with the go-back-n strategy. however, with only cumulative acknowledgements a selective repeat sender cannot easily determine which data segments have been correctly received after a data segment has been lost. for example, in the ﬁgure above, the second c(ok,0) does not inform
easiest and less costly method to send acknowledgements is to place them in the data segments sent in the other direction. however, few application layer protocols exchange data in both directions at the same time and thus this method rarely works. for an application that is sending data segments in one direction only, the remote tcp entity returns empty tcp segments whose only useful information is their acknowledgement number. this may cause a large overhead in wide area network if a pure ack segment is sent in response to each received data segment. most tcp implementations use a delayed acknowledgement strategy. this strategy ensures that piggybacking is used whenever possible, otherwise pure ack segments are sent for every second received data segments when there are no losses. when there are losses or reordering, ack segments are more important for the sender and they are sent immediately rfc 813 rfc 1122. this strategy relies on a new timer with a short delay (e.g. 50 milliseconds) and one additional ﬂag in the tcb. it can be implemented as follows
due to this delayed acknowledgement strategy, during a bulk transfer, a tcp implementation usually acknowledges every second tcp segment received. the default go-back-n retransmission strategy used by tcp has the advantage of being simple to implement, in particular on the receiver side, but when there are losses, a go-back-n strategy provides a lower performance than a selective repeat strategy. the tcp developers have designed several extensions to tcp to allow it to use a selective repeat strategy while maintaining backward compatibility with older tcp implementations. these tcp extensions assume that the receiver is able to buffer the segments that it receives out-of-sequence. the ﬁrst extension that was proposed is the fast retransmit heuristic. this extension can be implemented on tcp senders and thus does not require any change to the protocol. it only assumes that the tcp receiver is able to buffer out-of-sequence segments. from a performance point of view, one issue with tcp’s retransmission timeout is that when there are isolated segment losses, the tcp sender often remains idle waiting for the expiration of its retransmission timeouts. such isolated losses are frequent in the global internet [paxson99]. a heuristic to deal with isolated losses without waiting for the expiration of the retransmission timeout has been included in many tcp implementations since the early 1990s. to understand this heuristic, let us consider the ﬁgure below that shows the segments exchanged over a tcp connection when an isolated segment is lost. as shown above, when an isolated segment is lost the sender receives several duplicate acknowledgements since the tcp receiver immediately sends a pure acknowledgement when it receives an out-of-sequence segment. a duplicate acknowledgement is an acknowledgement that contains the same acknowledgement number as a previous segment. a single duplicate acknowledgement does not necessarily imply that a segment was lost, as a simple reordering of the segments may cause duplicate acknowledgements as well. measurements [paxson99] have shown that segment reordering is frequent in the internet. based on these observations, the fast retransmit heuristic has been included in most tcp implementations. it can be implemented as follows
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
many protocols have been deﬁned for networked applications. in this section, we describe some of the important applications that are used on the internet. we ﬁrst explain the domain name system (dns) that enables hosts to be identiﬁed by human-friendly names instead of the ipv4 or ipv6 addresses that are used by the network. then, we describe the operation of electronic mail, one of the ﬁrst killer applications on the global internet, and the protocols used on world wide web.
in the early days of the internet, there were only a few number of hosts (mainly minicomputers) connected to the network. the most popular applications were remote login and ﬁle transfer. by 1983, there were already ﬁve hundred hosts attached to the internet. each of these hosts were identiﬁed by a unique ipv4 address. forcing human users to remember the ipv4 addresses of the remote hosts that they want to use was not user-friendly. human users prefer to remember names, and use them when needed. using names as aliases for addresses is a common technique in computer science. it simpliﬁes the development of applications and allows the developer to ignore the low level details. for example, by using a programming language instead of writing machine code, a developer can write software without knowing whether the variables that it uses are stored in memory or inside registers. because names are at a higher level than addresses, they allow (both in the example of programming above, and on the internet) to treat addresses as mere technical identiﬁers, which can change at will. only the names are stable. on today’s internet, where switching to another isp means changing your ip addresses, the user-friendliness of domain names is less important (they are not often typed by users) but their stability remains a very important, may be their most important property. the ﬁrst solution that allowed applications to use names was the hosts.txt ﬁle. this ﬁle is similar to the symbol table found in compiled code. it contains the mapping between the name of each internet host and its associated ip address 2. it was maintained by sri international that coordinated the network information center (nic). when a new host was connected to the network, the system administrator had to register its name and ip address at the nic. the nic updated the hosts.txt ﬁle on its server. all internet hosts regularly retrieved the updated hosts.txt ﬁle from the server maintained by sri. this ﬁle was stored at a well-known location on each internet host (see rfc 952) and networked applications could use it to ﬁnd the ip address corresponding to a name. a hosts.txt ﬁle can be used when there are up to a few hundred hosts on the network. however, it is clearly not suitable for a network containing thousands or millions of hosts. a key issue in a large network is to deﬁne a suitable naming scheme. the arpanet initially used a ﬂat naming space, i.e. each host was assigned a unique name. to limit collisions between names, these names usually contained the name of the institution and a sufﬁx to identify the host inside the institution (a kind of poor man’s hierarchical naming scheme). on the arpanet few institutions had several hosts connected to the network. however, the limitations of a ﬂat naming scheme became clear before the end of the arpanet and rfc 819 proposed a hierarchical naming scheme. while rfc 819 discussed the possibility of organising the names as a directed graph, the internet opted eventually for a tree structure capable of containing all names. in this tree, the top-level domains are those that are directly attached to the root. the ﬁrst top-level domain was .arpa 3. this top-level name was initially added as a sufﬁx to the names of the hosts attached to the arpanet and listed in the hosts.txt ﬁle. in 1984, the .gov, .edu, .com, .mil and .org generic top-level domain names were added and rfc 1032 proposed the utilisation of the two letter iso-3166 country codes as top-level domain names. since iso-3166 deﬁnes a two letter code for each country recognised by the united nations, this allowed all countries to automatically have a top-level domain. these domains include .be for belgium, .fr for france, .us for the usa, .ie for ireland or .tv for tuvalu, a group of small islands in the paciﬁc and .tm for turkmenistan. today, the set of top-level domain-names is managed by the internet corporation for assigned names and numbers (icann). recently, icann added a dozen of generic top-level domains that are not related to a country and the .cat top-level domain has been registered for the catalan language. there are ongoing discussions within icann to increase the number of top-level domains.
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
12. the dns protocol can run over udp and over tcp. most dns servers prefer to use udp because it consumes fewer resources on the server. however, tcp is useful when a large answer is expected or when a large answer must. you can force the utilisation of tcp by using dig +tcp. use tcp and udp to query a root dns server. is it faster to receive an answer via tcp or via udp ?
many internet protocols are ascii-based protocols where the client sends requests as one line of ascii text terminated by crlf and the server replies with one of more lines of ascii text. using such ascii messages has several advantages compared to protocols that rely on binary encoded messages
• it is often easy to write a small prototype that implements a part of the protocol • it is possible to test a server manually by using telnet telnet is a protocol that allows to obtain a terminal on a remote server. for this, telnet opens a tcp connection with the remote server on port 23. however, most telnet implementations allow the user to specify an alternate port as telnet hosts port when used with a port number as parameter, telnet opens a tcp connection to the remote host on the speciﬁed port. telnet can thus be used to test any server using an ascii-based protocol on top of tcp. note that if you need to stop a running telnet session, ctrl-c will not work as it will be sent by telnet to the remote host over the tcp connection. on many telnet implementations you can type ctrl-] to freeze the tcp connection and return to the telnet interface.
2. same question when alice sends an email to her friend trudy, trudy@gmail.com. 3. before the advent of webmail and feature rich mailers, email was written and read by using command line tools on servers. using your account on sirius.info.ucl.ac.be use the /bin/mail command line tool to send an email to yourself on this host. this server stores local emails in the /var/mail directory with one ﬁle per user. check with /bin/more the content of your mail ﬁle and try to understand which lines have been added by the server in the header of your email.
4. use your preferred email tool to send an email message to yourself containing a single line of text. most email tools have the ability to show the source of the message, use this function to look at the message that you sent and the message that you received. can you ﬁnd an explanation for all the lines that have been added to your single line email 24 ?
6. when using smtp, how do you recognise a positive reply from a negative one ? 7. a smtp server is a daemon process that can fail due to a bug or lack of resources (e.g. memory). network administrators often install tools 26 that regularly connect to their servers to check that they are operating correctly. a simple solution is to open a tcp connection on port 25 to the smtp server’s host 27 . if the connection is established, this implies that there is a process listening. what is the reply sent by the smtp server when you type the following command ? telnet cnp3.info.ucl.ac.be 25
24 since rfc 821, smtp has evolved a lot due notably to the growing usage of email and the need to protect the email system against spammers. it is unlikely that you will be able to explain all the additional lines that you will ﬁnd in email headers, but we’ll discuss them together.
25 a shorter description of the smtp protocol may be found on wikipedia at http://en.wikipedia.org/wiki/simple_mail_transfer_protocol 26 there are many monitoring tools available. nagios is a very popular open source monitoring system. 27 note that using telnet to connect to a remote host on port 25 may not work in all networks. due to the spam problem, many isp networks do not allow their customers to use port tcp 25 directly and force them to use the isp’s mail relay to forward their email. thanks to this, if a software sending spam has been installed on the pc of one of the isp’s customers, this software will not be able to send a huge amount of spam. if you connect to nostromo.info.ucl.ac.be from the ﬁxed stations in ingi’s lab, you should not be blocked.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
initially, email was used to exchange small messages of ascii text between computer scientists. however, with the growth of the internet, supporting only ascii text became a severe limitation for two reasons. first of all, non-english speakers wanted to write emails in their native language that often required more characters than those of the ascii character table. second, many users wanted to send other content than just ascii text by email such as binary ﬁles, images or sound. to solve this problem, the ietf developed the multipurpose internet mail extensions (mime). these extensions were carefully designed to allow internet email to carry non-ascii characters and binary ﬁles without breaking the email servers that were deployed at that time. this requirement for backward compatibility forced the mime designers to develop extensions to the existing email message format rfc 822 instead of deﬁning a completely new format that would have been better suited to support the new types of emails. rfc 2045 deﬁnes three new types of header lines to support mime :
• the mime-version: header indicates the version of the mime speciﬁcation that was used to encode the email message. the current version of mime is 1.0. other versions of mime may be deﬁned in the future. thanks to this header line, the software that processes email messages will be able to adapt to the mime version used to encode the message. messages that do not contain this header are supposed to be formatted according to the original rfc 822 speciﬁcation.
• the content-type: header line indicates the type of data that is carried inside the message (see below) • the content-transfer-encoding: header line is used to specify how the message has been encoded. when mime was designed, some email servers were only able to process messages containing characters encoded using the 7 bits ascii character set. mime allows the utilisation of other character encodings.
inside the email header, the content-type: header line indicates how the mime email message is structured. rfc 2046 deﬁnes the utilisation of this header line. the two most common structures for mime messages are :
• content-type: multipart/alternative. this header line indicates that the mime message contains several representations of the same information. for example, a multipart/alternative message may contain both a plain text and an html version of the same text.
to support these two types of mime messages, the recipient of a message must be able to extract the different parts from the message. in rfc 822, an empty line was used to separate the header lines from the body. using an empty line to separate the different parts of an email body would be difﬁcult as the body of email messages often contains one or more empty lines. another possible option would be to deﬁne a special line, e.g. *-last_line-* to mark the boundary between two parts of a mime message. unfortunately, this is not possible as some emails may contain this string in their body (e.g. emails sent to students to explain the format of mime messages). to solve this problem, the content-type: header line contains a second parameter that speciﬁes the string that has been used by the sender of the mime message to delineate the different parts. in practice, this string is often chosen randomly by the mail client. the email message below, copied from rfc 2046 shows a mime message containing two parts that are both in plain text and encoded using the ascii character set. the string simple boundary is deﬁned in the content-type: header as the marker for the boundary between two successive parts. another example of mime messages may be found in rfc 2046.
date: mon, 20 sep 1999 16:33:16 +0200 from: nathaniel borenstein <nsb@bellcore.com> to: ned freed <ned@innosoft.com> subject: test mime-version: 1.0 content-type: multipart/mixed; boundary="simple boundary"
as mentioned in the ﬁrst section of this chapter, there are three main types of datalink layers : point-to-point links, lans supporting broadcast and multicast and nbma networks. there are two important issues to be addressed when using ipv4 in these types of networks. the ﬁrst issue is how an ipv4 device obtains its ipv4 address. the second issue is how ipv4 packets are exchanged over the datalink layer service. on a point-to-point link, the ipv4 addresses of the communicating devices can be conﬁgured manually or by using a simple protocol. ipv4 addresses are often conﬁgured manually on point-to-point links between routers. when point-to-point links are used to attach hosts to the network, automatic conﬁguration is often preferred in order to avoid problems with incorrect ipv4 addresses. for example, the ppp, speciﬁed in rfc 1661, includes an ip network control protocol that can be used by the router in the ﬁgure below to send the ipv4 address that the attached host must conﬁgure for its interface. the transmission of ipv4 packets on a point-to-point link will be discussed in chapter chap:lan.
using ipv4 in a lan introduces an additional problem. on a lan, each device is identiﬁed by its unique datalink layer address. the datalink layer service can be used by any host attached to the lan to send a frame to any other host attached to the same lan. for this, the sending host must know the datalink layer address of the destination host. for example, the ﬁgure below shows four hosts attached to the same lan conﬁgured with ipv4 addresses in the 10.0.1.0/24 subnet and datalink layer addresses represented as a single character 12. in this network, if host 10.0.1.22/24 wants to send an ipv4 packet to the host having address 10.0.1.8, it must know that the datalink layer address of this host is c.
in a simple network such as the one shown above, it could be possible to manually conﬁgure the mapping between the ipv4 addresses of the hosts and the corresponding datalink layer addresses. however, in a larger lan this is impossible. to ease the utilisation of lans, ipv4 hosts must be able to automatically obtain the datalink layer address corresponding to any ipv4 address on the same lan. this is the objective of the address resolution protocol (arp) deﬁned in rfc 826. arp is a datalink layer protocol that is used by ipv4. it relies on the ability of the datalink layer service to easily deliver a broadcast frame to all devices attached to the same lan.
aimd additive increase, multiplicative decrease. a rate adaption algorithm used notably by tcp where a host additively increases its transmission rate when the network is not congested and multiplicatively decreases when congested is detected.
arpanet the advanced research project agency (arpa) network is a network that was built by network scientists in usa with funding from the arpa of the us ministry of defense. arpanet is considered as the grandfather of today’s internet.
ascii the american standard code for information interchange (ascii) is a character-encoding scheme that deﬁnes a binary representation for characters. the ascii table contains both printable characters and control characters. ascii characters were encoded in 7 bits and only contained the characters required to write text in english. other character sets such as unicode have been developed later to support all written languages.
asn.1 the abstract syntax notation one (asn.1) was designed by iso and itu-t. it is a standard and ﬂexible notation that can be used to describe data structures for representing, encoding, transmitting, and decoding data between applications. it was designed to be used in the presentation layer of the osi reference model but is now used in other protocols such as snmp.
atm asynchronous transfer mode bgp the border gateway protocol is the interdomain routing protocol used in the global internet. bnf a backus-naur form (bnf) is a formal way to describe a language by using syntactic and lexical rules. bnfs are frequently used to deﬁne programming languages, but also to deﬁne the messages exchanged between networked applications. rfc 5234 explains how a bnf must be written to specify an internet protocol.
broadcast a transmission mode where is same information is sent to all nodes in the network cidr classless inter domain routing is the current address allocation architecture for ipv4. it was deﬁned in
dial-up line a synonym for a regular telephone line, i.e. a line that can be used to dial any telephone number. dns the domain name system is a distributed database that allows to map names on ip addresses. dns the domain name system is deﬁned in rfc 1035
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
denial of service attacks when a tcp entity opens a tcp connection, it creates a transmission control block (tcb). the tcb contains the entire state that is maintained by the tcp entity for each tcp connection. during connection establishment, the tcb contains the local ip address, the remote ip address, the local port number, the remote port number, the current local sequence number, the last sequence number received from the remote entity. until the mid 1990s, tcp implementations had a limit on the number of tcp connections that could be in the syn rcvd state at a given time. many implementations set this limit to about 100 tcbs. this limit was considered sufﬁcient even for heavily load http servers given the small delay between the reception of a syn segment and the reception of the ack segment that terminates the establishment of the tcp connection. when the limit of 100 tcbs in the syn rcvd state is reached, the tcp entity discards all received tcp syn segments that do not correspond to an existing tcb. this limit of 100 tcbs in the syn rcvd state was chosen to protect the tcp entity from the risk of overloading its memory with too many tcbs in the syn rcvd state. however, it was also the reason for a new type of denial of service (dos) attack rfc 4987. a dos attack is deﬁned as an attack where an attacker can render a resource unavailable in the network. for example, an attacker may cause a dos attack on a 2 mbps link used by a company by sending more than 2 mbps of packets through this link. in this case, the dos attack was more subtle. as a tcp entity discards all received syn segments as soon as it has 100 tcbs in the syn rcvd state, an attacker simply had to send a few 100 syn segments every second to a server and never reply to the received syn+ack segments. to avoid being caught, attackers were of course sending these syn segments with a different address than their own ip address a. on most tcp implementations, once a tcb entered the syn rcvd state, it remained in this state for several seconds, waiting for a retransmission of the initial syn segment. this attack was later called a syn ﬂood attack and the servers of the isp named panix were among the ﬁrst to be affected by this attack. to avoid the syn ﬂood attacks, recent tcp implementations no longer enter the syn rcvd state upon reception of a syn segment. instead, they reply directly with a syn+ack segment and wait until the reception of a valid ack. this implementation trick is only possible if the tcp implementation is able to verify that the received ack segment acknowledges the syn+ack segment sent earlier without storing the initial sequence number of this syn+ack segment in a tcb. the solution to solve this problem, which is known as syn cookies is to compute the 32 bits of the isn as follows :
• the high order bits contain the low order bits of a counter that is incremented slowly • the low order bits contain a hash value computed over the local and remote ip addresses and ports and
the advantage of the syn cookies is that by using them, the server does not need to create a tcb upon reception of the syn segment and can still check the returned ack segment by recomputing the syn cookie.
retransmitting the ﬁrst syn segment as ip provides an unreliable connectionless service, the syn and syn+ack segments sent to open a tcp connection could be lost. current tcp implementations start a retransmission timer when they send the ﬁrst syn segment. this timer is often set to three seconds for the ﬁrst retransmission and then doubles after each retransmission rfc 2988. tcp implementations also enforce a maximum number of retransmissions for the initial syn segment.
as explained earlier, tcp segments may contain an optional header extension. in the syn and syn+ack segments, these options are used to negotiate some parameters and the utilisation of extensions to the basic tcp speciﬁcation. the ﬁrst parameter which is negotiated during the establishment of a tcp connection is the maximum segment size (mss). the mss is the size of the largest segment that a tcp entity is able to process. according to rfc 879, all tcp implementations must be able to receive tcp segments containing 536 bytes of payload. however, most tcp implementations are able to process larger segments. such tcp implementations use the tcp mss option in the syn/syn+ack segment to indicate the largest segment they are able to process. the mss value indicates the maximum size of the payload of the tcp segments. the client (resp. server) stores in its tcb the mss value announced by the server (resp. the client).
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
address. as this address is placed at the beginning of the frame, an ethernet interface can quickly verify whether it is the frame recipient and if not, cancel the processing of the arriving frame. the second ﬁeld is the source address. while the destination address can be either a unicast or a multicast/broadcast address, the source address must always be a unicast address. the third ﬁeld is a 16 bits integer that indicates which type of network layer packet is carried inside the frame. this ﬁeld is often called the ethertype. frequently used ethertype values 6 include 0x0800 for ipv4, 0x86dd for ipv6 7 and 0x806 for the address resolution protocol (arp). the fourth part of the ethernet frame is the payload. the minimum length of the payload is 46 bytes to ensure a minimum frame size, including the header of 512 bits. the ethernet payload cannot be longer than 1500 bytes. this size was found reasonable when the ﬁrst ethernet speciﬁcation was written. at that time, xerox had been using its experimental 3 mbps ethernet that offered 554 bytes of payload and rfc 1122 required a minimum mtu of 572 bytes for ipv4. 1500 bytes was large enough to support these needs without forcing the network adapters to contain overly large memories. furthermore, simulations and measurement studies performed in ethernet networks revealed that csma/cd was able to achieve a very high utilization. this is illustrated in the ﬁgure below based on [sh1980], which shows the channel utilization achieved in ethernet networks containing different numbers of hosts that are sending frames of different sizes.
the last ﬁeld of the ethernet frame is a 32 bit cyclical redundancy check (crc). this crc is able to catch a much larger number of transmission errors than the internet checksum used by ip, udp and tcp [sgp98]. the format of the ethernet frame is shown below.
note: where should the crc be located in a frame ? the transport and datalink layers usually chose different strategies to place their crcs or checksums. transport layer protocols usually place their crcs or checksums in the segment header. datalink layer protocols sometimes place their crc in the frame header, but often in a trailer at the end of the frame. this choice reﬂects implementation assumptions, but also inﬂuences performance rfc 893. when the crc is placed in the trailer, as in ethernet, the datalink layer can compute it while transmitting the frame and insert it at the end of the transmission. all ethernet interfaces use this optimisation today. when the checksum is placed in the header, as in a tcp segment, it is impossible for the network interface to compute it while transmitting the segment. some network interfaces provide hardware assistance to compute the tcp checksum, but this is more complex than if the tcp checksum were placed in the trailer 8.
6 the ofﬁcial list of all assigned ethernet type values is available from http://standards.ieee.org/regauth/ethertype/eth.txt 7 the attentive reader may question the need for different ethertypes for ipv4 and ipv6 while the ip header already contains a version ﬁeld that can be used to distinguish between ipv4 and ipv6 packets. theoretically, ipv4 and ipv6 could have used the same ethertype. unfortunately, developers of the early ipv6 implementations found that some devices did not check the version ﬁeld of the ipv4 packets that they received and parsed frames whose ethertype was set to 0x0800 as ipv4 packets. sending ipv6 packets to such devices would have caused disruptions. to avoid this problem, the ietf decided to apply for a distinct ethertype value for ipv6.
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
the ethernet frame format shown above is speciﬁed in [dix]. this is the format used to send both ipv4 rfc 894 and ipv6 packets rfc 2464. after the publication of [dix], the institute of electrical and electronic engineers (ieee) began to standardise several local area network technologies. ieee worked on several lan technologies, starting with ethernet, token ring and token bus. these three technologies were completely different, but they all agreed to use the 48 bits mac addresses speciﬁed initially for ethernet [802]_ . while developing its ethernet standard [802.3], the ieee 802.3 working group was confronted with a problem. ethernet mandated a minimum payload size of 46 bytes, while some companies were looking for a lan technology that could transparently transport short frames containing only a few bytes of payload. such a frame can be sent by an ethernet host by padding it to ensure that the payload is at least 46 bytes long. however since the ethernet header [dix] does not contain a length ﬁeld, it is impossible for the receiver to determine how many useful bytes were placed inside the payload ﬁeld. to solve this problem, the ieee decided to replace the type ﬁeld of the ethernet [dix] header with a length ﬁeld 9. this length ﬁeld contains the number of useful bytes in the frame payload. the payload must still contain at least 46 bytes, but padding bytes are added by the sender and removed by the receiver. in order to add the length ﬁeld without signiﬁcantly changing the frame format, ieee had to remove the type ﬁeld. without this ﬁeld, it is impossible for a receiving host to identify the type of network layer packet inside a received frame. to solve this new problem, ieee developed a completely new sublayer called the logical link control [802.2]. several protocols were deﬁned in this sublayer. one of them provided a slightly different version of the type ﬁeld of the original ethernet frame format. another contained acknowledgements and retransmissions to provide a reliable service... in practice, [802.2] is never used to support ip in ethernet networks. the ﬁgure below shows the ofﬁcial [802.3] frame format.
9 fortunately, ieee was able to deﬁne the [802.3] frame format while maintaining backward compatibility with the ethernet [dix] frame format. the trick was to only assign values above 1500 as ethertype values. when a host receives a frame, it can determine whether the frame’s format by checking its ethertype/length ﬁeld. a value lower smaller than 1501 is clearly a length indicator and thus an [802.3] frame. a value larger than 1501 can only be type and thus a [dix] frame.
ﬁeld of the rts frame indicates the duration of the entire reservation (i.e. the time required to transmit the cts, the data frame, the acknowledgements and the required sifs delays). the cts frame has the same format as the acknowledgement frame.
note: the 802.11 service despite the utilization of acknowledgements, the 802.11 layer only provides an unreliable connectionless service like ethernet networks that do not use acknowledgements. the 802.11 acknowledgements are used to minimize the probability of frame duplication. they do not guarantee that all frames will be correctly received by their recipients. like ethernet, 802.11 networks provide a high probability of successful delivery of the frames, not a guarantee. furthermore, it should be noted that 802.11 networks do not use acknowledgements for multicast and broadcast frames. this implies that in practice such frames are more likely to suffer from transmission errors than unicast frames.
in addition to the data and control frames that we have brieﬂy described above, 802.11 networks use several types of management frames. these management frames are used for various purposes. we brieﬂy describe some of these frames below. a detailed discussion may be found in [802.11] and [gast2002]. a ﬁrst type of management frames are the beacon frames. these frames are broadcasted regularly by access points. each beacon frame contains information about the capabilities of the access point (e.g. the supported 802.11 transmission rates) and a service set identity (ssid). the ssid is a null-terminated ascii string that can contain up to 32 characters. an access point may support several ssids and announce them in beacon frames. an access point may also choose to remain silent and not advertise beacon frames. in this case, wifi stations may send probe request frames to force the available access points to return a probe response frame.
note: ip over 802.11 two types of encapsulation schemes were deﬁned to support ip in ethernet networks : the original encapsulation scheme, built above the ethernet dix format is deﬁned in rfc 894 and a second encapsulation rfc 1042 scheme, built above the llc/snap protocol [802.2]. in 802.11 networks, the situation is simpler and only the rfc 1042 encapsulation is used. in practice, this encapsulation adds 6 bytes to the 802.11 header. the ﬁrst four bytes correspond to the llc/snap header. they are followed by the two bytes ethernet type ﬁeld (0x800 for ip and 0x806 for arp). the ﬁgure below shows an ip packet encapsulated in an 802.11 frame.
the second important utilisation of the management frames is to allow a wifi station to be associated with an access point. when a wifi station starts, it listens to beacon frames to ﬁnd the available ssids. to be allowed to
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
• snd.una : the earliest sequence number that has been sent but has not yet been acknowledged • snd.wnd : the current size of the sending window (in bytes) • rcv.nxt : the sequence number of the next byte that is expected to be received from the remote host • rcv.wnd : the current size of the receive window advertised by the remote host • sending buffer : a buffer used to store all unacknowledged data • receiving buffer : a buffer to store all data received from the remote host that has not yet been delivered to the user. data may be stored in the receiving buffer because either it was not received in sequence or because the user is too slow to process it
the original tcp speciﬁcation can be categorised as a transport protocol that provides a byte stream service and uses go-back-n. to send new data on an established connection, a tcp entity performs the following operations on the corresponding tcb. it ﬁrst checks that the sending buffer does not contain more data than the receive window advertised by the remote host (rcv.wnd). if the window is not full, up to mss bytes of data are placed in the payload of a tcp segment. the sequence number of this segment is the sequence number of the ﬁrst byte of the payload. it is set to the ﬁrst available sequence number : snd.nxt and snd.nxt is incremented by the length of the payload of the tcp segment. the acknowledgement number of this segment is set to the current value of rcv.nxt and the window ﬁeld of the tcp segment is computed based on the current occupancy of the receiving buffer. the data is kept in the sending buffer in case it needs to be retransmitted later. when a tcp segment with the ack ﬂag set is received, the following operations are performed. rcv.wnd is set to the value of the window ﬁeld of the received segment. the acknowledgement number is compared to snd.una. the newly acknowledged data is remove from the sending buffer and snd.una is updated. if the tcp segment contained data, the sequence number is compared to rcv.nxt. if they are equal, the segment was received in sequence and the data can be delivered to the user and rcv.nxt is updated. the contents of the receiving buffer is checked to see whether other data already present in this buffer can be delivered in sequence to the user. if so, rcv.nxt is updated again. otherwise, the segment’s payload is placed in the receiving buffer.
in a transport protocol such as tcp that offers a bytestream, a practical issue that was left as an implementation choice in rfc 793 is to decide when a new tcp segment containing data must be sent. there are two simple and extreme implementation choices. the ﬁrst implementation choice is to send a tcp segment as soon as the user has requested the transmission of some data. this allows tcp to provide a low delay service. however, if the user is sending data one byte at a time, tcp would place each user byte in a segment containing 20 bytes of tcp header 17. this is a huge overhead that is not acceptable in wide area networks. a second simple solution would be to only transmit a new tcp segment once the user has produced mss bytes of data. this solution reduces the overhead, but at the cost of a potentially very high delay. an elegant solution to this problem was proposed by john nagle in rfc 896. john nagle observed that the overhead caused by the tcp header was a problem in wide area connections, but less in local area connections where the available bandwidth is usually higher. he proposed the following rules to decide to send a new data segment when a new data has been produced by the user or a new ack segment has been received
depicted below which is similar to the one discussed in [jacobson1988] and rfc 896. in this network, we assume that the buffers of the router are inﬁnite to ensure that no packet is lost.
if many tcp senders are attached to the left part of the network above, they all send a window full of segments. these segments are stored in the buffers of the router before being transmitted towards their destination. if there are many senders on the left part of the network, the occupancy of the buffers quickly grows. a consequence of the buffer occupancy is that the round-trip-time, measured by tcp, between the sender and the receiver increases. consider a network where 10,000 bits segments are sent. when the buffer is empty, such a segment requires 1 millisecond to be transmitted on the 10 mbps link and 5 milliseconds to be the transmitted on the 2 mbps link. thus, the round-trip-time measured by tcp is roughly 6 milliseconds if we ignore the propagation delay on the links. most routers manage their buffers as a fifo queue 25. if the buffer contains 100 segments, the round-triptime becomes 1 + 100 × 5 + 5 milliseconds as new segments are only transmitted on the 2 mbps link once all previous segments have been transmitted. unfortunately, tcp uses a retransmission timer and performs go-back-n to recover from transmission errors. if the buffer occupancy is high, tcp assumes that some segments have been lost and retransmits a full window of segments. this increases the occupancy of the buffer and the delay through the buffer... furthermore, the buffer may store and send on the low bandwidth links several retransmissions of the same segment. this problem is called congestion collapse. it occurred several times in the late 1980s. for example, [jacobson1988] notes that in 1986, the usable bandwidth of a 32 kbits link dropped to 40 bits per second due to congestion collapse 26 ! the congestion collapse is a problem that all heterogeneous networks face. different mechanisms have been proposed in the scientiﬁc literature to avoid or control network congestion. some of them have been implemented and deployed in real networks. to understand this problem in more detail, let us ﬁrst consider a simple network with two hosts attached to a high bandwidth link that are sending segments to destination c attached to a low bandwidth link as depicted below.
to avoid congestion collapse, the hosts must regulate their transmission rate 27 by using a congestion control mechanism. such a mechanism can be implemented in the transport layer or in the network layer. in tcp/ip networks, it is implemented in the transport layer, but other technologies such as asynchronous transfer mode (atm) or frame relay include congestion control mechanisms in lower layers. let us ﬁrst consider the simple problem of a set of i hosts that share a single bottleneck link as shown in the example above. in this network, the congestion control scheme must achieve the following objectives [cj1989] :
25 we discuss in another chapter other possible organisations of the router’s buffers. 26 at this time, tcp implementations were mainly following rfc 791. the round-trip-time estimations and the retransmission mechanisms
27 in this section, we focus on congestion control mechanisms that regulate the transmission rate of the hosts. other types of mechanisms have been proposed in the literature. for example, credit-based ﬂow-control has been proposed to avoid congestion in atm networks [kr1995]. with a credit-based mechanism, hosts can only send packets once they have received credits from the routers and the credits depend on the occupancy of the router’s buffers.
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
many protocols have been deﬁned for networked applications. in this section, we describe some of the important applications that are used on the internet. we ﬁrst explain the domain name system (dns) that enables hosts to be identiﬁed by human-friendly names instead of the ipv4 or ipv6 addresses that are used by the network. then, we describe the operation of electronic mail, one of the ﬁrst killer applications on the global internet, and the protocols used on world wide web.
in the early days of the internet, there were only a few number of hosts (mainly minicomputers) connected to the network. the most popular applications were remote login and ﬁle transfer. by 1983, there were already ﬁve hundred hosts attached to the internet. each of these hosts were identiﬁed by a unique ipv4 address. forcing human users to remember the ipv4 addresses of the remote hosts that they want to use was not user-friendly. human users prefer to remember names, and use them when needed. using names as aliases for addresses is a common technique in computer science. it simpliﬁes the development of applications and allows the developer to ignore the low level details. for example, by using a programming language instead of writing machine code, a developer can write software without knowing whether the variables that it uses are stored in memory or inside registers. because names are at a higher level than addresses, they allow (both in the example of programming above, and on the internet) to treat addresses as mere technical identiﬁers, which can change at will. only the names are stable. on today’s internet, where switching to another isp means changing your ip addresses, the user-friendliness of domain names is less important (they are not often typed by users) but their stability remains a very important, may be their most important property. the ﬁrst solution that allowed applications to use names was the hosts.txt ﬁle. this ﬁle is similar to the symbol table found in compiled code. it contains the mapping between the name of each internet host and its associated ip address 2. it was maintained by sri international that coordinated the network information center (nic). when a new host was connected to the network, the system administrator had to register its name and ip address at the nic. the nic updated the hosts.txt ﬁle on its server. all internet hosts regularly retrieved the updated hosts.txt ﬁle from the server maintained by sri. this ﬁle was stored at a well-known location on each internet host (see rfc 952) and networked applications could use it to ﬁnd the ip address corresponding to a name. a hosts.txt ﬁle can be used when there are up to a few hundred hosts on the network. however, it is clearly not suitable for a network containing thousands or millions of hosts. a key issue in a large network is to deﬁne a suitable naming scheme. the arpanet initially used a ﬂat naming space, i.e. each host was assigned a unique name. to limit collisions between names, these names usually contained the name of the institution and a sufﬁx to identify the host inside the institution (a kind of poor man’s hierarchical naming scheme). on the arpanet few institutions had several hosts connected to the network. however, the limitations of a ﬂat naming scheme became clear before the end of the arpanet and rfc 819 proposed a hierarchical naming scheme. while rfc 819 discussed the possibility of organising the names as a directed graph, the internet opted eventually for a tree structure capable of containing all names. in this tree, the top-level domains are those that are directly attached to the root. the ﬁrst top-level domain was .arpa 3. this top-level name was initially added as a sufﬁx to the names of the hosts attached to the arpanet and listed in the hosts.txt ﬁle. in 1984, the .gov, .edu, .com, .mil and .org generic top-level domain names were added and rfc 1032 proposed the utilisation of the two letter iso-3166 country codes as top-level domain names. since iso-3166 deﬁnes a two letter code for each country recognised by the united nations, this allowed all countries to automatically have a top-level domain. these domains include .be for belgium, .fr for france, .us for the usa, .ie for ireland or .tv for tuvalu, a group of small islands in the paciﬁc and .tm for turkmenistan. today, the set of top-level domain-names is managed by the internet corporation for assigned names and numbers (icann). recently, icann added a dozen of generic top-level domains that are not related to a country and the .cat top-level domain has been registered for the catalan language. there are ongoing discussions within icann to increase the number of top-level domains.
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
the reply code indicates whether the command was successful or not. a reply code of 2xy indicates that the command has been accepted. a reply code of 3xy indicates that the command has been accepted, but additional information from the client is expected. a reply code of 4xy indicates a transient negative reply. this means that for some reason, which is indicated by either the other digits or the comment, the command cannot be processed immediately, but there is some hope that the problem will only be transient. this is basically telling the client to try the same command again later. in contrast, a reply code of 5xy indicates a permanent failure or error. in this case, it is useless for the client to retry the same command later. other application layer protocols such as ftp rfc 959 or http rfc 2616 use a similar structure for their reply codes. additional details about the other reply codes may be found in rfc 5321. examples of smtp reply codes include the following :
syntax error, command unrecognized syntax error in parameters or arguments command not implemented bad sequence of commands <domain> service ready <domain> service closing transmission channel <domain> service not available, closing transmission channel requested mail action okay, completed requested mail action not taken: mailbox unavailable requested action not taken: insufficient system storage requested action not taken: mailbox unavailable start mail input; end with <crlf>.<crlf>
the ﬁrst four reply codes correspond to errors in the commands sent by the client. the fourth reply code would be sent by the server when the client sends commands in an incorrect order (e.g. the client tries to send an email before providing the destination address of the message). reply code 220 is used by the server as the ﬁrst message when it agrees to interact with the client. reply code 221 is sent by the server before closing the underlying transport connection. reply code 421 is returned when there is a problem (e.g. lack of memory/disk resources) that prevents the server from accepting the transport connection. reply code 250 is the standard positive reply that indicates the success of the previous command. reply codes 450 and 452 indicate that the destination mailbox is temporarily unavailable, for various reasons, while reply code 550 indicates that the mailbox does not exist or cannot be used for policy reasons. reply code 354 indicates that the client can start transmitting its email message. the transfer of an email message is performed in three phases. during the ﬁrst phase, the client opens a transport connection with the server. once the connection has been established, the client and the server exchange greetings messages (ehlo command). most servers insist on receiving valid greeting messages and some of them drop the underlying transport connection if they do not receive a valid greeting. once the greetings have been exchanged, the email transfer phase can start. during this phase, the client transfers one or more email messages by indicating the email address of the sender (mail from: command), the email address of the recipient (rcpt to: command) followed by the headers and the body of the email message (data command). once the client has ﬁnished sending all its queued email messages to the smtp server, it terminates the smtp association (quit command). a successful transfer of an email message is shown below
s: 220 smtp.example.com esmtp mta information c: ehlo mta.example.org s: 250 hello mta.example.org, glad to meet you c: mail from:<alice@example.org> s: 250 ok c: rcpt to:<bob@example.com> s: 250 ok c: data s: 354 end data with <cr><lf>.<cr><lf> c: from: "alice doe" <alice@example.org> c: to: bob smith <bob@example.com> c: date: mon, 9 mar 2010 18:22:32 +0100 c: subject: hello c: c: hello bob c: this is a small message containing 4 lines of text. c: best regards,
assumes that all the messages of a given user are stored on a server and provides the functions that are necessary to search, download, delete or ﬁlter messages. pop is another example of a simple line-based protocol. pop runs above the bytestream service. a pop server usually listens to port 110. a pop session is composed of three parts : an authorisation phase during which the server veriﬁes the client’s credential, a transaction phase during which the client downloads messages and an update phase that concludes the session. the client sends commands and the server replies are preﬁxed by +ok to indicate a successful command or by -err to indicate errors. when a client opens a transport connection with the pop server, the latter sends as banner an ascii-line starting with +ok. the pop session is at that time in the authorisation phase. in this phase, the client can send its username (resp. password) with the user (resp. pass) command. the server replies with +ok if the username (resp. password) is valid and -err otherwise. once the username and password have been validated, the pop session enters in the transaction phase. in this phase, the client can issue several commands. the stat command is used to retrieve the status of the server. upon reception of this command, the server replies with a line that contains +ok followed by the number of messages in the mailbox and the total size of the mailbox in bytes. the retr command, followed by a space and an integer, is used to retrieve the nth message of the mailbox. the dele command is used to mark for deletion the nth message of the mailbox. once the client has retrieved and possibly deleted the emails contained in the mailbox, it must issue the quit command. this command terminates the pop session and allows the server to delete all the messages that have been marked for deletion by using the dele command. the ﬁgure below provides a simple pop session. all lines preﬁxed with c: (resp. s:) are sent by the client (resp. server).
+ok pop3 server ready user alice +ok pass 12345pass +ok alice’s maildrop has 2 messages (620 octets) stat +ok 2 620 list +ok 2 messages (620 octets) 1 120 2 500 . retr 1 +ok 120 octets <the pop3 server sends message 1> . dele 1 +ok message 1 deleted quit +ok pop3 server signing off (1 message left)
in this example, a pop client contacts a pop server on behalf of the user named alice. note that in this example, alice’s password is sent in clear by the client. this implies that if someone is able to capture the packets sent by alice, he will know alice’s password 16. then alice’s client issues the stat command to know the number of messages that are stored in her mailbox. it then retrieves and deletes the ﬁrst message of the mailbox.
in the early days of the internet was mainly used for remote terminal access with telnet, email and ﬁle transfer. the default ﬁle transfer protocol, ftp, deﬁned in rfc 959 was widely used and ftp clients and servers are still included in most operating systems.
• the source address of the packet (s) is replaced by the mapped public address (p1) • the checksum of the ip header is incrementally updated as its content has changed • if the packet carried a tcp or udp segment, the transport layer checksum found in the included segment must also be updated as it is computed over the segment and a pseudo-header that includes the source and destination addresses
when a packet destined to p1 is received from the public internet, the nat consults its mapping table to ﬁnd s. the received packet is translated and forwarded in the internal network. this works as long as the pool of public ip addresses of the nat does not become empty. in this case, a mapping must be removed from the mapping table to allow a packet from a new host to be translated. this garbage collection can be implemented by adding to each entry in the mapping table a timestamp that contains the last utilisation time of a mapping entry. this timestamp is updated each time the corresponding entry is used. then, the garbage collection algorithm can remove the oldest mapping entry in the table. a drawback of such a simple enterprise nat is the size of the pool of public ipv4 addresses which is often too small to allow a large number of hosts share such a nat. in this case, a better solution is to allow the nat to translate both ip addresses and port numbers. such a nat maintains a mapping table that maps an internal ip address and tcp port number with an external ip address and tcp port number. when such a nat receives a packet from the internal network, it performs a lookup in the mapping table with the packet’s source ip address and source tcp port number. if a mapping is found, the source ip address and the source tcp port number of the packet are translated with the values found in the mapping table, the checksums are updated and the packet is sent to the global internet. if no mapping is found, a new mapping is created with the ﬁrst available couple (ip address, tcp port number) and the packet is translated. the entries of the mapping table are either removed at the end of the corresponding tcp connection as the nat tracks tcp connection state like a stateful ﬁrewall or after some idle time. when such a nat receives a packet from the global internet, it looks up its mapping table for the packet’s destination ip address and destination tcp port number. if a mapping is found, the packet is translated and forwarded into the internal network. otherwise, the packet is discarded as the nat cannot determine to which particular internal host the packet should be forwarded. for this reason, with 216 different port numbers, a nat may support a large number of hosts with a single public ipv4 address. however, it should be noted that some applications open a large number of tcp connections [miyakawa2008]. each of these tcp connections consumes one mapping entry in the nat’s mapping table. nat allows many hosts to share one or a few public ipv4 addresses. however, using nat has two important drawbacks. first, it is difﬁcult for external hosts to open tcp connections with hosts that are behind a nat. some consider this to be a beneﬁt from a security perspective. however, a nat should not be confused with a ﬁrewall as there are some techniques to traverse nats. second, nat breaks the end-to-end transparency of the network and transport layers. the main problem is when an application layer protocol uses ip addresses in some of the adus that it sends. a popular example is ftp deﬁned in rfc 959. in this case, there is a mismatch between the packet header translated by the nat and the packet payload. the only solution to solve this problem is to place an application level gateway (alg) on the nat that understands the application layer protocol and can thus translate the ip addresses and port numbers found in the adus. however, deﬁning an alg for each application is costly and application developers should avoid using ip addresses in the messages exchanged in the application layer rfc 3235.
note: ipv6 and nat nat has been very successful with ipv4. given the size of the ipv6 addressing space, the ipv6 designers expected that nat would never be useful with ipv6. the end-to-end transparency of ipv6 has been one of its key selling points compared to ipv4. however, the expected shortage of ipv4 addresses lead enterprise network administrators to consider ipv6 more seriously. one of the results of this analysis is that the ietf deﬁned nat devices [wb2008] that are ipv6 speciﬁc. another usage of nat with ipv6 is to allow ipv6 hosts to access ipv4 destinations and conversely. the early ipv6 speciﬁcations included the network address translation - protocol translation (natpt) mechanism deﬁned in rfc 2766. this mechanism was later deprecated in rfc 4966 but has been recently restarted under the name nat64 [bmvb2009]. a nat64 is a middlebox that performs the ipv6<->ipv4 packet translation to allow ipv6 hosts to contact ipv4 servers rfc 6144.
egp exterior gateway protocol. synonym of interdomain routing protocol eigrp the enhanced interior gateway routing protocol (eigrp) is a proprietary intradomain routing protocol
frame a frame is the unit of information transfer in the datalink layer frame-relay a wide area networking technology using virtual circuits that is deployed by telecom operators. ftp the file transfer protocol deﬁned in rfc 959 has been the de facto protocol to exchange ﬁles over the
ftp the file transfer protocol is deﬁned in rfc 959 hosts.txt a ﬁle that initially contained the list of all internet hosts with their ipv4 address. as the network grew, this ﬁle was replaced by the dns, but each host still maintains a small hosts.txt ﬁle that can be used when dns is not available.
http the hypertext transport protocol is deﬁned in rfc 2616 hub a relay operating in the physical layer. iana the internet assigned numbers authority (iana) is responsible for the coordination of the dns root,
icann the internet corporation for assigned names and numbers (icann) coordinates the allocation of domain names, ip addresses and as numbers as well protocol parameters. it also coordinates the operation and the evolution of the dns root name servers.
ietf the internet engineering task force is a non-proﬁt organisation that develops the standards for the protocols used in the internet. the ietf mainly covers the transport and network layers. several application layer protocols are also standardised within the ietf. the work in the ietf is organised in working groups. most of the work is performed by exchanging emails and there are three ietf meetings every year. participation is open to anyone. see http://www.ietf.org
igp interior gateway protocol. synonym of intradomain routing protocol igrp the interior gateway routing protocol (igrp) is a proprietary intradomain routing protocol that uses
imap the internet message access protocol is deﬁned in rfc 3501 imap the internet message access protocol (imap), deﬁned in rfc 3501, is an application-level protocol that allows a client to access and manipulate the emails stored on a server. with imap, the email messages remain on the server and are not downloaded on the client.
internet a public internet, i.e. a network composed of different networks that are running ipv4 or ipv6 internet an internet is an internetwork, i.e. a network composed of different networks. the internet is a very
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
5. when run without any parameter, dig queries one of the root dns servers and retrieves the list of the the names of all root dns servers. for technical reasons, there are only 13 different root dns servers. this information is also available as a text ﬁle from http://www.internic.net/zones/named.root what are the ip addresses of all these servers. can they be queried by using ipv6 23 ?
7. perform the same analysis for a popular website such as www.google.com. what is the lifetime associated to this ip address ? if you perform the same request several times, do you always receive the same answer ? can you explain why a lifetime is associated to the dns replies ?
8. use dig to ﬁnd the mail relays used by the uclouvain.be and gmail.com domains. what is the ttl of these records (use the +ttlid option when using dig) ? can you explain the preferences used by the mx records. you can ﬁnd more information about the mx records in rfc 974
11. a dns implementation such as dig and more importantly a name resolver such as bind or unbound, always checks that the received dns reply contains the same identiﬁer as the dns request that it sent. why is this so important ?
– sends dns requests containing always the same identiﬁer – sends dns requests containing identiﬁers that are incremented by one after each request – sends dns requests containing random identiﬁers
[moy1998] moy, j., ospf: anatomy of an internet routing protocol, addison wesley, 1998 [myers1998] myers, b. a., a brief history of human-computer interaction technology. interactions 5, 2 (mar.
[nelson1965] nelson, t. h., complex information processing: a ﬁle structure for the complex, the changing and the indeterminate. in proceedings of the 1965 20th national conference (cleveland, ohio, united states, august 24 - 26, 1965). l. winner, ed. acm ‘65. acm, new york, ny, 84-100.
[perlman2004] perlman, r., rbridges: transparent routing, proc. ieee infocom , march 2004. [pouzin1975] pouzin, l., the cyclades network - present state and development trends, symposium on
[rago1993] rago, s., unix system v network programming, addison wesley, 1993 [re1989] rochlis, j. a. and eichin, m. w., with microscope and tweezers: the worm from mit’s perspective.
[rfc20] cerf, v., ascii format for network interchange, rfc 20, oct. 1969 [rfc768] postel, j., user datagram protocol, rfc 768, aug. 1980 [rfc789] rosen, e., vulnerabilities of network control protocols: an example, rfc 789, july 1981 [rfc791] postel, j., internet protocol, rfc 791, sep. 1981 [rfc792] postel, j., internet control message protocol, rfc 792, sep. 1981 [rfc793] postel, j., transmission control protocol, rfc 793, sept. 1981 [rfc813] clark, d., window and acknowledgement strategy in tcp, rfc 813, july 1982 [rfc819] su, z. and postel, j., domain naming convention for internet user applications, rfc 819, aug. 1982 [rfc821] postel, j., simple mail transfer protocol, rfc 821, aug. 1982 [rfc822] crocker, d., standard for the format of arpa internet text messages, :rfc:‘822, aug. 1982 [rfc826] plummer, d., ‘‘ethernet address resolution protocol: or converting network protocol addresses to
48.bit ethernet address for transmission on ethernet hardware‘, rfc 826, nov. 1982 [rfc879] postel, j., tcp maximum segment size and related topics, rfc 879, nov. 1983 [rfc893] lefﬂer, s. and karels, m., trailer encapsulations, rfc 893, april 1984 [rfc894] hornig, c., a standard for the transmission of ip datagrams over ethernet networks, rfc 894, april
[rfc896] nagle, j., congestion control in ip/tcp internetworks, rfc 896, jan. 1984 [rfc952] harrenstien, k. and stahl, m. and feinler, e., dod internet host table speciﬁcation, rfc 952, oct.
[rfc959] postel, j. and reynolds, j., file transfer protocol, rfc 959, oct. 1985 [rfc974] partridge, c., mail routing and the domain system, rfc 974, jan. 1986 [rfc1032] stahl, m., domain administrators guide, rfc 1032, nov. 1987 [rfc1035] mockapteris, p., domain names - implementation and speciﬁcation, rfc 1035, nov. 1987 [rfc1042] postel, j. and reynolds, j., standard for the transmission of ip datagrams over ieee 802 networks,
an acknowledgement once its sending buffer is full. when a go-back-n sender receives an acknowledgement, it removes from the sending buffer all the acknowledged segments and uses a retransmission timer to detect segment losses. a simple go-back-n sender maintains one retransmission timer per connection. this timer is started when the ﬁrst segment is sent. when the go-back-n sender receives an acknowledgement, it restarts the retransmission timer only if there are still unacknowledged segments in its sending buffer. when the retransmission timer expires, the go-back-n sender assumes that all the unacknowledged segments currently stored in its sending buffer have been lost. it thus retransmits all the unacknowledged segments in the buffer and restarts its retransmission timer.
the operation of go-back-n is illustrated in the ﬁgure below. in this ﬁgure, note that upon reception of the outof-sequence segment d(2,c), the receiver returns a cumulative acknowledgement c(ok,0) that acknowledges all the segments that have been received in sequence. the lost segment is retransmitted upon the expiration of the retransmission timer.
the main advantage of go-back-n is that it can be easily implemented, and it can also provide good performance when only a few segments are lost. however, when there are many losses, the performance of go-back-n quickly drops for two reasons :
• the go-back-n receiver does not accept out-of-sequence segments • the go-back-n sender retransmits all unacknowledged segments once its has detected a loss
selective repeat is a better strategy to recover from segment losses. intuitively, selective repeat allows the receiver to accept out-of-sequence segments. furthermore, when a selective repeat sender detects losses, it only retransmits the segments that have been lost and not the segments that have already been correctly received.
all corruptedsegments arediscarded in all statesall corruptedsegments arediscarded in all statesrecvd(c(ok,t,crc)) and crcok(c(ok,t,crc))remove acked seqs from buffer;unpack = (t+1) % maxseq;if (unpack==seq) { cancel_timer(); } else{ restart_timer(); }timer expires for all (i, sdu) in buffer{ send(d(i,sdu,crc)); }restart_timer();data.req(sdu) size(buffer) < w if (seq==unack) { start_timer ; }insert_in_buffer(seq, sdu);send(d(seq,sdu,crc));seq=(seq+1) % maxseq;saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
the data segment that has not been acknowledged. unfortunately, as illustrated in the ﬁgure below, the receiver considers the retransmission as a new segment whose payload must be delivered to its user.
to solve this problem, transport protocols associate a sequence number to each data segment. this sequence number is one of the ﬁelds found in the header of data segments. we use the notation d(s,...) to indicate a data segment whose sequence number ﬁeld is set to s. the acknowledgements also contain a sequence number indicating the data segments that it is acknowledging. we use oks to indicate an acknowledgement segment that conﬁrms the reception of d(s,...). the sequence number is encoded as a bit string of ﬁxed length. the simplest transport protocol is the alternating bit protocol (abp). the alternating bit protocol uses a single bit to encode the sequence number. it can be implemented easily. the sender and the receivers only require a four states finite state machine.
d(a)abdata.req(a)data.ind(a)data.req(b)c(ok)d(b)data.ind(b)c(ok)d(b)start timertimer expireslost segmentstart timercancel timerd(a)abdata.req(a)data.ind(a)data.req(b)c(ok)d(b)data.ind(b) !!!!!!c(ok)d(b)start timertimer expireslost segmentstart timercancel timerc(ok)data.ind(b)saylor url: http://www.saylor.org/courses/cs402/the saylor foundation
must forward the entire delimiter to its downstream neighbour. it is only when it receives the fourth bit of the access control ﬁeld (i.e. the token bit) that the station knows whether the frame is a data frame or a token. if the token bit is reset, it indicates a data frame and the remaining bits of the data frame must be forwarded to the downstream station. otherwise (token bit is set), this is a token and the station can capture it by resetting the bit that is currently in its buffer. thanks to this modiﬁcation, the beginning of the token is now the beginning of a data frame and the station can switch to transmit mode and send its data frame starting at the ﬁfth bit of the access control ﬁeld. thus, the one-bit delay introduced by each token ring station plays a key role in enabling the stations to efﬁciently capture the token. after having transmitted its data frame, the station must remain in transmit mode until it has received the last bit of its own data frame. this ensures that the bits sent by a station do not remain in the network forever. a data frame sent by a station in a token ring network passes in front of all stations attached to the network. each station can detect the data frame and analyse the destination address to possibly capture the frame. the frame status ﬁeld that appears after the ending delimiter is used to provide acknowledgements without requiring special frames. the frame status contains two ﬂags : a and c. both ﬂags are reset when a station sends a data frame. these ﬂags can be modiﬁed by their recipients. when a station senses its address as the destination address of a frame, it can capture the frame, check its crc and place it in its own buffers. the destination of a frame must set the a bit (resp. c bit) of the frame status ﬁeld once it has seen (resp. copied) a data frame. by inspecting the frame status of the returning frame, the sender can verify whether its frame has been received correctly by its destination. the text above describes the basic operation of a token ring network when all stations work correctly. unfortunately, a real token ring network must be able to handle various types of anomalies and this increases the complexity of token ring stations. we brieﬂy list the problems and outline their solutions below. a detailed description of the operation of token ring stations may be found in [802.5]. the ﬁrst problem is when all the stations attached to the network start. one of them must bootstrap the network by sending the ﬁrst token. for this, all stations implement a distributed election mechanism that is used to select the monitor. any station can become a monitor. the monitor manages the token ring network and ensures that it operates correctly. its ﬁrst role is to introduce a delay of 24 bit transmission times to ensure that the token can travel smoothly on the ring. second, the monitor sends the ﬁrst token on the ring. it must also verify that the token passes regularly. according to the token ring standard [802.5], a station cannot retain the token to transmit data frames for a duration longer than the token holding time (tht) (slightly less than 10 milliseconds). on a network containing n stations, the monitor must receive the token at least every n × t ht seconds. if the monitor does not receive a token during such a period, it cuts the ring for some time and then reinitialises the ring and sends a token. several other anomalies may occur in a token ring network. for example, a station could capture a token and be powered off before having resent the token. another station could have captured the token, sent its data frame and be powered off before receiving all of its data frame. in this case, the bit string corresponding to the end of a frame would remain in the ring without being removed by its sender. several techniques are deﬁned in [802.5] to allow the monitor to handle all these problems. if unfortunately, the monitor fails, another station will be elected to become the new monitor.
in this section, we review the key characteristics of several datalink layer technologies. we discuss in more detail the technologies that are widely used today. a detailed survey of all datalink layer technologies would be outside the scope of this book.
many point-to-point datalink layers 2 have been developed, starting in the 1960s [mcfadyen1976]. in this section, we focus on the protocols that are often used to transport ip packets between hosts or routers that are directly connected by a point-to-point link. this link can be a dedicated physical cable, a leased line through the telephone network or a dial-up connection with modems on the two communicating hosts.
the last transmission mode is the anycast transmission mode. in this transmission mode, a set of receivers is identiﬁed. when a source sends information towards this set of receivers, the network ensures that the information is delivered to one receiver that belongs to this set. usually, the receiver closest to the source is the one that receives the information sent by this particular source. the anycast transmission mode is useful to ensure redundancy, as when one of the receivers fails, the network will ensure that information will be delivered to another receiver belonging to the same group. however, in practice supporting the anycast transmission mode can be difﬁcult.
in the example above, the three hosts marked with * are part of the same anycast group. when host s sends information to this anycast group, the network ensures that it will reach one of the members of the anycast group. the dashed lines show a possible delivery via nodes 1, 2 and 4. a subsequent anycast transmission from host s to the same anycast group could reach the host attached to intermediate node 3 as shown by the plain line. an anycast transmission reaches a member of the anycast group that is chosen by the network in function of the current network conditions.
an important aspect to understand before studying computer networks is the difference between a service and a protocol. in order to understand the difference between the two, it is useful to start with real world examples. the traditional post provides a service where a postman delivers letters to recipients. the post deﬁnes precisely which types of letters (size, weight, etc) can be delivered by using the standard mail service. furthermore, the format of the envelope is speciﬁed (position of the sender and recipient addresses, position of the stamp). someone who wants to send a letter must either place the letter at a post ofﬁce or inside one of the dedicated mailboxes. the letter will then be collected and delivered to its ﬁnal recipient. note that for the regular service the post usually does not guarantee the delivery of each particular letter, some letters may be lost, and some letters are delivered to the wrong mailbox. if a letter is important, then the sender can use the registered service to ensure that the letter will be delivered to its recipient. some post services also provide an acknowledged service or an express mail service that is faster than the regular service. in computer networks, the notion of service is more formally deﬁned in [x200] . it can be better understood by considering a computer network, whatever its size or complexity, as a black box that provides a service to users , as shown in the ﬁgure below. these users could be human users or processes running on a computer system. many users can be attached to the same service provider. through this provider, each user must be able to exchange messages with any other user. to be able to deliver these messages, the service provider must be able to unambiguously identify each user. in computer networks, each user is identiﬁed by a unique address, we will discuss later how these addresses are built and used. at this point, and when considering unicast transmission, the main characteristic of these addresses is that they are unique. two different users attached to the network cannot use the same address.
throughout this book, we will deﬁne a service as a set of capabilities provided by a system (and its underlying elements) to its user. a user interacts with a service through a service access point. note that as shown in the ﬁgure above, users interact with one service provider. in practice, the service provider is distributed over several hosts, but these are implementation details that are not important at this stage. these interactions between a user and a service provider are expressed in [x200] by using primitives, as show in the ﬁgure below. these primitives are an abstract representation of the interactions between a user and a service provider. in practice, these interactions could be implemented as system calls for example.
• x.request. this type of primitive corresponds to a request issued by a user to a service provider • x.indication. this type of primitive is generated by the network provider and delivered to a user (often
• x.response. this type of primitive is generated by a user to answer to an earlier x.indication primitive • x.conﬁrm. this type of primitive is delivered by the service provide to conﬁrm to a user that a previous
primitives can be combined to model different types of services. the simplest service in computer networks is called the connectionless service 3. this service can be modelled by using two primitives :
• data.request(source,destination,sdu). this primitive is issued by a user that speciﬁes, as parameters, its (source) address, the address of the recipient of the message and the message itself. we will use service data unit (sdu) to name the message that is exchanged transparently between two users of a service. • data.indication(source,destination,sdu). this primitive is delivered by a service provider to a user.
it contains as parameters a service data unit as well as the addresses of the sender and the destination users. when discussing the service provided in a computer network, it is often useful to be able to describe the interactions between the users and the provider graphically. a frequently used representation is the time-sequence diagram. in this chapter and later throughout the book, we will often use diagrams such as the ﬁgure below. a time-sequence diagram describes the interactions between two users and a service provider. by convention, the users are represented in the left and right parts of the diagram while the service provider occupies the middle of the diagram. in such a time-sequence diagram, time ﬂows from the top, to the bottom of the diagram. each primitive
user auser bservice provider ("the network")service access pointprimitivesuser auser bservice provider ("the network")x.indicationx.responsex.confirmx.requestsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
throughout this book, we will deﬁne a service as a set of capabilities provided by a system (and its underlying elements) to its user. a user interacts with a service through a service access point. note that as shown in the ﬁgure above, users interact with one service provider. in practice, the service provider is distributed over several hosts, but these are implementation details that are not important at this stage. these interactions between a user and a service provider are expressed in [x200] by using primitives, as show in the ﬁgure below. these primitives are an abstract representation of the interactions between a user and a service provider. in practice, these interactions could be implemented as system calls for example.
• x.request. this type of primitive corresponds to a request issued by a user to a service provider • x.indication. this type of primitive is generated by the network provider and delivered to a user (often
• x.response. this type of primitive is generated by a user to answer to an earlier x.indication primitive • x.conﬁrm. this type of primitive is delivered by the service provide to conﬁrm to a user that a previous
primitives can be combined to model different types of services. the simplest service in computer networks is called the connectionless service 3. this service can be modelled by using two primitives :
• data.request(source,destination,sdu). this primitive is issued by a user that speciﬁes, as parameters, its (source) address, the address of the recipient of the message and the message itself. we will use service data unit (sdu) to name the message that is exchanged transparently between two users of a service. • data.indication(source,destination,sdu). this primitive is delivered by a service provider to a user.
it contains as parameters a service data unit as well as the addresses of the sender and the destination users. when discussing the service provided in a computer network, it is often useful to be able to describe the interactions between the users and the provider graphically. a frequently used representation is the time-sequence diagram. in this chapter and later throughout the book, we will often use diagrams such as the ﬁgure below. a time-sequence diagram describes the interactions between two users and a service provider. by convention, the users are represented in the left and right parts of the diagram while the service provider occupies the middle of the diagram. in such a time-sequence diagram, time ﬂows from the top, to the bottom of the diagram. each primitive
user auser bservice provider ("the network")service access pointprimitivesuser auser bservice provider ("the network")x.indicationx.responsex.confirmx.requestsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
ﬁeld of the rts frame indicates the duration of the entire reservation (i.e. the time required to transmit the cts, the data frame, the acknowledgements and the required sifs delays). the cts frame has the same format as the acknowledgement frame.
note: the 802.11 service despite the utilization of acknowledgements, the 802.11 layer only provides an unreliable connectionless service like ethernet networks that do not use acknowledgements. the 802.11 acknowledgements are used to minimize the probability of frame duplication. they do not guarantee that all frames will be correctly received by their recipients. like ethernet, 802.11 networks provide a high probability of successful delivery of the frames, not a guarantee. furthermore, it should be noted that 802.11 networks do not use acknowledgements for multicast and broadcast frames. this implies that in practice such frames are more likely to suffer from transmission errors than unicast frames.
in addition to the data and control frames that we have brieﬂy described above, 802.11 networks use several types of management frames. these management frames are used for various purposes. we brieﬂy describe some of these frames below. a detailed discussion may be found in [802.11] and [gast2002]. a ﬁrst type of management frames are the beacon frames. these frames are broadcasted regularly by access points. each beacon frame contains information about the capabilities of the access point (e.g. the supported 802.11 transmission rates) and a service set identity (ssid). the ssid is a null-terminated ascii string that can contain up to 32 characters. an access point may support several ssids and announce them in beacon frames. an access point may also choose to remain silent and not advertise beacon frames. in this case, wifi stations may send probe request frames to force the available access points to return a probe response frame.
note: ip over 802.11 two types of encapsulation schemes were deﬁned to support ip in ethernet networks : the original encapsulation scheme, built above the ethernet dix format is deﬁned in rfc 894 and a second encapsulation rfc 1042 scheme, built above the llc/snap protocol [802.2]. in 802.11 networks, the situation is simpler and only the rfc 1042 encapsulation is used. in practice, this encapsulation adds 6 bytes to the 802.11 header. the ﬁrst four bytes correspond to the llc/snap header. they are followed by the two bytes ethernet type ﬁeld (0x800 for ip and 0x806 for arp). the ﬁgure below shows an ip packet encapsulated in an 802.11 frame.
the second important utilisation of the management frames is to allow a wifi station to be associated with an access point. when a wifi station starts, it listens to beacon frames to ﬁnd the available ssids. to be allowed to
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
slot time is the optimal delay since it is the shortest delay that ensures that the ﬁrst host will be able to retransmit its frame completely without any collision. if two hosts are competing, the algorithm above will avoid a second collision 50% of the time. however, if the network is heavily loaded, several hosts may be competing at the same time. in this case, the hosts should be able to automatically adapt their retransmission delay. the binary exponential back-off performs this adaptation based on the number of collisions that have affected a frame. after the ﬁrst collision, the host ﬂips a coin and waits 0 or 1 slot time. after the second collision, it generates a random number and waits 0, 1, 2 or 3 slot times, etc. the duration of the waiting time is doubled after each collision. the complete pseudo-code for the csma/cd algorithm is shown in the ﬁgure below.
the inter-frame delay used in this pseudo-code is a short delay corresponding to the time required by a network adapter to switch from transmit to receive mode. it is also used to prevent a host from sending a continuous stream of frames without leaving any transmission opportunities for other hosts on the network. this contributes to the fairness of csma/cd. despite this delay, there are still conditions where csma/cd is not completely fair [ry1994]. consider for example a network with two hosts : a server sending long frames and a client sending acknowledgments. measurements reported in [ry1994] have shown that there are situations where the client could suffer from repeated collisions that lead it to wait for long periods of time due to the exponential back-off algorithm.
the carrier sense multiple access with collision avoidance (csma/ca) medium access control algorithm was designed for the popular wifi wireless network technology [802.11]. csma/ca also senses the transmission channel before transmitting a frame. furthermore, csma/ca tries to avoid collisions by carefully tuning the timers used by csma/ca devices. csma/ca uses acknowledgements like csma. each frame contains a sequence number and a crc. the crc is used to detect transmission errors while the sequence number is used to avoid frame duplication. when a device receives a correct frame, it returns a special acknowledgement frame to the sender. csma/ca introduces a small delay, named short inter frame spacing (sifs), between the reception of a frame and the transmission of the acknowledgement frame. this delay corresponds to the time that is required to switch the radio of a device between the reception and transmission modes. compared to csma, csma/ca deﬁnes more precisely when a device is allowed to send a frame. first, csma/ca deﬁnes two delays : difs and eifs. to send a frame, a device must ﬁrst wait until the channel has been idle for at least the distributed coordination function inter frame space (difs) if the previous frame was received correctly. however, if the previously received frame was corrupted, this indicates that there are collisions and the device must sense the channel idle for at least the extended inter frame space (eifs), with sif s < dif s < eif s. the exact values for sifs, difs and eifs depend on the underlying physical layer [802.11].
coming back to the ﬁgure above, as4 advertises to its two providers as1 and as2 its own routes and the routes learned from its customer, as7. on the other hand, as4 advertises to as7 all the routes that it knows. the second type of peering relationship is the shared-cost peering relationship. such a relationship usually does not involve a payment from one domain to the other in contrast with the customer->provider relationship. a shared-cost peering relationship is usually established between domains having a similar size and geographic coverage. for example, consider the ﬁgure above. if as3 and as4 exchange many packets via as1, they both need to pay as1. a cheaper alternative for as3 and as4 would be to establish a shared-cost peering. such a peering can be established at ixps where both as3 and as4 are present or by using private peering links. this shared-cost peering should be used to exchange packets between hosts inside as3 and hosts inside as4. however, as3 does not want to receive on the as3-as4 shared-cost peering links packets whose destination belongs to as1 as as3 would have to pay to send these packets to as1. from a routing perspective, over a shared-cost peering relationship a domain only advertises its internal routes and the routes that it has learned from its customers. this restriction ensures that only packets destined to the local domain or one of its customers is received over the shared-cost peering relationship. this implies that the routes that have been learned from a provider or from another shared-cost peer is not advertised over a shared-cost peering relationship. this is motivated by economical reasons. if a domain were to advertise the routes that it learned from a provider over a shared-cost peering relationship that does not bring revenue, it would have allowed its shared-cost peer to use the link with its provider without any payment. if a domain were to advertise the routes it learned over a shared cost peering over another shared-cost peering relationship, it would have allowed these shared-cost peers to use its own network (which may span one or more continents) freely to exchange packets. finally, the last type of peering relationship is the sibling. such a relationship is used when two domains exchange all their routes in both directions. in practice, such a relationship is only used between domains that belong to the same company. these different types of relationships are implemented in the interdomain routing policies deﬁned by each domain. the interdomain routing policy of a domain is composed of three main parts :
• the import ﬁlter that speciﬁes, for each peering relationship, the routes that can be accepted from the neighbouring domain (the non-acceptable routes are ignored and the domain never uses them to forward packets) • the export ﬁlter that speciﬁes, for each peering relationship, the routes that can be advertised to the neigh-
a domain’s import and export ﬁlters can be deﬁned by using the route policy speciﬁcation language (rpsl) speciﬁed in rfc 2622 [gave1999] . some internet service providers, notably in europe, use rpsl to document 29 their import and export policies. several tools help to easily convert a rpsl policy into router commands. the ﬁgure below provides a simple example of import and export ﬁlters for two domains in a simple internetwork. in rpsl, the keyword any is used to replace any route from any domain. it is typically used by a provider to indicate that it announces all its routes to a customer over a provider->customer relationship. this is the case for as4‘s export policy. the example below clearly shows the difference between a provider->customer and a shared-cost peering relationship. as4‘s export ﬁlter indicates that it announces only its internal routes (as4) and the routes learned from its clients (as7) over its shared-cost peering with as3, while it advertises all the routes that it uses (including the routes learned from as3) to as7.
the internet uses a single interdomain routing protocol : the border gateway protocol (bgp). the current version of bgp is deﬁned in rfc 4271. bgp differs from the intradomain routing protocols that we have already discussed in several ways. first, bgp is a path-vector protocol. when a bgp router advertises a route towards a preﬁx, it announces the ip preﬁx and the interdomain path used to reach this preﬁx. from bgp’s point of view, each domain is identiﬁed by a unique autonomous system (as) number 30 and the interdomain path contains the as numbers of the transit domains that are used to reach the associated preﬁx. this interdomain path is called the
29 see ftp://ftp.ripe.net/ripe/dbase for the ripe database that contains the import and export policies of many european isps 30 in this text, we consider autonomous system and domain as synonyms. in practice, a domain may be divided into several autonomous
slot time is the optimal delay since it is the shortest delay that ensures that the ﬁrst host will be able to retransmit its frame completely without any collision. if two hosts are competing, the algorithm above will avoid a second collision 50% of the time. however, if the network is heavily loaded, several hosts may be competing at the same time. in this case, the hosts should be able to automatically adapt their retransmission delay. the binary exponential back-off performs this adaptation based on the number of collisions that have affected a frame. after the ﬁrst collision, the host ﬂips a coin and waits 0 or 1 slot time. after the second collision, it generates a random number and waits 0, 1, 2 or 3 slot times, etc. the duration of the waiting time is doubled after each collision. the complete pseudo-code for the csma/cd algorithm is shown in the ﬁgure below.
the inter-frame delay used in this pseudo-code is a short delay corresponding to the time required by a network adapter to switch from transmit to receive mode. it is also used to prevent a host from sending a continuous stream of frames without leaving any transmission opportunities for other hosts on the network. this contributes to the fairness of csma/cd. despite this delay, there are still conditions where csma/cd is not completely fair [ry1994]. consider for example a network with two hosts : a server sending long frames and a client sending acknowledgments. measurements reported in [ry1994] have shown that there are situations where the client could suffer from repeated collisions that lead it to wait for long periods of time due to the exponential back-off algorithm.
the carrier sense multiple access with collision avoidance (csma/ca) medium access control algorithm was designed for the popular wifi wireless network technology [802.11]. csma/ca also senses the transmission channel before transmitting a frame. furthermore, csma/ca tries to avoid collisions by carefully tuning the timers used by csma/ca devices. csma/ca uses acknowledgements like csma. each frame contains a sequence number and a crc. the crc is used to detect transmission errors while the sequence number is used to avoid frame duplication. when a device receives a correct frame, it returns a special acknowledgement frame to the sender. csma/ca introduces a small delay, named short inter frame spacing (sifs), between the reception of a frame and the transmission of the acknowledgement frame. this delay corresponds to the time that is required to switch the radio of a device between the reception and transmission modes. compared to csma, csma/ca deﬁnes more precisely when a device is allowed to send a frame. first, csma/ca deﬁnes two delays : difs and eifs. to send a frame, a device must ﬁrst wait until the channel has been idle for at least the distributed coordination function inter frame space (difs) if the previous frame was received correctly. however, if the previously received frame was corrupted, this indicates that there are collisions and the device must sense the channel idle for at least the extended inter frame space (eifs), with sif s < dif s < eif s. the exact values for sifs, difs and eifs depend on the underlying physical layer [802.11].
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
important for short frames. let us consider two hosts, a and b, that are sending a small frame to host c as illustrated in the ﬁgure below. if the frames sent by a and b are very short, the situation illustrated below may occur. hosts a and b send their frame and stop transmitting (point (1)). when the two short frames arrive at the location of host c, they collide and host c cannot decode them (point (2)). the two frames are absorbed by the ends of the wire. neither host a nor host b have detected the collision. they both consider their frame to have been received correctly by its destination.
to solve this problem, networks using csma/cd require hosts to transmit for at least 2 × τ seconds. since the network transmission speed is ﬁxed for a given network technology, this implies that a technology that uses csma/cd enforces a minimum frame size. in the most popular csma/cd technology, ethernet, 2 × τ is called the slot time 1. the last innovation introduced by csma/cd is the computation of the retransmission timeout. as for aloha, this timeout cannot be ﬁxed, otherwise hosts could become synchronised and always retransmit at the same time. setting such a timeout is always a compromise between the network access delay and the amount of collisions. a short timeout would lead to a low network access delay but with a higher risk of collisions. on the other hand, a long timeout would cause a long network access delay but a lower risk of collisions. the binary exponential back-off algorithm was introduced in csma/cd networks to solve this problem. to understand binary exponential back-off, let us consider a collision caused by exactly two hosts. once it has detected the collision, a host can either retransmit its frame immediately or defer its transmission for some time. if each colliding host ﬂips a coin to decide whether to retransmit immediately or to defer its retransmission, four cases are possible :
1. both hosts retransmit immediately and a new collision occurs 2. the ﬁrst host retransmits immediately and the second defers its retransmission 3. the second host retransmits immediately and the ﬁrst defers its retransmission 4. both hosts defer their retransmission and a new collision occurs
in the second and third cases, both hosts have ﬂipped different coins. the delay chosen by the host that defers its retransmission should be long enough to ensure that its retransmission will not collide with the immediate retransmission of the other host. however the delay should not be longer than the time necessary to avoid the collision, because if both hosts decide to defer their transmission, the network will be idle during this delay. the
1 this name should not be confused with the duration of a transmission slot in slotted aloha. in csma/cd networks, the slot time is the time during which a collision can occur at the beginning of the transmission of a frame. in slotted aloha, the duration of a slot is the transmission time of an entire ﬁxed-size frame.
the pseudo-code below shows the operation of an alohanet terminal. we use this python syntax for all medium access control algorithms described in this chapter. the algorithm is applied to each new frame that needs to be transmitted. it attempts to transmit a frame at most max times (while loop). each transmission attempt is performed as follows: first, the frame is sent. each frame is protected by a timeout. then, the terminal waits for either a valid acknowledgement frame or the expiration of its timeout. if the terminal receives an acknowledgement, the frame has been delivered correctly and the algorithm terminates. otherwise, the terminal waits for a random time and attempts to retransmit the frame.
[abramson1970] analysed the performance of alohanet under particular assumptions and found that alohanet worked well when the channel was lightly loaded. in this case, the frames are rarely retransmitted and the channel trafﬁc, i.e. the total number of (correct and retransmitted) frames transmitted per unit of time is close to the channel utilization, i.e. the number of correctly transmitted frames per unit of time. unfortunately, the analysis 2×e = 0.186 times the channel bandwidth. at also reveals that the channel utilization reaches its maximum at higher utilization, alohanet becomes unstable and the network collapses due to collided retransmissions.
note: amateur packet radio packet radio technologies have evolved in various directions since the ﬁrst experiments performed at the university of hawaii. the amateur packet radio service developed by amateur radio operators is one of the descendants alohanet. many amateur radio operators are very interested in new technologies and they often spend countless hours developing new antennas or transceivers. when the ﬁrst personal computers appeared, several amateur radio operators designed radio modems and their own datalink layer protocols [kpd1985] [bnt1997]. this network grew and it was possible to connect to servers in several european countries by only using packet radio relays. some amateur radio operators also developed tcp/ip protocol stacks that were used over the packet radio service. some parts of the amateur packet radio network are connected to the global internet and use the 44.0.0.0/8 preﬁx.
many improvements to alohanet have been proposed since the publication of [abramson1970], and this technique, or some of its variants, are still found in wireless networks today. the slotted technique proposed in [roberts1975] is important because it shows that a simple modiﬁcation can signiﬁcantly improve channel utilization. instead of allowing all terminals to transmit at any time, [roberts1975] proposed to divide time into slots and allow terminals to transmit only at the beginning of each slot. each slot corresponds to the time required to transmit one ﬁxed size frame. in practice, these slots can be imposed by a single clock that is received by all terminals. in alohanet, it could have been located on the central mainframe. the analysis in [roberts1975] reveals that this simple modiﬁcation improves the channel utilization by a factor of two.
aloha and slotted aloha can easily be implemented, but unfortunately, they can only be used in networks that are very lightly loaded. designing a network for a very low utilisation is possible, but it clearly increases the cost of the network. to overcome the problems of aloha, many medium access control mechanisms have been proposed which improve channel utilization. carrier sense multiple access (csma) is a signiﬁcant improvement compared to aloha. csma requires all nodes to listen to the transmission channel to verify that it is free before transmitting a frame [kt1975]. when a node senses the channel to be busy, it defers its transmission until the channel becomes free again. the pseudo-code below provides a more detailed description of the operation of csma.
the ﬁgure below shows the basic operation of csma/ca devices. before transmitting, host a veriﬁes that the channel is empty for a long enough period. then, its sends its data frame. after checking the validity of the received frame, the recipient sends an acknowledgement frame after a short sifs delay. host c, which does not participate in the frame exchange, senses the channel to be busy at the beginning of the data frame. host c can use this information to determine how long the channel will be busy for. note that as sif s < dif s < eif s, even a device that would start to sense the channel immediately after the last bit of the data frame could not decide to transmit its own frame during the transmission of the acknowledgement frame.
the main difﬁculty with csma/ca is when two or more devices transmit at the same time and cause collisions. this is illustrated in the ﬁgure below, assuming a ﬁxed timeout after the transmission of a data frame. with csma/ca, the timeout after the transmission of a data frame is very small, since it corresponds to the sifs plus the time required to transmit the acknowledgement frame.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
the socket api is quite low-level and should be used only when you need a complete control of the network access. if your application simply needs, for instance, to retrieve data with http, there are much simpler and higher-level apis. a detailed discussion of the socket api is outside the scope of this section and the references cited above provide a detailed discussion of all the details of the socket api. as a starting point, it is interesting to compare the socket api with the service primitives that we have discussed in the previous chapter. let us ﬁrst consider the connectionless service that consists of the following two primitives :
the data primitives are exchanged through a service access point. in the socket api, the equivalent to the service access point is the socket. a socket is a data structure which is maintained by the networking stack and is used by the application every time it needs to send or receive data through the networking stack. the socket method in the python api takes two main arguments :
• an address family that speciﬁes the type of address family and thus the underlying networking stack that will be used with the socket. this parameter can be either socket.af_inet or socket.af_inet6. socket.af_inet, which corresponds to the tcp/ipv4 protocol stack is the default. socket.af_inet6 corresponds to the tcp/ipv6 protocol stack.
• a type indicates the type of service which is expected from the networking stack. socket.stream (the default) corresponds to the reliable bytestream connection-oriented service. socket.dgram corresponds to the connectionless service.
# a simple client of the connectionless service import socket import sys hostip=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" s = socket.socket( socket.af_inet, socket.sock_dgram ) s.sendto( msg, (hostip, port) )
where 127.0.0.1 is the ipv4 address of the host (in this case the localhost) where the server is running and 12345 the port of the server. the ﬁrst operation is the creation of the socket. two parameters must be speciﬁed while creating a socket. the ﬁrst parameter indicates the address family and the second the socket type. the second operation is the transmission of the message by using sendto to the server. it should be noted that sendto takes as arguments the message to be transmitted and a tuple that contains the ipv4 address of the server and its port number. the code shown above supports only the tcp/ipv4 protocol stack. to use the tcp/ipv6 protocol stack the socket must be created by using the socket.af_inet6 address family. forcing the application developer to select tcp/ipv4 or tcp/ipv6 when creating a socket is a major hurdle for the deployment and usage of tcp/ipv6 in the global internet [cheshire2010]. while most operating systems support both tcp/ipv4 and tcp/ipv6, many applications still only use tcp/ipv4 by default. in the long term, the socket api should be able to handle tcp/ipv4 and tcp/ipv6 transparently and should not force the application developer to always specify whether it uses tcp/ipv4 or tcp/ipv6. another important issue with the socket api as supported by python is that it forces the application to deal with ip addresses instead of dealing directly with domain names. this limitation dates from the early days of the socket api in unix 4.2bsd. at that time, the dns was not widely available and only ip addresses could be used. most applications rely on dns names to interact with servers and this utilisation of the dns plays a very important role to scale web servers and content distribution networks. to use domain names, the application needs
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
as mentioned above, the socket api is very low-level. this is the interface to the transport service. for a common and simple task, like retrieving a document from the web, there are much simpler solutions. for example, the python standard library includes several high-level apis to implementations of various application layer protocols including http. for example, the httplib module can be used to easily access documents via http.
conn = httplib.httpconnection(hostname, port) conn.request("get", path) r = conn.getresponse() print "response is %i (%s)" % (r.status, r.reason) print r.read()
another module, urllib2 allows the programmer to directly use urls. this is much more simpler than directly using sockets. but simplicity is not the only advantage of using high-level libraries. they allow the programmer to manipulate i want the content pointed by this url) but also include many features such as higher-level concepts ( e.g. transparent support for the utilisation of tls or ipv6. the second type of applications that can be written by using the socket api are the servers. a server is typically runs forever waiting to process requests coming from remote clients. a server using the connectionless will typically start with the creation of a socket with the socket.socket. this socket can be created above the tcp/ipv4 networking stack (socket.af_inet) or the tcp/ipv6 networking stack (socket.af_inet6), but not both by default. if a server is willing to use the two networking stacks, it must create two threads, one to handle the tcp/ipv4 socket and the other to handle the tcp/ipv6 socket. it is unfortunately impossible to deﬁne a socket that can receive data from both networking stacks at the same time with the python socket api. a server using the connectionless service will typically use two methods from the socket api in addition to those that we have already discussed.
• socket.bind is used to bind a socket to a port number and optionally an ip address. most servers will bind their socket to all available interfaces on the servers, but there are some situations where the server
to perform the dns resolution by using the getaddrinfo method. this method queries the dns and builds the sockaddr data structure which is used by other methods of the socket api. in python, getaddrinfo takes several arguments :
• a name that is the domain name for which the dns will be queried • an optional port number which is the port number of the remote server • an optional address
the dns request. socket.af_inet (resp. socket.af_inet6) indicates that an ipv4 (ipv6) address is expected. furthermore, the python socket api allows an application to use socket.af_unspec to indicate that it is able to use either ipv4 or ipv6 addresses.
in today’s internet hosts that are capable of supporting both ipv4 and ipv6, all applications should be able to handle both ipv4 and ipv6 addresses. when used with the socket.af_unspec parameter, the socket.getaddrinfo method returns a list of tuples containing all the information to create a socket.
import socket socket.getaddrinfo(’www.example.net’,80,socket.af_unspec,socket.sock_stream) [ (30, 1, 6, ’’, (’2001:db8:3080:3::2’, 80, 0, 0)),
in the example above, socket.getaddrinfo returns two tuples. the ﬁrst one corresponds to the sockaddr containing the ipv6 address of the remote server and the second corresponds to the ipv4 information. due to some peculiarities of ipv6 and ipv4, the format of the two tuples is not exactly the same, but the key information in both cases are the network layer address (2001:db8:3080:3::2 and 203.0.113.225) and the port number (80). the other parameters are seldom used. socket.getaddrinfo can be used to build a simple client that queries the dns and contact the server by using either ipv4 or ipv6 depending on the addresses returned by the socket.getaddrinfo method. the client below iterates over the list of addresses returned by the dns and sends its request to the ﬁrst destination address for which it can create a socket. other strategies are of course possible. for example, a host running in an ipv6 network might prefer to always use ipv6 when ipv6 is available 19. another example is the happy eyeballs approach which is being discussed within the ietf [wy2011]. for example, [wy2011] mentions that some web browsers try to use the ﬁrst address returned by socket.getaddrinfo. if there is no answer within some small delay (e.g. 300 milliseconds), the second address is tried.
import socket import sys hostname=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" for a in socket.getaddrinfo(hostname, port, socket.af_unspec,socket.sock_dgram,0, socket.ai_passive) :
now that we have described the utilisation of the socket api to write a simple client using the connectionless transport service, let us have a closer look at the reliable byte stream transport service. as explained above, this service is invoked by creating a socket of type socket.sock_stream. once a socket has been created, a client will typically connect to the remote server, send some data, wait for an answer and eventually close the connection. these operations are performed by calling the following methods :
to perform the dns resolution by using the getaddrinfo method. this method queries the dns and builds the sockaddr data structure which is used by other methods of the socket api. in python, getaddrinfo takes several arguments :
• a name that is the domain name for which the dns will be queried • an optional port number which is the port number of the remote server • an optional address
the dns request. socket.af_inet (resp. socket.af_inet6) indicates that an ipv4 (ipv6) address is expected. furthermore, the python socket api allows an application to use socket.af_unspec to indicate that it is able to use either ipv4 or ipv6 addresses.
in today’s internet hosts that are capable of supporting both ipv4 and ipv6, all applications should be able to handle both ipv4 and ipv6 addresses. when used with the socket.af_unspec parameter, the socket.getaddrinfo method returns a list of tuples containing all the information to create a socket.
import socket socket.getaddrinfo(’www.example.net’,80,socket.af_unspec,socket.sock_stream) [ (30, 1, 6, ’’, (’2001:db8:3080:3::2’, 80, 0, 0)),
in the example above, socket.getaddrinfo returns two tuples. the ﬁrst one corresponds to the sockaddr containing the ipv6 address of the remote server and the second corresponds to the ipv4 information. due to some peculiarities of ipv6 and ipv4, the format of the two tuples is not exactly the same, but the key information in both cases are the network layer address (2001:db8:3080:3::2 and 203.0.113.225) and the port number (80). the other parameters are seldom used. socket.getaddrinfo can be used to build a simple client that queries the dns and contact the server by using either ipv4 or ipv6 depending on the addresses returned by the socket.getaddrinfo method. the client below iterates over the list of addresses returned by the dns and sends its request to the ﬁrst destination address for which it can create a socket. other strategies are of course possible. for example, a host running in an ipv6 network might prefer to always use ipv6 when ipv6 is available 19. another example is the happy eyeballs approach which is being discussed within the ietf [wy2011]. for example, [wy2011] mentions that some web browsers try to use the ﬁrst address returned by socket.getaddrinfo. if there is no answer within some small delay (e.g. 300 milliseconds), the second address is tried.
import socket import sys hostname=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" for a in socket.getaddrinfo(hostname, port, socket.af_unspec,socket.sock_dgram,0, socket.ai_passive) :
now that we have described the utilisation of the socket api to write a simple client using the connectionless transport service, let us have a closer look at the reliable byte stream transport service. as explained above, this service is invoked by creating a socket of type socket.sock_stream. once a socket has been created, a client will typically connect to the remote server, send some data, wait for an answer and eventually close the connection. these operations are performed by calling the following methods :
to perform the dns resolution by using the getaddrinfo method. this method queries the dns and builds the sockaddr data structure which is used by other methods of the socket api. in python, getaddrinfo takes several arguments :
• a name that is the domain name for which the dns will be queried • an optional port number which is the port number of the remote server • an optional address
the dns request. socket.af_inet (resp. socket.af_inet6) indicates that an ipv4 (ipv6) address is expected. furthermore, the python socket api allows an application to use socket.af_unspec to indicate that it is able to use either ipv4 or ipv6 addresses.
in today’s internet hosts that are capable of supporting both ipv4 and ipv6, all applications should be able to handle both ipv4 and ipv6 addresses. when used with the socket.af_unspec parameter, the socket.getaddrinfo method returns a list of tuples containing all the information to create a socket.
import socket socket.getaddrinfo(’www.example.net’,80,socket.af_unspec,socket.sock_stream) [ (30, 1, 6, ’’, (’2001:db8:3080:3::2’, 80, 0, 0)),
in the example above, socket.getaddrinfo returns two tuples. the ﬁrst one corresponds to the sockaddr containing the ipv6 address of the remote server and the second corresponds to the ipv4 information. due to some peculiarities of ipv6 and ipv4, the format of the two tuples is not exactly the same, but the key information in both cases are the network layer address (2001:db8:3080:3::2 and 203.0.113.225) and the port number (80). the other parameters are seldom used. socket.getaddrinfo can be used to build a simple client that queries the dns and contact the server by using either ipv4 or ipv6 depending on the addresses returned by the socket.getaddrinfo method. the client below iterates over the list of addresses returned by the dns and sends its request to the ﬁrst destination address for which it can create a socket. other strategies are of course possible. for example, a host running in an ipv6 network might prefer to always use ipv6 when ipv6 is available 19. another example is the happy eyeballs approach which is being discussed within the ietf [wy2011]. for example, [wy2011] mentions that some web browsers try to use the ﬁrst address returned by socket.getaddrinfo. if there is no answer within some small delay (e.g. 300 milliseconds), the second address is tried.
import socket import sys hostname=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" for a in socket.getaddrinfo(hostname, port, socket.af_unspec,socket.sock_dgram,0, socket.ai_passive) :
now that we have described the utilisation of the socket api to write a simple client using the connectionless transport service, let us have a closer look at the reliable byte stream transport service. as explained above, this service is invoked by creating a socket of type socket.sock_stream. once a socket has been created, a client will typically connect to the remote server, send some data, wait for an answer and eventually close the connection. these operations are performed by calling the following methods :
as mentioned above, the socket api is very low-level. this is the interface to the transport service. for a common and simple task, like retrieving a document from the web, there are much simpler solutions. for example, the python standard library includes several high-level apis to implementations of various application layer protocols including http. for example, the httplib module can be used to easily access documents via http.
conn = httplib.httpconnection(hostname, port) conn.request("get", path) r = conn.getresponse() print "response is %i (%s)" % (r.status, r.reason) print r.read()
another module, urllib2 allows the programmer to directly use urls. this is much more simpler than directly using sockets. but simplicity is not the only advantage of using high-level libraries. they allow the programmer to manipulate i want the content pointed by this url) but also include many features such as higher-level concepts ( e.g. transparent support for the utilisation of tls or ipv6. the second type of applications that can be written by using the socket api are the servers. a server is typically runs forever waiting to process requests coming from remote clients. a server using the connectionless will typically start with the creation of a socket with the socket.socket. this socket can be created above the tcp/ipv4 networking stack (socket.af_inet) or the tcp/ipv6 networking stack (socket.af_inet6), but not both by default. if a server is willing to use the two networking stacks, it must create two threads, one to handle the tcp/ipv4 socket and the other to handle the tcp/ipv6 socket. it is unfortunately impossible to deﬁne a socket that can receive data from both networking stacks at the same time with the python socket api. a server using the connectionless service will typically use two methods from the socket api in addition to those that we have already discussed.
• socket.bind is used to bind a socket to a port number and optionally an ip address. most servers will bind their socket to all available interfaces on the servers, but there are some situations where the server
to perform the dns resolution by using the getaddrinfo method. this method queries the dns and builds the sockaddr data structure which is used by other methods of the socket api. in python, getaddrinfo takes several arguments :
• a name that is the domain name for which the dns will be queried • an optional port number which is the port number of the remote server • an optional address
the dns request. socket.af_inet (resp. socket.af_inet6) indicates that an ipv4 (ipv6) address is expected. furthermore, the python socket api allows an application to use socket.af_unspec to indicate that it is able to use either ipv4 or ipv6 addresses.
in today’s internet hosts that are capable of supporting both ipv4 and ipv6, all applications should be able to handle both ipv4 and ipv6 addresses. when used with the socket.af_unspec parameter, the socket.getaddrinfo method returns a list of tuples containing all the information to create a socket.
import socket socket.getaddrinfo(’www.example.net’,80,socket.af_unspec,socket.sock_stream) [ (30, 1, 6, ’’, (’2001:db8:3080:3::2’, 80, 0, 0)),
in the example above, socket.getaddrinfo returns two tuples. the ﬁrst one corresponds to the sockaddr containing the ipv6 address of the remote server and the second corresponds to the ipv4 information. due to some peculiarities of ipv6 and ipv4, the format of the two tuples is not exactly the same, but the key information in both cases are the network layer address (2001:db8:3080:3::2 and 203.0.113.225) and the port number (80). the other parameters are seldom used. socket.getaddrinfo can be used to build a simple client that queries the dns and contact the server by using either ipv4 or ipv6 depending on the addresses returned by the socket.getaddrinfo method. the client below iterates over the list of addresses returned by the dns and sends its request to the ﬁrst destination address for which it can create a socket. other strategies are of course possible. for example, a host running in an ipv6 network might prefer to always use ipv6 when ipv6 is available 19. another example is the happy eyeballs approach which is being discussed within the ietf [wy2011]. for example, [wy2011] mentions that some web browsers try to use the ﬁrst address returned by socket.getaddrinfo. if there is no answer within some small delay (e.g. 300 milliseconds), the second address is tried.
import socket import sys hostname=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" for a in socket.getaddrinfo(hostname, port, socket.af_unspec,socket.sock_dgram,0, socket.ai_passive) :
now that we have described the utilisation of the socket api to write a simple client using the connectionless transport service, let us have a closer look at the reliable byte stream transport service. as explained above, this service is invoked by creating a socket of type socket.sock_stream. once a socket has been created, a client will typically connect to the remote server, send some data, wait for an answer and eventually close the connection. these operations are performed by calling the following methods :
to perform the dns resolution by using the getaddrinfo method. this method queries the dns and builds the sockaddr data structure which is used by other methods of the socket api. in python, getaddrinfo takes several arguments :
• a name that is the domain name for which the dns will be queried • an optional port number which is the port number of the remote server • an optional address
the dns request. socket.af_inet (resp. socket.af_inet6) indicates that an ipv4 (ipv6) address is expected. furthermore, the python socket api allows an application to use socket.af_unspec to indicate that it is able to use either ipv4 or ipv6 addresses.
in today’s internet hosts that are capable of supporting both ipv4 and ipv6, all applications should be able to handle both ipv4 and ipv6 addresses. when used with the socket.af_unspec parameter, the socket.getaddrinfo method returns a list of tuples containing all the information to create a socket.
import socket socket.getaddrinfo(’www.example.net’,80,socket.af_unspec,socket.sock_stream) [ (30, 1, 6, ’’, (’2001:db8:3080:3::2’, 80, 0, 0)),
in the example above, socket.getaddrinfo returns two tuples. the ﬁrst one corresponds to the sockaddr containing the ipv6 address of the remote server and the second corresponds to the ipv4 information. due to some peculiarities of ipv6 and ipv4, the format of the two tuples is not exactly the same, but the key information in both cases are the network layer address (2001:db8:3080:3::2 and 203.0.113.225) and the port number (80). the other parameters are seldom used. socket.getaddrinfo can be used to build a simple client that queries the dns and contact the server by using either ipv4 or ipv6 depending on the addresses returned by the socket.getaddrinfo method. the client below iterates over the list of addresses returned by the dns and sends its request to the ﬁrst destination address for which it can create a socket. other strategies are of course possible. for example, a host running in an ipv6 network might prefer to always use ipv6 when ipv6 is available 19. another example is the happy eyeballs approach which is being discussed within the ietf [wy2011]. for example, [wy2011] mentions that some web browsers try to use the ﬁrst address returned by socket.getaddrinfo. if there is no answer within some small delay (e.g. 300 milliseconds), the second address is tried.
import socket import sys hostname=sys.argv[1] port=int(sys.argv[2]) msg="hello, world!" for a in socket.getaddrinfo(hostname, port, socket.af_unspec,socket.sock_dgram,0, socket.ai_passive) :
now that we have described the utilisation of the socket api to write a simple client using the connectionless transport service, let us have a closer look at the reliable byte stream transport service. as explained above, this service is invoked by creating a socket of type socket.sock_stream. once a socket has been created, a client will typically connect to the remote server, send some data, wait for an answer and eventually close the connection. these operations are performed by calling the following methods :
in a network using virtual circuits, all hosts are identiﬁed with a network layer address. however, a host must explicitly request the establishment of a virtual circuit before being able to send packets to a destination host. the request to establish a virtual circuit is processed by the control plane, which installs state to create the virtual circuit between the source and the destination through intermediate routers. all the packets that are sent on the virtual circuit contain a virtual circuit identiﬁer that allows the routers to determine to which virtual circuit each packet belongs. this is illustrated in the ﬁgure below with one virtual circuit between host a and host i and another one between host a and host j.
the establishment of a virtual circuit is performed using a signalling protocol in the control plane. usually, the source host sends a signalling message to indicate to its router the address of the destination and possibly some performance characteristics of the virtual circuit to be established. the ﬁrst router can process the signalling message in two different ways. a ﬁrst solution is for the router to consult its routing table, remember the characteristics of the requested virtual circuit and forward it over its outgoing interface towards the destination. the signalling message is thus forwarded hop-by-hop until it reaches the destination and the virtual circuit is opened along the path followed by the signalling message. this is illustrated with the red virtual circuit in the ﬁgure below.
a second solution can be used if the routers know the entire topology of the network. in this case, the ﬁrst router can use a technique called source routing. upon reception of the signalling message, the ﬁrst router chooses the path of the virtual circuit in the network. this path is encoded as the list of the addresses of all intermediate routers to reach the destination. it is included in the signalling message and intermediate routers can remove their address from the signalling message before forwarding it. this technique enables routers to spread the virtual circuits throughout the network better. if the routers know the load of remote links, they can also select the least loaded path when establishing a virtual circuit. this solution is illustrated with the blue circuit in the ﬁgure above. the last point to be discussed about the virtual circuit organisation is its data plane. the data plane mainly deﬁnes the format of the data packets and the algorithm used by routers to forward packets. the data packets contain a virtual circuit identiﬁer, encoded as a ﬁxed number of bits. these virtual circuit identiﬁers are usually called labels.
the above pseudo-code is often called persistent csma [kt1975] as the terminal will continuously listen to the channel and transmit its frame as soon as the channel becomes free. another important variant of csma is the non-persistent csma [kt1975]. the main difference between persistent and non-persistent csma described in the pseudo-code below is that a non-persistent csma node does not continuously listen to the channel to determine when it becomes free. when a non-persistent csma terminal senses the transmission channel to be busy, it waits for a random time before sensing the channel again. this improves channel utilization compared to persistent csma. with persistent csma, when two terminals sense the channel to be busy, they will both transmit (and thus cause a collision) as soon as the channel becomes free. with non-persistent csma, this synchronisation does not occur, as the terminals wait a random time after having sensed the transmission channel. however, the higher channel utilization achieved by non-persistent csma comes at the expense of a slightly higher waiting time in the terminals when the network is lightly loaded.
[kt1975] analyzes in detail the performance of several csma variants. under some assumptions about the transmission channel and the trafﬁc, the analysis compares aloha, slotted aloha, persistent and non-persistent csma. under these assumptions, aloha achieves a channel utilization of only 18.4% of the channel capacity. slotted aloha is able to use 36.6% of this capacity. persistent csma improves the utilization by reaching 52.9% of the capacity while non-persistent csma achieves 81.5% of the channel capacity.
csma improves channel utilization compared to aloha. however, the performance can still be improved, especially in wired networks. consider the situation of two terminals that are connected to the same cable. this cable could, for example, be a coaxial cable as in the early days of ethernet [metcalfe1976]. it could also be built with twisted pairs. before extending csma, it is useful to understand more intuitively, how frames are transmitted in such a network and how collisions can occur. the ﬁgure below illustrates the physical transmission of a frame on such a cable. to transmit its frame, host a must send an electrical signal on the shared medium. the ﬁrst step is thus to begin the transmission of the electrical signal. this is point (1) in the ﬁgure below. this electrical signal will travel along the cable. although electrical signals travel fast, we know that information cannot travel faster than the speed of light (i.e. 300.000 kilometers/second). on a coaxial cable, an electrical signal is slightly slower
[d = shorter routes advertised by a towards b, c and e. after some time d sends a new distance vector : 0, a = 1, e = 3, c = 4, b = 4]. a updates its routing table and after some time sends its own distance vector [a = 0, d = 1, b = 5, c = 5, e = 4], etc. this problem is known as the count to inﬁnity problem in networking literature. routers a and d exchange distance vectors with increasing costs until these costs reach ∞. this problem may occur in other scenarios than the one depicted in the above ﬁgure. in fact, distance vector routing may suffer from count to inﬁnity problems as soon as there is a cycle in the network. cycles are necessary to have enough redundancy to deal with link and router failures. to mitigate the impact of counting to inﬁnity, some distance vector protocols consider that 16 = ∞. unfortunately, this limits the metrics that network operators can use and the diameter of the networks using distance vectors. this count to inﬁnity problem occurs because router a advertises to router d a route that it has learned via router d. a possible solution to avoid this problem could be to change how a router creates its distance vector. instead of computing one distance vector and sending it to all its neighbors, a router could create a distance vector that is speciﬁc to each neighbour and only contains the routes that have not been learned via this neighbour. this could be implemented by the following pseudocode.
this technique is called split-horizon. with this technique, the count to inﬁnity problem would not have happened in the above scenario, as router a would have advertised [a = 0], since it learned all its other routes via router d. another variant called split-horizon with poison reverse is also possible. routers using this variant advertise a cost of ∞ for the destinations that they reach via the router to which they send the distance vector. this can be implemented by using the pseudo-code below.
unfortunately, split-horizon, is not sufﬁcient to avoid all count to inﬁnity problems with distance vector routing. consider the failure of link a-b in the network of four routers below.
[d = shorter routes advertised by a towards b, c and e. after some time d sends a new distance vector : 0, a = 1, e = 3, c = 4, b = 4]. a updates its routing table and after some time sends its own distance vector [a = 0, d = 1, b = 5, c = 5, e = 4], etc. this problem is known as the count to inﬁnity problem in networking literature. routers a and d exchange distance vectors with increasing costs until these costs reach ∞. this problem may occur in other scenarios than the one depicted in the above ﬁgure. in fact, distance vector routing may suffer from count to inﬁnity problems as soon as there is a cycle in the network. cycles are necessary to have enough redundancy to deal with link and router failures. to mitigate the impact of counting to inﬁnity, some distance vector protocols consider that 16 = ∞. unfortunately, this limits the metrics that network operators can use and the diameter of the networks using distance vectors. this count to inﬁnity problem occurs because router a advertises to router d a route that it has learned via router d. a possible solution to avoid this problem could be to change how a router creates its distance vector. instead of computing one distance vector and sending it to all its neighbors, a router could create a distance vector that is speciﬁc to each neighbour and only contains the routes that have not been learned via this neighbour. this could be implemented by the following pseudocode.
this technique is called split-horizon. with this technique, the count to inﬁnity problem would not have happened in the above scenario, as router a would have advertised [a = 0], since it learned all its other routes via router d. another variant called split-horizon with poison reverse is also possible. routers using this variant advertise a cost of ∞ for the destinations that they reach via the router to which they send the distance vector. this can be implemented by using the pseudo-code below.
unfortunately, split-horizon, is not sufﬁcient to avoid all count to inﬁnity problems with distance vector routing. consider the failure of link a-b in the network of four routers below.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
ﬁeld of the rts frame indicates the duration of the entire reservation (i.e. the time required to transmit the cts, the data frame, the acknowledgements and the required sifs delays). the cts frame has the same format as the acknowledgement frame.
note: the 802.11 service despite the utilization of acknowledgements, the 802.11 layer only provides an unreliable connectionless service like ethernet networks that do not use acknowledgements. the 802.11 acknowledgements are used to minimize the probability of frame duplication. they do not guarantee that all frames will be correctly received by their recipients. like ethernet, 802.11 networks provide a high probability of successful delivery of the frames, not a guarantee. furthermore, it should be noted that 802.11 networks do not use acknowledgements for multicast and broadcast frames. this implies that in practice such frames are more likely to suffer from transmission errors than unicast frames.
in addition to the data and control frames that we have brieﬂy described above, 802.11 networks use several types of management frames. these management frames are used for various purposes. we brieﬂy describe some of these frames below. a detailed discussion may be found in [802.11] and [gast2002]. a ﬁrst type of management frames are the beacon frames. these frames are broadcasted regularly by access points. each beacon frame contains information about the capabilities of the access point (e.g. the supported 802.11 transmission rates) and a service set identity (ssid). the ssid is a null-terminated ascii string that can contain up to 32 characters. an access point may support several ssids and announce them in beacon frames. an access point may also choose to remain silent and not advertise beacon frames. in this case, wifi stations may send probe request frames to force the available access points to return a probe response frame.
note: ip over 802.11 two types of encapsulation schemes were deﬁned to support ip in ethernet networks : the original encapsulation scheme, built above the ethernet dix format is deﬁned in rfc 894 and a second encapsulation rfc 1042 scheme, built above the llc/snap protocol [802.2]. in 802.11 networks, the situation is simpler and only the rfc 1042 encapsulation is used. in practice, this encapsulation adds 6 bytes to the 802.11 header. the ﬁrst four bytes correspond to the llc/snap header. they are followed by the two bytes ethernet type ﬁeld (0x800 for ip and 0x806 for arp). the ﬁgure below shows an ip packet encapsulated in an 802.11 frame.
the second important utilisation of the management frames is to allow a wifi station to be associated with an access point. when a wifi station starts, it listens to beacon frames to ﬁnd the available ssids. to be allowed to
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
the ﬁrst problem faced by a token ring network is that as the token represents the authorization to transmit, it must continuously travel on the ring when no data frame is being transmitted. let us assume that a token has been produced and sent on the ring by one station. in token ring networks, the token is a 24 bits frame whose structure is shown below.
the token is composed of three ﬁelds. first, the starting delimiter is the marker that indicates the beginning of a frame. the ﬁrst token ring networks used manchester coding and the starting delimiter contained both symbols representing 0 and symbols that do not represent bits. the last ﬁeld is the ending delimiter which marks the end of the token. the access control ﬁeld is present in all frames, and contains several ﬂags. the most important is the token bit that is set in token frames and reset in other frames. let us consider the ﬁve station network depicted in ﬁgure a token ring network above and assume that station s1 sends a token. if we neglect the propagation delay on the inter-station links, as each station introduces a one bit delay, the ﬁrst bit of the frame would return to s1 while it sends the ﬁfth bit of the token. if station s1 is powered off at that time, only the ﬁrst ﬁve bits of the token will travel on the ring. to avoid this problem, there is a special station called the monitor on each token ring. to ensure that the token can travel forever on the ring, this monitor inserts a delay that is equal to at least 24 bit transmission times. if station s3 was the monitor in ﬁgure a token ring network, s1 would have been able to transmit the entire token before receiving the ﬁrst bit of the token from its upstream neighbour. now that we have explained how the token can be forwarded on the ring, let us analyse how a station can capture a token to transmit a data frame. for this, we need some information about the format of the data frames. an 802.5 data frame begins with the starting delimiter followed by the access control ﬁeld whose token bit is reset, a frame control ﬁeld that allows for the deﬁnition of several types of frames, destination and source address, a payload, a crc, the ending delimiter and a frame status ﬁeld. the format of the token ring data frames is illustrated below.
to capture a token, a station must operate in listen mode. in this mode, the station receives bits from its upstream neighbour. if the bits correspond to a data frame, they must be forwarded to the downstream neighbour. if they correspond to a token, the station can capture it and transmit its data frame. both the data frame and the token are encoded as a bit string beginning with the starting delimiter followed by the access control ﬁeld. when the station receives the ﬁrst bit of a starting delimiter, it cannot know whether this is a data frame or a token and
there are several differences between ipv6 and ipv4 when considering their interactions with the datalink layer. in ipv6, the interactions between the network and the datalink layer is performed using icmpv6. first icmpv6 is used to resolve the datalink layer address that corresponds to a given ipv6 address. this part of icmpv6 is the neighbour discovery protocol (ndp) deﬁned in rfc 4861. ndp is similar to arp, but there are two important differences. first, ndp messages are exchanged in icmpv6 messages while arp messages are sent as datalink layer frames. second, an arp request is sent as a broadcast frame while an ndp solicitation message is sent as a multicast icmpv6 packet that is transported inside a multicast frame. the operation of the ndp protocol is similar to arp. to obtain an address mapping, a host sends a neighbour solicitation message. this message is sent inside an icmpv6 message that is placed in an ipv6 packet whose source address is the ipv6 address of the requesting host and the destination address is the all-hosts ipv6 multicast address (ff02::1) to which all ipv6 hosts listen. the neighbour solicitation contains the requested ipv6 address. the owner of the requested address replies by sending a unicast neighbour advertisement message to the requesting host. ndp suffers from similar security issues as the arp protocol. however, it is possible to secure ndp by using the cryptographically generated ipv6 addresses (cga) deﬁned in rfc 3972. the secure neighbour discovery protocol is deﬁned in rfc 3971, but a detailed description of this protocol is outside the scope of this chapter. ipv6 networks also support the dynamic host conﬁguration protocol. the ipv6 extensions to dhcp are deﬁned in rfc 3315. the operation of dhcpv6 is similar to dhcp that was described earlier. in addition to dhcpv6, ipv6 networks support another mechanism to assign ipv6 addresses to hosts. this is the stateless address conﬁguration (slac) deﬁned in rfc 4862. when a host boots, it derives its identiﬁer from its datalink layer address 21 and concatenates this 64 bits identiﬁer to the fe80::/64 preﬁx to obtain its link-local ipv6 address. it then sends a neighbour solicitation with its link-local address as a target to verify whether another host is using the same link-local address on this subnet. if it receives a neighbour advertisement indicating that the link-local address is used by another host, it generates another 64 bits identiﬁer and sends again a neighbour solicitation. if there is no answer, the host considers its link-local address to be valid. this address will be used as the source address for all ndp messages sent on the subnet. to automatically conﬁgure its global ipv6 address, the host must know the globally routable ipv6 preﬁx that is used on the local subnet. ipv6 routers regularly send icmpv6 router advertisement messages that indicate the ipv6 preﬁx assigned to each subnet. upon reception of this message, the host can derive its global ipv6 address by concatenating its 64 bits identiﬁer with the received preﬁx. it concludes the slac by sending a neighbour solicitation message targeted at its global ipv6 address to ensure that another host is not using the same ipv6 address.
when the tcp/ip architecture and the ip protocol were deﬁned, two type of devices were considered in the network layer : endhosts and routers. endhosts are the sources and destinations of ip packets while routers forward packets. when a router forwards an ip packet, it consults its forwarding table, updates the packet’s ttl, recomputes its checksum and forwards it to the next hop. a router does not need to read or change the contents of the packet’s payload. however, in today’s internet, there exist devices that are not strictly routers but which process, sometimes modify, and forward ip packets. these devices are often called middleboxes rfc 3234. some middleboxes only operate in the network layer, but most middleboxes are able to analyse the payload of the received packets and extract the transport header, and in some cases the application layer protocols. in this section, we brieﬂy describe two type of middleboxes : ﬁrewalls and network address translation (nat) devices. a discussion of the different types of middleboxes with references may be found in rfc 3234.
when the internet was only a research network interconnecting research labs, security was not a concern, and most hosts agreed to exchange packets over tcp connections with most other hosts. however, as more and more
21 using a datalink layer address to derive a 64 bits identiﬁer for each host raises privacy concerns as the host will always use the same identiﬁer. attackers could use this to track hosts on the internet. an extension to the stateless address conﬁguration mechanism that does not raise privacy concerns is deﬁned in rfc 4941. these privacy extensions allow a host to generate its 64 bits identiﬁer randomly every time it attaches to a subnet. it then becomes impossible for an attacker to use the 64-bits identiﬁer to track a host.
cases, the service provider responds to the connect.request with a disconnect.indication primitive whose reason parameter contains additional information about the failure of the connection.
once the connection has been established, the service provider supplies two data streams to the communicating users. the ﬁrst data stream can be used by the initiating user to send sdus. the second data stream allows the responding user to send sdus to the initiating user. the data streams can be organised in different ways. a ﬁrst organisation is the message-mode transfer. with the message-mode transfer, the service provider guarantees that one and only one data.indication will be delivered to the endpoint of the data stream for each data.request primitive issued by the other endpoint. the message-mode transfer is illustrated in the ﬁgure below. the main advantage of the message-transfer mode is that the recipient receives exactly the sdus that were sent by the other user. if each sdu contains a command, the receiving user can process each command as soon as it receives a sdu. unfortunately, the message-mode transfer is not widely used on the internet. on the internet, the most popular connection-oriented service transfers sdus in stream-mode. with the stream-mode, the service provider supplies a byte stream that links the two communicating users. the sending user sends bytes by using data.request primitives that contain sequences of bytes as sdus. the service provider delivers sdus containing consecutive bytes to the receiving user by using data.indication primitives. the service provider ensures that all the bytes sent at one end
sourceproviderdestinationtimeconnect.requestconnect.indicationconnect.confirmconnect.responsesource considersconnection opendestination considersconnection opensourceproviderdestinationtimeconnect.requestconnect.indicationdisconnect.indicationdisconnect.requestconnection rejectedby providerconnection rejected by destinationconnect.requestdisconnect.indicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
a ﬁrst solution to support such a lan with a link-state routing protocol would be to consider that a lan is equivalent to a full-mesh of point-to-point links as if each router can directly reach any other router on the lan. however, this approach has two important drawbacks :
2. remote routers, when looking at the topology distributed by ospf, consider that there is a full-mesh of links between all the lan routers. such a full-mesh implies a lot of redundancy in case of failure, while in practice the entire lan may completely fail. in case of a failure of the entire lan, all routers need to detect the failures and ﬂood link state packets before the lan is completely removed from the ospf topology by remote routers.
to better represent lans and reduce the number of ospf packets that are exchanged, ospf handles lan differently. when ospf routers boot on a lan, they elect 24 one of them as the designated router (dr) rfc 2328. the dr router represents the local area network, and advertises the lan’s subnet (138.48.4.0/24 in the example above). furthermore, lan routers only exchange hello packets with the dr. thanks to the utilisation of a dr, the topology of the lan appears as a set of point-to-point links connected to the dr as shown in the ﬁgure below.
note: how to quickly detect a link failure ? network operators expect an ospf network to be able to quickly recover from link or router failures [vpd2004]. in an ospf network, the recovery after a failure is performed in three steps [ffeb2005] :
• the routers that are adjacent to the failure detect it quickly. the default solution is to rely on the regular exchange of hello packets. however, the interval between successive hellos is often set to 10 seconds... setting the hello timer down to a few milliseconds is difﬁcult as hello packets are created and processed by the main cpu of the routers and these routers cannot easily generate and process a hello packet every millisecond on each of their interfaces. a better solution is to use a dedicated failure detection protocol such as the bidirectional forwarding detection (bfd) protocol deﬁned in [kw2009] that can be implemented directly on the router interfaces. another solution to be able to detect the failure is to instrument the physical and the datalink layer so that they can interrupt the router when a link fails. unfortunately, such a solution cannot be used on all types of physical and datalink layers.
as explained earlier, the internet is composed of more than 30,000 different networks 25 called domains. each domain is composed of a group of routers and hosts that are managed by the same organisation. example domains include belnet, sprint, level3, geant, abilene, cisco or google ...
• the physical layer may deliver more bits to the receiver than the bits sent by the sender • the physical layer may deliver fewer bits to the receiver than the bits sent by the sender
the datalink layer must allow endsystems to exchange frames containing packets despite all of these limitations. on point-to-point links and local area networks, the ﬁrst problem to be solved is how to encode a frame as a sequence of bits, so that the receiver can easily recover the received frame despite the limitations of the physical layer. if the physical layer were perfect, the problem would be very simple. the datalink layer would simply need to deﬁne how to encode each frame as a sequence of consecutive bits. the receiver would then easily be able to extract the frames from the received bits. unfortunately, the imperfections of the physical layer make this framing problem slightly more complex. several solutions have been proposed and are used in practice in different datalink layer technologies.
this is the framing problem. it can be deﬁned as : “how does a sender encode frames so that the receiver can efﬁciently extract them from the stream of bits that it receives from the physical layer”. a ﬁrst solution to solve the framing problem is to require the physical layer to remain idle for some time after the transmission of each frame. these idle periods can be detected by the receiver and serve as a marker to delineate frame boundaries. unfortunately, this solution is not sufﬁcient for two reasons. first, some physical layers cannot remain idle and always need to transmit bits. second, inserting an idle period between frames decreases the maximum bandwidth that can be achieved by the datalink layer. some physical layers provide an alternative to this idle period. all physical layers are able to send and receive physical symbols that represent values 0 and 1. however, for various reasons that are outside the scope of this chapter, several physical layers are able to exchange other physical symbols as well. for example, the manchester encoding used in several physical layers can send four different symbols. the manchester encoding is a differential encoding scheme in which time is divided into ﬁxed-length periods. each period is divided in two halves and two different voltage levels can be applied. to send a symbol, the sender must set one of these two voltage levels during each half period. to send a 1 (resp. 0), the sender must set a high (resp. low) voltage during the ﬁrst half of the period and a low (resp. high) voltage during the second half. this encoding ensures that there will be a transition at the middle of each period and allows the receiver to synchronise its clock to the sender’s clock. apart from the encodings for 0 and 1, the manchester encoding also supports two additional symbols : invh and invb where the same voltage level is used for the two half periods. by deﬁnition, these two symbols cannot appear inside a frame which is only composed of 0 and 1. some technologies use these special symbols as markers for the beginning or end of frames.
unfortunately, multi-symbol encodings cannot be used by all physical layers and a generic solution which can be used with any physical layer that is able to transmit and receive only 0 and 1 is required. this generic solution is called stufﬁng and two variants exist : bit stufﬁng and character stufﬁng. to enable a receiver to easily delineate the frame boundaries, these two techniques reserve special bit strings as frame boundary markers and encode the frames so that these special bit strings do not appear inside the frames. bit stufﬁng reserves the 01111110 bit string as the frame boundary marker and ensures that there will never be six consecutive 1 symbols transmitted by the physical layer inside a frame. with bit stufﬁng, a frame is sent as follows. first, the sender transmits the marker, i.e. 01111110. then, it sends all the bits of the frame and inserts
an additional bit set to 0 after each sequence of ﬁve consecutive 1 bits. this ensures that the sent frame never contains a sequence of six consecutive bits set to 1. as a consequence, the marker pattern cannot appear inside the frame sent. the marker is also sent to mark the end of the frame. the receiver performs the opposite to decode a received frame. it ﬁrst detects the beginning of the frame thanks to the 01111110 marker. then, it processes the received bits and counts the number of consecutive bits set to 1. if a 0 follows ﬁve consecutive bits set to 1, this bit is removed since it was inserted by the sender. if a 1 follows ﬁve consecutive bits sets to 1, it indicates a marker if it is followed by a bit set to 0. the table below illustrates the application of bit stufﬁng to some frames.
for example, consider the transmission of 0110111111111111111110010. the sender will ﬁrst send the 01111110 marker followed by 011011111. after these ﬁve consecutive bits set to 1, it inserts a bit set to 0 followed by 11111. a new 0 is inserted, followed by 11111. a new 0 is inserted followed by the end of the frame 110010 and the 01111110 marker. bit stufﬁng increases the number of bits required to transmit each frame. the worst case for bit stufﬁng is of course a long sequence of bits set to 1 inside the frame. if transmission errors occur, stuffed bits or markers can be in error. in these cases, the frame affected by the error and possibly the next frame will not be correctly decoded by the receiver, but it will be able to resynchronise itself at the next valid marker. bit stufﬁng can be easily implemented in hardware. however, implementing it in software is difﬁcult given the higher overhead of bit manipulations in software. software implementations prefer to process characters than bits, software-based datalink layers usually use character stufﬁng. this technique operates on frames that contain an integer number of 8-bit characters. some characters are used as markers to delineate the frame boundaries. many character stufﬁng techniques use the dle, stx and etx characters of the ascii character set. dle stx (resp. dle etx) is used to mark the beginning (end) of a frame. when transmitting a frame, the sender adds a dle character after each transmitted dle character. this ensures that none of the markers can appear inside the transmitted frame. the receiver detects the frame boundaries and removes the second dle when it receives two consecutive dle characters. for example, to transmit frame 1 2 3 dle stx 4, a sender will ﬁrst send dle stx as a marker, followed by 1 2 3 dle. then, the sender transmits an additional dle character followed by stx 4 and the dle etx marker. original frame 1 2 3 4 1 2 3 dle stx 4 dle stx dle etx dle stx dle dle stx dle dle etx dle etx
character stufﬁng , like bit stufﬁng, increases the length of the transmitted frames. for character stufﬁng, the worst frame is a frame containing many dle characters. when transmission errors occur, the receiver may incorrectly decode one or two frames (e.g. if the errors occur in the markers). however, it will be able to resynchronise itself with the next correctly received markers.
besides framing, datalink layers also include mechanisms to detect and sometimes even recover from transmission error. to allow a receiver to detect transmission errors, a sender must add some redundant information as an error detection code to the frame sent. this error detection code is computed by the sender on the frame that it transmits. when the receiver receives a frame with an error detection code, it recomputes it and veriﬁes whether the received error detection code matches the computer error detection code. if they match, the frame is considered to be valid. many error detection schemes exist and entire books have been written on the subject. a detailed discussion of these techniques is outside the scope of this book, and we will only discuss some examples to illustrate the key principles. to understand error detection codes, let us consider two devices that exchange bit strings containing n bits. to allow the receiver to detect a transmission error, the sender converts each string of n bits into a string of n+r bits. usually, the r redundant bits are added at the beginning or the end of the transmitted bit string, but some techniques interleave redundant bits with the original bits. an error detection code can be deﬁned as a function that computes the r redundant bits corresponding to each string of n bits. the simplest error detection code is the
an ipv4 address is used to identify an interface on a router or a host. a router has thus as many ipv4 addresses as the number of interfaces that it has in the datalink layer. most hosts have a single datalink layer interface and thus have a single ipv4 address. however, with the growth of wireless, more and more hosts have several datalink layer interfaces (e.g. an ethernet interface and a wifi interface). these hosts are said to be multihomed. a multihomed host with two interfaces has thus two ipv4 addresses. an important point to be deﬁned in a network layer protocol is the allocation of the network layer addresses. a naive allocation scheme would be to provide an ipv4 address to each host when the host is attached to the internet on a ﬁrst come ﬁrst served basis. with this solution, a host in belgium could have address 2.3.4.5 while another host located in africa would use address 2.3.4.6. unfortunately, this would force all routers to maintain a speciﬁc route towards each host. the ﬁgure below shows a simple enterprise network with two routers and three hosts and the associated routing tables if such isolated addresses were used.
to preserve the scalability of the routing system, it is important to minimize the number of routes that are stored on each router. a router cannot store and maintain one route for each of the almost 1 billion hosts that are connected to today’s internet. routers should only maintain routes towards blocks of addresses and not towards individual hosts. for this, hosts are grouped in subnets based on their location in the network. a typical subnet groups all the hosts that are part of the same enterprise. an enterprise network is usually composed of several lans interconnected by routers. a small block of addresses from the enterprise’s block is usually assigned to each lan. an ipv4 address is composed of two parts : a subnetwork identiﬁer and a host identiﬁer. the subnetwork identiﬁer is composed of the high order bits of the address and the host identiﬁer is encoded in the low order bits of the address. this is illustrated in the ﬁgure below.
when a router needs to forward a packet, it must know the subnet of the destination address to be able to consult its forwarding table to forward the packet. rfc 791 proposed to use the high-order bits of the address to encode the length of the subnet identiﬁer. this led to the deﬁnition of three classes of unicast addresses 2
2 in addition to the a, b and c classes, rfc 791 also deﬁned the d and e classes of ipv4 addresses. class d (resp. e) addresses are those whose high order bits are set to 1110 (resp. 1111). class d addresses are used by ip multicast and will be explained later. class e addresses are currently unused, but there are some discussions on possible future usages [wmh2008] [flm2008]
microseconds slot time. if the delay is longer, collisions between short frames may not be correctly detected. this constraint limits the geographical spread of 10baset networks containing hubs.
in the late 1980s, 10 mbps became too slow for some applications and network manufacturers developed several lan technologies that offered higher bandwidth, such as the 100 mbps fddi lan that used optical ﬁbers. as the development of 10base5, 10base2 and 10baset had shown that ethernet could be adapted to different physical layers, several manufacturers started to work on 100 mbps ethernet and convinced ieee to standardise this new technology that was initially called fast ethernet. fast ethernet was designed under two constraints. first, fast ethernet had to support twisted pairs. although it was easier from a physical layer perspective to support higher bandwidth on coaxial cables than on twisted pairs, coaxial cables were a nightmare from deployment and maintenance perspectives. second, fast ethernet had to be perfectly compatible with the existing 10 mbps ethernets to allow fast ethernet technology to be used initially as a backbone technology to interconnect 10 mbps ethernet networks. this forced fast ethernet to use exactly the same frame format as 10 mbps ethernet. this implied that the minimum fast ethernet frame size remained at 512 bits. to preserve csma/cd with this minimum frame size and 100 mbps instead of 10 mbps, the duration of the slot time was decreased to 5.12 microseconds. the evolution of ethernet did not stop. in 1998, the ieee published a ﬁrst standard to provide gigabit ethernet over optical ﬁbers. several other types of physical layers were added afterwards. the 10 gigabit ethernet standard appeared in 2002. work is ongoing to develop standards for 40 gigabit and 100 gigabit ethernet and some are thinking about terabit ethernet. the table below lists the main ethernet standards. a more detailed list may be found at http://en.wikipedia.org/wiki/ethernet_physical_layer
comments thick coaxial cable, 500m thin coaxial cable, 185m two pairs of category 3+ utp 10 mb/s over optical ﬁber category 5 utp or stp, 100 m maximum two multimode optical ﬁber, 2 km maximum
standard 10base5 10base2 10baset 10base-f 100base-tx 100base-fx 1000base-cx two pairs shielded twisted pair, 25m maximum 1000base-sx two multimode or single mode optical ﬁbers with lasers 10 gbps 40-100 gbps
increasing the physical layer bandwidth as in fast ethernet was only one of the solutions to improve the performance of ethernet lans. a second solution was to replace the hubs with more intelligent devices. as ethernet hubs operate in the physical layer, they can only regenerate the electrical signal to extend the geographical reach
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
be exchanged. on the other hand, a server host starts in the init state. when a server process starts to listen to a destination port, the underlying tcp entity creates a tcp control block and a queue to process incoming syn segments. upon reception of a syn segment, the server’s tcp entity replies with a syn+ack and enters the syn rcvd state. it remains in this state until it receives an ack segment that acknowledges its syn+ack segment, with this it then enters the established state. apart from these two paths in the tcp connection establishment fsm, there is a third path that corresponds to the case when both the client and the server send a syn segment to open a tcp connection 13. in this case, the client and the server send a syn segment and enter the syn sent state. upon reception of the syn segment sent by the other host, they reply by sending a syn+ack segment and enter the syn rcvd state. the syn+ack that arrives from the other host allows it to transition to the established state. the ﬁgure below illustrates such a simultaneous establishment of a tcp connection.
13 of course, such a simultaneous tcp establishment can only occur if the source port chosen by the client is equal to the destination port chosen by the server. this may happen when a host can serve both as a client as a server or in peer-to-peer applications when the communicating hosts do not use ephemeral port numbers.
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
a udp application that is often used in the wide area. however, in local area networks, many distributed systems rely on remote procedure call (rpc) that is often used on top of udp. in unix environments, the network file system (nfs) is built on top of rpc and runs frequently on top of udp. a second class of udp-based applications are the interactive computer games that need to frequently exchange small messages, such as the player’s location or their recent actions. many of these games use udp to minimise the delay and can recover from losses. a third class of applications are multimedia applications such as interactive voice over ip or interactive video over ip. these interactive applications expect a delay shorter than about 200 milliseconds between the sender and the receiver and can recover from losses directly inside the application.
the transmission control protocol (tcp) was initially deﬁned in rfc 793. several parts of the protocol have been improved since the publication of the original protocol speciﬁcation 9. however, the basics of the protocol remain and an implementation that only supports rfc 793 should inter-operate with today’s implementation. tcp provides a reliable bytestream, connection-oriented transport service on top of the unreliable connectionless network service provided by ip. tcp is used by a large number of applications, including :
• email (smtp, pop, imap) • world wide web ( http, ...) • most ﬁle transfer protocols ( ftp, peer-to-peer ﬁle sharing applications , ...) • remote computer access : telnet, ssh, x11, vnc, ... • non-interactive multimedia applications : ﬂash
on the global internet, most of the applications used in the wide area rely on tcp. many studies 10 have reported that tcp was responsible for more than 90% of the data exchanged in the global internet. to provide this service, tcp relies on a simple segment format that is shown in the ﬁgure below. each tcp segment contains a header described below and, optionally, a payload. the default length of the tcp header is twenty bytes, but some tcp headers contain options.
• source and destination ports. the source and destination ports play an important role in tcp, as they allow the identiﬁcation of the connection to which a tcp segment belongs. when a client opens a tcp connection, it typically selects an ephemeral tcp port number as its source port and contacts the server by using the server’s port number. all the segments that are sent by the client on this connection have the same source and destination ports. the server sends segments that contain as source (resp. destination port, the
these studies have been performed by collecting all transmitted over a given link during a period of a few hours or days and then analysing their headers recent studies include http://www.caida.org/research/trafﬁc-analysis/tcpudpratio/, https://research.sprintlabs.com/packstat/packetoverview.php or http://www.nanog.org/meetings/nanog43/presentations/labovitz_internetstats_n43.pdf
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
destination (resp. source) port of the segments sent by the client (see ﬁgure utilization of the tcp source and destination ports). a tcp connection is always identiﬁed by ﬁve pieces of information :
• the sequence number (32 bits), acknowledgement number (32 bits) and window (16 bits) ﬁelds are used to provide a reliable data transfer, using a window-based protocol. in a tcp bytestream, each byte of the stream consumes one sequence number. their utilisation will be described in more detail in section tcp reliable data transfer
• the urgent pointer is used to indicate that some data should be considered as urgent in a tcp bytestream. however, it is rarely used in practice and will not be described here. additional details about the utilisation of this pointer may be found in rfc 793, rfc 1122 or [stevens1994]
– the syn ﬂag is used during connection establishment – the fin ﬂag is used during connection release – the rst is used in case of problems or when an invalid segment has been received – when the ack ﬂag is set, it indicates that the acknowledgment ﬁeld contains a valid number. other-
– the urg ﬂag is used together with the urgent pointer – the psh ﬂag is used as a notiﬁcation from the sender to indicate to the receiver that it should pass all the data it has received to the receiving process. however, in practice tcp implementations do not allow tcp users to indicate when the psh ﬂag should be set and thus there are few real utilizations of this ﬂag.
• the reserved ﬁeld was initially reserved for future utilization. it is now used by rfc 3168. • the tcp header length (thl) or data offset ﬁeld is a four bits ﬁeld that indicates the size of the tcp
• the optional header extension is used to add optional information to the tcp header. thanks to this header extension, it is possible to add new ﬁelds to the tcp header that were not planned in the original speciﬁcation. this allowed tcp to evolve since the early eighties. the details of the tcp header extension are explained in sections tcp connection establishment and tcp reliable data transfer.
the rest of this section is organised as follows. we ﬁrst explain the establishment and the release of a tcp connection, then we discuss the mechanisms that are used by tcp to provide a reliable bytestream service. we end the section with a discussion of network congestion and explain the mechanisms that tcp uses to avoid congestion collapse.
a tcp connection is established by using a three-way handshake. the connection establishment phase uses the sequence number, the acknowledgment number and the syn ﬂag. when a tcp connection is established, the two communicating hosts negotiate the initial sequence number to be used in both directions of the connection. for this, each tcp entity maintains a 32 bits counter, which is supposed to be incremented by one at least every 4
another utilisation of tcp options during connection establishment is to enable tcp extensions. for example, consider rfc 1323 (which is discussed in tcp reliable data transfer). rfc 1323 deﬁnes tcp extensions to support timestamps and larger windows. if the client supports rfc 1323, it adds a rfc 1323 option to its syn if the server understands this rfc 1323 option and wishes to use it, it replies with an rfc 1323 segment. option in the syn+ack segment and the extension deﬁned in rfc 1323 is used throughout the tcp connection. otherwise, if the server’s syn+ack does not contain the rfc 1323 option, the client is not allowed to use this extension and the corresponding tcp header options throughout the tcp connection. tcp’s option mechanism is ﬂexible and it allows the extension of tcp while maintaining compatibility with older implementations. the tcp options are encoded by using a type length value format where :
• the ﬁrst byte indicates the type of the option. • the second byte indicates the total length of the option (including the ﬁrst two bytes) in bytes • the last bytes are speciﬁc for each type of option
rfc 793 deﬁnes the maximum segment size (mss) tcp option that must be understood by all tcp implementations. this option (type 2) has a length of 4 bytes and contains a 16 bits word that indicates the mss supported by the sender of the syn segment. the mss option can only be used in tcp segments having the syn ﬂag set. rfc 793 also deﬁnes two special options that must be supported by all tcp implementations. the ﬁrst option is end of option. it is encoded as a single byte having value 0x00 and can be used to ensure that the tcp header extension ends on a 32 bits boundary. the no-operation option, encoded as a single byte having value 0x01, can be used when the tcp header extension contains several tcp options that should be aligned on 32 bit boundaries. all other options 14 are encoded by using the tlv format.
note: the robustness principle the handling of the tcp options by tcp implementations is one of the many applications of the robustness principle which is usually attributed to jon postel and is often quoted as “be liberal in what you accept, and conservative in what you send” rfc 1122 concerning the tcp options, the robustness principle implies that a tcp implementation should be able to accept tcp options that it does not understand, in particular in received syn segments, and that it should be able to parse any received segment without crashing, even if the segment contains an unknown tcp option. furthermore, a server should not send in the syn+ack segment or later, options that have not been proposed by the client in the syn segment.
• graceful connection release, where each tcp user can release its own direction of data transfer • abrupt connection release, where either one user closes both directions of data transfer or one tcp entity is forced to close the connection (e.g. because the remote host does not reply anymore or due to lack of resources)
the abrupt connection release mechanism is very simple and relies on a single segment having the rst bit set. a tcp segment containing the rst bit can be sent for the following reasons :
• a non-syn segment was received for a non-existing tcp connection rfc 793 • by extension, some implementations respond with an rst segment to a segment that is received on an existing connection but with an invalid header rfc 3360. this causes the corresponding connection to be closed and has caused security attacks rfc 4953
• by extension, some implementations send an rst segment when they need to close an existing tcp connection (e.g. because there are not enough resources to support this connection or because the remote host is considered to be unreachable). measurements have shown that this usage of tcp rst was widespread [aw05]
easiest and less costly method to send acknowledgements is to place them in the data segments sent in the other direction. however, few application layer protocols exchange data in both directions at the same time and thus this method rarely works. for an application that is sending data segments in one direction only, the remote tcp entity returns empty tcp segments whose only useful information is their acknowledgement number. this may cause a large overhead in wide area network if a pure ack segment is sent in response to each received data segment. most tcp implementations use a delayed acknowledgement strategy. this strategy ensures that piggybacking is used whenever possible, otherwise pure ack segments are sent for every second received data segments when there are no losses. when there are losses or reordering, ack segments are more important for the sender and they are sent immediately rfc 813 rfc 1122. this strategy relies on a new timer with a short delay (e.g. 50 milliseconds) and one additional ﬂag in the tcb. it can be implemented as follows
due to this delayed acknowledgement strategy, during a bulk transfer, a tcp implementation usually acknowledges every second tcp segment received. the default go-back-n retransmission strategy used by tcp has the advantage of being simple to implement, in particular on the receiver side, but when there are losses, a go-back-n strategy provides a lower performance than a selective repeat strategy. the tcp developers have designed several extensions to tcp to allow it to use a selective repeat strategy while maintaining backward compatibility with older tcp implementations. these tcp extensions assume that the receiver is able to buffer the segments that it receives out-of-sequence. the ﬁrst extension that was proposed is the fast retransmit heuristic. this extension can be implemented on tcp senders and thus does not require any change to the protocol. it only assumes that the tcp receiver is able to buffer out-of-sequence segments. from a performance point of view, one issue with tcp’s retransmission timeout is that when there are isolated segment losses, the tcp sender often remains idle waiting for the expiration of its retransmission timeouts. such isolated losses are frequent in the global internet [paxson99]. a heuristic to deal with isolated losses without waiting for the expiration of the retransmission timeout has been included in many tcp implementations since the early 1990s. to understand this heuristic, let us consider the ﬁgure below that shows the segments exchanged over a tcp connection when an isolated segment is lost. as shown above, when an isolated segment is lost the sender receives several duplicate acknowledgements since the tcp receiver immediately sends a pure acknowledgement when it receives an out-of-sequence segment. a duplicate acknowledgement is an acknowledgement that contains the same acknowledgement number as a previous segment. a single duplicate acknowledgement does not necessarily imply that a segment was lost, as a simple reordering of the segments may cause duplicate acknowledgements as well. measurements [paxson99] have shown that segment reordering is frequent in the internet. based on these observations, the fast retransmit heuristic has been included in most tcp implementations. it can be implemented as follows
a udp application that is often used in the wide area. however, in local area networks, many distributed systems rely on remote procedure call (rpc) that is often used on top of udp. in unix environments, the network file system (nfs) is built on top of rpc and runs frequently on top of udp. a second class of udp-based applications are the interactive computer games that need to frequently exchange small messages, such as the player’s location or their recent actions. many of these games use udp to minimise the delay and can recover from losses. a third class of applications are multimedia applications such as interactive voice over ip or interactive video over ip. these interactive applications expect a delay shorter than about 200 milliseconds between the sender and the receiver and can recover from losses directly inside the application.
the transmission control protocol (tcp) was initially deﬁned in rfc 793. several parts of the protocol have been improved since the publication of the original protocol speciﬁcation 9. however, the basics of the protocol remain and an implementation that only supports rfc 793 should inter-operate with today’s implementation. tcp provides a reliable bytestream, connection-oriented transport service on top of the unreliable connectionless network service provided by ip. tcp is used by a large number of applications, including :
• email (smtp, pop, imap) • world wide web ( http, ...) • most ﬁle transfer protocols ( ftp, peer-to-peer ﬁle sharing applications , ...) • remote computer access : telnet, ssh, x11, vnc, ... • non-interactive multimedia applications : ﬂash
on the global internet, most of the applications used in the wide area rely on tcp. many studies 10 have reported that tcp was responsible for more than 90% of the data exchanged in the global internet. to provide this service, tcp relies on a simple segment format that is shown in the ﬁgure below. each tcp segment contains a header described below and, optionally, a payload. the default length of the tcp header is twenty bytes, but some tcp headers contain options.
• source and destination ports. the source and destination ports play an important role in tcp, as they allow the identiﬁcation of the connection to which a tcp segment belongs. when a client opens a tcp connection, it typically selects an ephemeral tcp port number as its source port and contacts the server by using the server’s port number. all the segments that are sent by the client on this connection have the same source and destination ports. the server sends segments that contain as source (resp. destination port, the
these studies have been performed by collecting all transmitted over a given link during a period of a few hours or days and then analysing their headers recent studies include http://www.caida.org/research/trafﬁc-analysis/tcpudpratio/, https://research.sprintlabs.com/packstat/packetoverview.php or http://www.nanog.org/meetings/nanog43/presentations/labovitz_internetstats_n43.pdf
microseconds and after each connection establishment 11. when a client host wants to open a tcp connection with a server host, it creates a tcp segment with :
• the syn ﬂag set • the sequence number set to the current value of the 32 bits counter of the server host’s tcp entity • the ack ﬂag set • the acknowledgment number set to the sequence number of the received syn segment incremented by 1 ( mod 232). when a tcp entity sends a segment having x+1 as acknowledgment number, this indicates that it has received all data up to and including sequence number x and that it is expecting data having sequence number x+1. as the syn ﬂag was set in a segment having sequence number x, this implies that setting the syn ﬂag in a segment consumes one sequence number.
this segment is often called a syn+ack segment. the acknowledgment conﬁrms to the client that the server has correctly received the syn segment. the sequence number of the syn+ack segment is used by the server host to verify that the client has received the segment. upon reception of the syn+ack segment, the client host replies with a segment containing :
at this point, the tcp connection is open and both the client and the server are allowed to send tcp segments containing data. this is illustrated in the ﬁgure below. in the ﬁgure above, the connection is considered to be established by the client once it has received the syn+ack segment, while the server considers the connection to be established upon reception of the ack segment. the ﬁrst data segment sent by the client (server) has its sequence number set to x+1 (resp. y+1).
note: computing tcp’s initial sequence number in the original tcp speciﬁcation rfc 793, each tcp entity maintained a clock to compute the initial sequence number (isn) placed in the syn and syn+ack segments. this made the isn predictable and caused a security issue. the typical security problem was the following. consider a server that trusts a host based on its ip address
denial of service attacks when a tcp entity opens a tcp connection, it creates a transmission control block (tcb). the tcb contains the entire state that is maintained by the tcp entity for each tcp connection. during connection establishment, the tcb contains the local ip address, the remote ip address, the local port number, the remote port number, the current local sequence number, the last sequence number received from the remote entity. until the mid 1990s, tcp implementations had a limit on the number of tcp connections that could be in the syn rcvd state at a given time. many implementations set this limit to about 100 tcbs. this limit was considered sufﬁcient even for heavily load http servers given the small delay between the reception of a syn segment and the reception of the ack segment that terminates the establishment of the tcp connection. when the limit of 100 tcbs in the syn rcvd state is reached, the tcp entity discards all received tcp syn segments that do not correspond to an existing tcb. this limit of 100 tcbs in the syn rcvd state was chosen to protect the tcp entity from the risk of overloading its memory with too many tcbs in the syn rcvd state. however, it was also the reason for a new type of denial of service (dos) attack rfc 4987. a dos attack is deﬁned as an attack where an attacker can render a resource unavailable in the network. for example, an attacker may cause a dos attack on a 2 mbps link used by a company by sending more than 2 mbps of packets through this link. in this case, the dos attack was more subtle. as a tcp entity discards all received syn segments as soon as it has 100 tcbs in the syn rcvd state, an attacker simply had to send a few 100 syn segments every second to a server and never reply to the received syn+ack segments. to avoid being caught, attackers were of course sending these syn segments with a different address than their own ip address a. on most tcp implementations, once a tcb entered the syn rcvd state, it remained in this state for several seconds, waiting for a retransmission of the initial syn segment. this attack was later called a syn ﬂood attack and the servers of the isp named panix were among the ﬁrst to be affected by this attack. to avoid the syn ﬂood attacks, recent tcp implementations no longer enter the syn rcvd state upon reception of a syn segment. instead, they reply directly with a syn+ack segment and wait until the reception of a valid ack. this implementation trick is only possible if the tcp implementation is able to verify that the received ack segment acknowledges the syn+ack segment sent earlier without storing the initial sequence number of this syn+ack segment in a tcb. the solution to solve this problem, which is known as syn cookies is to compute the 32 bits of the isn as follows :
• the high order bits contain the low order bits of a counter that is incremented slowly • the low order bits contain a hash value computed over the local and remote ip addresses and ports and
the advantage of the syn cookies is that by using them, the server does not need to create a tcb upon reception of the syn segment and can still check the returned ack segment by recomputing the syn cookie.
retransmitting the ﬁrst syn segment as ip provides an unreliable connectionless service, the syn and syn+ack segments sent to open a tcp connection could be lost. current tcp implementations start a retransmission timer when they send the ﬁrst syn segment. this timer is often set to three seconds for the ﬁrst retransmission and then doubles after each retransmission rfc 2988. tcp implementations also enforce a maximum number of retransmissions for the initial syn segment.
as explained earlier, tcp segments may contain an optional header extension. in the syn and syn+ack segments, these options are used to negotiate some parameters and the utilisation of extensions to the basic tcp speciﬁcation. the ﬁrst parameter which is negotiated during the establishment of a tcp connection is the maximum segment size (mss). the mss is the size of the largest segment that a tcp entity is able to process. according to rfc 879, all tcp implementations must be able to receive tcp segments containing 536 bytes of payload. however, most tcp implementations are able to process larger segments. such tcp implementations use the tcp mss option in the syn/syn+ack segment to indicate the largest segment they are able to process. the mss value indicates the maximum size of the payload of the tcp segments. the client (resp. server) stores in its tcb the mss value announced by the server (resp. the client).
denial of service attacks when a tcp entity opens a tcp connection, it creates a transmission control block (tcb). the tcb contains the entire state that is maintained by the tcp entity for each tcp connection. during connection establishment, the tcb contains the local ip address, the remote ip address, the local port number, the remote port number, the current local sequence number, the last sequence number received from the remote entity. until the mid 1990s, tcp implementations had a limit on the number of tcp connections that could be in the syn rcvd state at a given time. many implementations set this limit to about 100 tcbs. this limit was considered sufﬁcient even for heavily load http servers given the small delay between the reception of a syn segment and the reception of the ack segment that terminates the establishment of the tcp connection. when the limit of 100 tcbs in the syn rcvd state is reached, the tcp entity discards all received tcp syn segments that do not correspond to an existing tcb. this limit of 100 tcbs in the syn rcvd state was chosen to protect the tcp entity from the risk of overloading its memory with too many tcbs in the syn rcvd state. however, it was also the reason for a new type of denial of service (dos) attack rfc 4987. a dos attack is deﬁned as an attack where an attacker can render a resource unavailable in the network. for example, an attacker may cause a dos attack on a 2 mbps link used by a company by sending more than 2 mbps of packets through this link. in this case, the dos attack was more subtle. as a tcp entity discards all received syn segments as soon as it has 100 tcbs in the syn rcvd state, an attacker simply had to send a few 100 syn segments every second to a server and never reply to the received syn+ack segments. to avoid being caught, attackers were of course sending these syn segments with a different address than their own ip address a. on most tcp implementations, once a tcb entered the syn rcvd state, it remained in this state for several seconds, waiting for a retransmission of the initial syn segment. this attack was later called a syn ﬂood attack and the servers of the isp named panix were among the ﬁrst to be affected by this attack. to avoid the syn ﬂood attacks, recent tcp implementations no longer enter the syn rcvd state upon reception of a syn segment. instead, they reply directly with a syn+ack segment and wait until the reception of a valid ack. this implementation trick is only possible if the tcp implementation is able to verify that the received ack segment acknowledges the syn+ack segment sent earlier without storing the initial sequence number of this syn+ack segment in a tcb. the solution to solve this problem, which is known as syn cookies is to compute the 32 bits of the isn as follows :
• the high order bits contain the low order bits of a counter that is incremented slowly • the low order bits contain a hash value computed over the local and remote ip addresses and ports and
the advantage of the syn cookies is that by using them, the server does not need to create a tcb upon reception of the syn segment and can still check the returned ack segment by recomputing the syn cookie.
retransmitting the ﬁrst syn segment as ip provides an unreliable connectionless service, the syn and syn+ack segments sent to open a tcp connection could be lost. current tcp implementations start a retransmission timer when they send the ﬁrst syn segment. this timer is often set to three seconds for the ﬁrst retransmission and then doubles after each retransmission rfc 2988. tcp implementations also enforce a maximum number of retransmissions for the initial syn segment.
as explained earlier, tcp segments may contain an optional header extension. in the syn and syn+ack segments, these options are used to negotiate some parameters and the utilisation of extensions to the basic tcp speciﬁcation. the ﬁrst parameter which is negotiated during the establishment of a tcp connection is the maximum segment size (mss). the mss is the size of the largest segment that a tcp entity is able to process. according to rfc 879, all tcp implementations must be able to receive tcp segments containing 536 bytes of payload. however, most tcp implementations are able to process larger segments. such tcp implementations use the tcp mss option in the syn/syn+ack segment to indicate the largest segment they are able to process. the mss value indicates the maximum size of the payload of the tcp segments. the client (resp. server) stores in its tcb the mss value announced by the server (resp. the client).
and allows the system administrator to login from this host without giving a password 12. consider now an attacker who knows this particular conﬁguration and is able to send ip packets having the client’s address as source. he can send fake tcp segments to the server, but does not receive the server’s answers. if he can predict the isn that is chosen by the server, he can send a fake syn segment and shortly after the fake ack segment conﬁrming the reception of the syn+ack segment sent by the server. once the tcp connection is open, he can use it to send any command to the server. to counter this attack, current tcp implementations add randomness to the isn. one of the solutions, proposed in rfc 1948 is to compute the isn as
where m is the current value of the tcp clock and h‘is a cryptographic hash function. ‘localhost and remotehost (resp. localport and remoteport ) are the ip addresses (port numbers) of the local and remote host and secret is a random number only known by the server. this method allows the server to use different isns for different clients at the same time. measurements performed with the ﬁrst implementations of this technique showed that it was difﬁcult to implement it correctly, but today’s tcp implementation now generate good isns.
a server could, of course, refuse to open a tcp connection upon reception of a syn segment. this refusal may be due to various reasons. there may be no server process that is listening on the destination port of the syn segment. the server could always refuse connection establishments from this particular client (e.g. due to security reasons) or the server may not have enough resources to accept a new tcp connection at that time. in this case, the server would reply with a tcp segment having its rst ﬂag set and containing the sequence number of the received syn segment as its acknowledgment number. this is illustrated in the ﬁgure below. we discuss the other utilizations of the tcp rst ﬂag later (see tcp connection release).
tcp connection establishment can be described as the four state finite state machine shown below. in this fsm, !x (resp. ?y) indicates the transmission of segment x (resp. reception of segment y) during the corresponding transition. init is the initial state. a client host starts in the init state. it then sends a syn segment and enters the syn sent state where it waits for a syn+ack segment. then, it replies with an ack segment and enters the established state where data can
12 on many departmental networks containing unix workstations, it was common to allow users on one of the hosts to use rlogin rfc 1258 to run commands on any of the workstations of the network without giving any password. in this case, the remote workstation “authenticated” the client host based on its ip address. this was a bad practice from a security viewpoint.
this heuristic requires an additional variable in the tcb (dupacks). most implementations set the default number of duplicate acknowledgements that trigger a retransmission to 3. it is now part of the standard tcp speciﬁcation rfc 2581. the fast retransmit heuristic improves the tcp performance provided that isolated segments are lost and the current window is large enough to allow the sender to send three duplicate acknowledgements. the ﬁgure below illustrates the operation of the fast retransmit heuristic.
when losses are not isolated or when the windows are small, the performance of the fast retransmit heuristic decreases. in such environments, it is necessary to allow a tcp sender to use a selective repeat strategy instead of the default go-back-n strategy. implementing selective-repeat requires a change to the tcp protocol as the receiver needs to be able to inform the sender of the out-of-order segments that it has already received. this can be done by using the selective acknowledgements (sack) option deﬁned in rfc 2018. this tcp option is
this heuristic requires an additional variable in the tcb (dupacks). most implementations set the default number of duplicate acknowledgements that trigger a retransmission to 3. it is now part of the standard tcp speciﬁcation rfc 2581. the fast retransmit heuristic improves the tcp performance provided that isolated segments are lost and the current window is large enough to allow the sender to send three duplicate acknowledgements. the ﬁgure below illustrates the operation of the fast retransmit heuristic.
when losses are not isolated or when the windows are small, the performance of the fast retransmit heuristic decreases. in such environments, it is necessary to allow a tcp sender to use a selective repeat strategy instead of the default go-back-n strategy. implementing selective-repeat requires a change to the tcp protocol as the receiver needs to be able to inform the sender of the out-of-order segments that it has already received. this can be done by using the selective acknowledgements (sack) option deﬁned in rfc 2018. this tcp option is
negotiated during the establishment of a tcp connection. if both tcp hosts support the option, sack blocks can be attached by the receiver to the segments that it sends. sack blocks allow a tcp receiver to indicate the blocks of data that it has received correctly but out of sequence. the ﬁgure below illustrates the utilisation of the sack blocks.
an sack option contains one or more blocks. a block corresponds to all the sequence numbers between the left edge and the right edge of the block. the two edges of the block are encoded as 32 bit numbers (the same size as the tcp sequence number) in an sack option. as the sack option contains one byte to encode its type and one byte for its length, a sack option containing b blocks is encoded as a sequence of 2 + 8 × b bytes. in practice, the size of the sack option can be problematic as the optional tcp header extension cannot be longer than 44 bytes. as the sack option is usually combined with the rfc 1323 timestamp extension, this implies that a tcp segment cannot usually contain more than three sack blocks. this limitation implies that a tcp receiver cannot always place in the sack option that it sends, information about all the received blocks. to deal with the limited size of the sack option, a tcp receiver currently having more than 3 blocks inside its receiving buffer must select the blocks to place in the sack option. a good heuristic is to put in the sack option the blocks that have most recently changed, as the sender is likely to be already aware of the older blocks. when a sender receives an sack option indicating a new block and thus a new possible segment loss, it usually does not retransmit the missing segment(s immediately. to deal with reordering, a tcp sender can use a heuristic similar to fast retransmit by retransmitting a gap only once it has received three sack options indicating this gap. it should be noted that the sack option does not supersede the acknowledgement number of the tcp header. a tcp sender can only remove data from its sending buffer once they have been acknowledged by tcp’s cumulative acknowledgements. this design was chosen for two reasons. first, it allows the receiver to discard parts of its receiving buffer when it is running out of memory without loosing data. second, as the sack option is not transmitted reliably, the cumulative acknowledgements are still required to deal with losses of ack segments carrying only sack information. thus, the sack option only serves as a hint to allow the sender to optimise its retransmissions.
in the previous sections, we have explained the mechanisms that tcp uses to deal with transmission errors and segment losses. in a heterogeneous network such as the internet or enterprise ip networks, endsystems have very different levels of performance. some endsystems are high-end servers attached to 10 gbps links while others are mobile devices attached to a very low bandwidth wireless link. despite these huge differences in performance, a mobile device should be able to efﬁciently exchange segments with a high-end server. to understand this problem better, let us consider the scenario shown in the ﬁgure below, where a server (a)
destination (resp. source) port of the segments sent by the client (see ﬁgure utilization of the tcp source and destination ports). a tcp connection is always identiﬁed by ﬁve pieces of information :
• the sequence number (32 bits), acknowledgement number (32 bits) and window (16 bits) ﬁelds are used to provide a reliable data transfer, using a window-based protocol. in a tcp bytestream, each byte of the stream consumes one sequence number. their utilisation will be described in more detail in section tcp reliable data transfer
• the urgent pointer is used to indicate that some data should be considered as urgent in a tcp bytestream. however, it is rarely used in practice and will not be described here. additional details about the utilisation of this pointer may be found in rfc 793, rfc 1122 or [stevens1994]
– the syn ﬂag is used during connection establishment – the fin ﬂag is used during connection release – the rst is used in case of problems or when an invalid segment has been received – when the ack ﬂag is set, it indicates that the acknowledgment ﬁeld contains a valid number. other-
– the urg ﬂag is used together with the urgent pointer – the psh ﬂag is used as a notiﬁcation from the sender to indicate to the receiver that it should pass all the data it has received to the receiving process. however, in practice tcp implementations do not allow tcp users to indicate when the psh ﬂag should be set and thus there are few real utilizations of this ﬂag.
• the reserved ﬁeld was initially reserved for future utilization. it is now used by rfc 3168. • the tcp header length (thl) or data offset ﬁeld is a four bits ﬁeld that indicates the size of the tcp
• the optional header extension is used to add optional information to the tcp header. thanks to this header extension, it is possible to add new ﬁelds to the tcp header that were not planned in the original speciﬁcation. this allowed tcp to evolve since the early eighties. the details of the tcp header extension are explained in sections tcp connection establishment and tcp reliable data transfer.
the rest of this section is organised as follows. we ﬁrst explain the establishment and the release of a tcp connection, then we discuss the mechanisms that are used by tcp to provide a reliable bytestream service. we end the section with a discussion of network congestion and explain the mechanisms that tcp uses to avoid congestion collapse.
a tcp connection is established by using a three-way handshake. the connection establishment phase uses the sequence number, the acknowledgment number and the syn ﬂag. when a tcp connection is established, the two communicating hosts negotiate the initial sequence number to be used in both directions of the connection. for this, each tcp entity maintains a 32 bits counter, which is supposed to be incremented by one at least every 4
destination (resp. source) port of the segments sent by the client (see ﬁgure utilization of the tcp source and destination ports). a tcp connection is always identiﬁed by ﬁve pieces of information :
• the sequence number (32 bits), acknowledgement number (32 bits) and window (16 bits) ﬁelds are used to provide a reliable data transfer, using a window-based protocol. in a tcp bytestream, each byte of the stream consumes one sequence number. their utilisation will be described in more detail in section tcp reliable data transfer
• the urgent pointer is used to indicate that some data should be considered as urgent in a tcp bytestream. however, it is rarely used in practice and will not be described here. additional details about the utilisation of this pointer may be found in rfc 793, rfc 1122 or [stevens1994]
– the syn ﬂag is used during connection establishment – the fin ﬂag is used during connection release – the rst is used in case of problems or when an invalid segment has been received – when the ack ﬂag is set, it indicates that the acknowledgment ﬁeld contains a valid number. other-
– the urg ﬂag is used together with the urgent pointer – the psh ﬂag is used as a notiﬁcation from the sender to indicate to the receiver that it should pass all the data it has received to the receiving process. however, in practice tcp implementations do not allow tcp users to indicate when the psh ﬂag should be set and thus there are few real utilizations of this ﬂag.
• the reserved ﬁeld was initially reserved for future utilization. it is now used by rfc 3168. • the tcp header length (thl) or data offset ﬁeld is a four bits ﬁeld that indicates the size of the tcp
• the optional header extension is used to add optional information to the tcp header. thanks to this header extension, it is possible to add new ﬁelds to the tcp header that were not planned in the original speciﬁcation. this allowed tcp to evolve since the early eighties. the details of the tcp header extension are explained in sections tcp connection establishment and tcp reliable data transfer.
the rest of this section is organised as follows. we ﬁrst explain the establishment and the release of a tcp connection, then we discuss the mechanisms that are used by tcp to provide a reliable bytestream service. we end the section with a discussion of network congestion and explain the mechanisms that tcp uses to avoid congestion collapse.
a tcp connection is established by using a three-way handshake. the connection establishment phase uses the sequence number, the acknowledgment number and the syn ﬂag. when a tcp connection is established, the two communicating hosts negotiate the initial sequence number to be used in both directions of the connection. for this, each tcp entity maintains a 32 bits counter, which is supposed to be incremented by one at least every 4
network-byte order internet protocol allow to transport sequences of bytes. these sequences of bytes are sufﬁcient to carry ascii characters. the network-byte order refers to the big-endian encoding for 16 and 32 bits integer. see http://en.wikipedia.org/wiki/endianness
nfs the network file system is deﬁned in rfc 1094 ntp the network time protocol is deﬁned in rfc 1305 osi open systems interconnection. a set of networking standards developed by iso including the 7 layers osi
isp networks. ospf is deﬁned in and rfc 2328 and rfc 5340 packet a packet is the unit of information transfer in the network layer pbl problem-based learning is a teaching approach that relies on problems. pop the post ofﬁce protocol is deﬁned in rfc 1939 pop the post ofﬁce protocol (pop), deﬁned rfc 1939, is an application-level protocol that allows a client to
resolver a server that implements the dns protocol and can resolve queries. a resolver usually serves a set of clients (e.g. all hosts in campus or all clients of a given isp). it sends dns queries to nameservers everywhere on behalf of its clients and stores the received answers in its cache. a resolver must know the ip addresses of the root nameservers.
rir regional internet registry. an organisation that manages ip addresses and as numbers on behalf of iana. root nameserver a name server that is responsible for the root of the domain names hierarchy. there are currently a dozen root nameservers and each dns resolver see http://www.root-servers.org/ for more information about the operation of these root servers.
router a relay operating in the network layer. rpc several types of remote procedure calls have been deﬁned. the rpc mechanism deﬁned in rfc 5531 is
sdu (service data unit) a service data unit is the unit information transferred between applications segment a segment is the unit of information transfer in the transport layer smtp the simple mail transfer protocol is deﬁned in rfc 821 snmp the simple network management protocol is a management protocol deﬁned for tcp/ip networks. socket a low-level api originally deﬁned on berkeley unix to allow programmers to develop clients and servers. spoofed packet a packet is said to be spoofed when the sender of the packet has used as source address a
ssh the secure shell (ssh) transport layer protocol is deﬁned in rfc 4253 standard query for dns servers and resolvers, a standard query is a query for a a or a aaaa record. such a
switch a relay operating in the datalink layer. syn cookie the syn cookies is a technique used to compute the initial sequence number (isn) tcb the transmission control block is the set of variables that are maintained for each established tcp con-
contains information about its origin and its destination, and usually passes through several intermediate devices called routers on its way from its origin to its destination.
most realisations of the network layer, including the internet, do not provide a reliable service. however, many applications need to exchange information reliably and so using the network layer service directly would be very difﬁcult for them. ensuring the reliable delivery of the data produced by applications is the task of the transport layer. transport layer entities exchange segments. a segment is a ﬁnite sequence of bytes that are transported inside one or more packets. a transport layer entity issues segments (or sometimes part of segments) as data.request to the underlying network layer entity. there are different types of transport layers. the most widely used transport layers on the internet are tcp ,that provides a reliable connection-oriented bytestream transport service, and udp ,that provides an unreliable connection-less transport service.
the upper layer of our architecture is the application layer. this layer includes all the mechanisms and data structures that are necessary for the applications. we will use application data unit (adu) to indicate the data exchanged between two entities of the application layer.
in contrast with osi, the tcp/ip community did not spend a lot of effort deﬁning a detailed reference model; in fact, the goals of the internet architecture were only documented after tcp/ip had been deployed [clark88]. rfc 1122 , which deﬁnes the requirements for internet hosts, mentions four different layers. starting from the top, these are :
• an application layer • a transport layer • an internet layer which is equivalent to the network layer of our reference model • a link layer which combines the functionalities of the physical and datalink layers of our ﬁve-layer reference
physical layerdatalinknetworkphysical layerdatalinknetworkphysical layerdatalinknetworkpacketspacketsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportsegmentsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportaduapplicationapplicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
the as-level topology of the internet. [coz2008] and [dkf+2007] based on these studies and [atlas2009], the as-level internet topology can be summarised as shown in the ﬁgure below.
• the core of the internet is composed of a dozen-twenty tier-1 isps. a tier-1 is a domain that has no provider. such an isp has shared-cost peering relationships with all other tier-1 isps and provider->customer relationships with smaller isps. examples of tier-1 isps include sprint, level3 or opentransit
• the tier-2 isps are national or continental isps that are customers of tier-1 isps. these tier-2 isps have smaller customers and shared-cost peering relationships with other tier-2 isps. example of tier-2 isps include france telecom, belgacom, british telecom, ...
• the tier-3 networks are either stub domains such as enterprise or campus networks networks and smaller isps. they are customers of tier-1 and tier-2 isps and have sometimes shared-cost peering relationships • the large content providers that are managing large datacenters. these content providers are producing a growing fraction of the packets exchanged on the global internet [atlas2009]. some of these content providers are customers of tier-1 or tier-2 isps, but they often try to establish shared-cost peering relationships, e.g. at ixps, with many tier-1 and tier-2 isps.
occur. in optical networks, a variant of fdm called wavelength division multiplexing (wdm) can be used. an optical ﬁber can transport light at different wavelengths without interference. with wdm, a different wavelength is allocated to each of the devices that share the same optical ﬁber. time division multiplexing (tdm) is a static bandwidth allocation method that was initially deﬁned for the telephone network. in the ﬁxed telephone network, a voice conversation is usually transmitted as a 64 kbps signal. thus, a telephone conservation generates 8 kbytes per second or one byte every 125 microsecond. telephone conversations often need to be multiplexed together on a single line. for example, in europe, thirty 64 kbps voice signals are multiplexed over a single 2 mbps (e1) line. this is done by using time division multiplexing (tdm). tdm divides the transmission opportunities into slots. in the telephone network, a slot corresponds to 125 microseconds. a position inside each slot is reserved for each voice signal. the ﬁgure below illustrates tdm on a link that is used to carry four voice conversations. the vertical lines represent the slot boundaries and the letters the different voice conversations. one byte from each voice conversation is sent during each 125 microsecond slot. the byte corresponding to a given conversation is always sent at the same position in each slot.
tdm as shown above can be completely static, i.e. the same conversations always share the link, or dynamic. in the latter case, the two endpoints of the link must exchange messages specifying which conversation uses which byte inside each slot. thanks to these signalling messages, it is possible to dynamically add and remove voice conversations from a given link. tdm and fdm are widely used in telephone networks to support ﬁxed bandwidth conversations. using them in local area networks that support computers would probably be inefﬁcient. computers usually do not send information at a ﬁxed rate. instead, they often have an on-off behaviour. during the on period, the computer tries to send at the highest possible rate, e.g. to transfer a ﬁle. during the off period, which is often much longer than the on period, the computer does not transmit any packet. using a static allocation scheme for computers attached to a lan would lead to huge inefﬁciencies, as they would only be able to transmit at 1 n of the total bandwidth during their on period, despite the fact that the other computers are in their off period and thus do not need to transmit any information. the dynamic mac algorithms discussed in the remainder of this chapter aim solve this problem.
in the 1960s, computers were mainly mainframes with a few dozen terminals attached to them. these terminals were usually in the same building as the mainframe and were directly connected to it. in some cases, the terminals were installed in remote locations and connected through a modem attached to a dial-up line. the university of hawaii chose a different organisation. instead of using telephone lines to connect the distant terminals, they developed the ﬁrst packet radio technology [abramson1970]. until then, computer networks were built on top of either the telephone network or physical cables. alohanet showed that it was possible to use radio signals to interconnect computers. the ﬁrst version of alohanet, described in [abramson1970], operated as follows: first, the terminals and the mainframe exchanged ﬁxed-length frames composed of 704 bits. each frame contained 80 8-bit characters, some control bits and parity information to detect transmission errors. two channels in the 400 mhz range were reserved for the operation of alohanet. the ﬁrst channel was used by the mainframe to send frames to all terminals. the second channel was shared among all terminals to send frames to the mainframe. as all terminals share the same transmission channel, there is a risk of collision. to deal with this problem as well as transmission errors, the mainframe veriﬁed the parity bits of the received frame and sent an acknowledgement on its channel for each correctly received frame. the terminals on the other hand had to retransmit the unacknowledged frames. as for tcp, retransmitting these frames immediately upon expiration of a ﬁxed timeout is not a good approach as several terminals may retransmit their frames at the same time leading to a network collapse. a better approach, but still far from perfect, is for each terminal to wait a random amount of time after the expiration of its retransmission timeout. this avoids synchronisation among multiple retransmitting terminals.
• 127.0.0.0/8, which is reserved for loopback addresses. each host implementing ipv4 must have a loopback interface (that is not attached to a datalink layer). by convention, ipv4 address 127.0.0.1 is assigned to this interface. this allows processes running on a host to use tcp/ip to contact other processes running on the same host. this can be very useful for testing purposes.
now that we have clariﬁed the allocation of ipv4 addresses and the utilisation of the longest preﬁx match to forward ipv4 packets, we can have a more detailed look at ipv4 by starting with the format of the ipv4 packets. the ipv4 packet format was deﬁned in rfc 791. apart from a few clariﬁcations and some backward compatible changes, the ipv4 packet format did not change signiﬁcantly since the publication of rfc 791. all ipv4 packets use the 20 bytes header shown below. some ipv4 packets contain an optional header extension that is described later.
• a 4 bits ip header length (ihl) that indicates the length of the ip header in 32 bits words. this ﬁeld allows ipv4 to use options if required, but as it is encoded as a 4 bits ﬁeld, the ipv4 header cannot be longer than 64 bytes.
• an 8 bits ds ﬁeld that is used for quality of service and whose usage is described later. • an 8 bits protocol ﬁeld that indicates the transport layer protocol that must process the packet’s payload at
• a 32 bits source address ﬁeld that contains the ipv4 address of the source host • a 32 bits destination address ﬁeld that contains the ipv4 address of the destination host • a 16 bits checksum that protects only the ipv4 header against transmission errors
the other ﬁelds of the ipv4 header are used for speciﬁc purposes. the ﬁrst is the 8 bits time to live (ttl) ﬁeld. this ﬁeld is used by ipv4 to avoid the risk of having an ipv4 packet caught in an inﬁnite loop due to a transient
throughout this book, we will deﬁne a service as a set of capabilities provided by a system (and its underlying elements) to its user. a user interacts with a service through a service access point. note that as shown in the ﬁgure above, users interact with one service provider. in practice, the service provider is distributed over several hosts, but these are implementation details that are not important at this stage. these interactions between a user and a service provider are expressed in [x200] by using primitives, as show in the ﬁgure below. these primitives are an abstract representation of the interactions between a user and a service provider. in practice, these interactions could be implemented as system calls for example.
• x.request. this type of primitive corresponds to a request issued by a user to a service provider • x.indication. this type of primitive is generated by the network provider and delivered to a user (often
• x.response. this type of primitive is generated by a user to answer to an earlier x.indication primitive • x.conﬁrm. this type of primitive is delivered by the service provide to conﬁrm to a user that a previous
primitives can be combined to model different types of services. the simplest service in computer networks is called the connectionless service 3. this service can be modelled by using two primitives :
• data.request(source,destination,sdu). this primitive is issued by a user that speciﬁes, as parameters, its (source) address, the address of the recipient of the message and the message itself. we will use service data unit (sdu) to name the message that is exchanged transparently between two users of a service. • data.indication(source,destination,sdu). this primitive is delivered by a service provider to a user.
it contains as parameters a service data unit as well as the addresses of the sender and the destination users. when discussing the service provided in a computer network, it is often useful to be able to describe the interactions between the users and the provider graphically. a frequently used representation is the time-sequence diagram. in this chapter and later throughout the book, we will often use diagrams such as the ﬁgure below. a time-sequence diagram describes the interactions between two users and a service provider. by convention, the users are represented in the left and right parts of the diagram while the service provider occupies the middle of the diagram. in such a time-sequence diagram, time ﬂows from the top, to the bottom of the diagram. each primitive
user auser bservice provider ("the network")service access pointprimitivesuser auser bservice provider ("the network")x.indicationx.responsex.confirmx.requestsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
must forward the entire delimiter to its downstream neighbour. it is only when it receives the fourth bit of the access control ﬁeld (i.e. the token bit) that the station knows whether the frame is a data frame or a token. if the token bit is reset, it indicates a data frame and the remaining bits of the data frame must be forwarded to the downstream station. otherwise (token bit is set), this is a token and the station can capture it by resetting the bit that is currently in its buffer. thanks to this modiﬁcation, the beginning of the token is now the beginning of a data frame and the station can switch to transmit mode and send its data frame starting at the ﬁfth bit of the access control ﬁeld. thus, the one-bit delay introduced by each token ring station plays a key role in enabling the stations to efﬁciently capture the token. after having transmitted its data frame, the station must remain in transmit mode until it has received the last bit of its own data frame. this ensures that the bits sent by a station do not remain in the network forever. a data frame sent by a station in a token ring network passes in front of all stations attached to the network. each station can detect the data frame and analyse the destination address to possibly capture the frame. the frame status ﬁeld that appears after the ending delimiter is used to provide acknowledgements without requiring special frames. the frame status contains two ﬂags : a and c. both ﬂags are reset when a station sends a data frame. these ﬂags can be modiﬁed by their recipients. when a station senses its address as the destination address of a frame, it can capture the frame, check its crc and place it in its own buffers. the destination of a frame must set the a bit (resp. c bit) of the frame status ﬁeld once it has seen (resp. copied) a data frame. by inspecting the frame status of the returning frame, the sender can verify whether its frame has been received correctly by its destination. the text above describes the basic operation of a token ring network when all stations work correctly. unfortunately, a real token ring network must be able to handle various types of anomalies and this increases the complexity of token ring stations. we brieﬂy list the problems and outline their solutions below. a detailed description of the operation of token ring stations may be found in [802.5]. the ﬁrst problem is when all the stations attached to the network start. one of them must bootstrap the network by sending the ﬁrst token. for this, all stations implement a distributed election mechanism that is used to select the monitor. any station can become a monitor. the monitor manages the token ring network and ensures that it operates correctly. its ﬁrst role is to introduce a delay of 24 bit transmission times to ensure that the token can travel smoothly on the ring. second, the monitor sends the ﬁrst token on the ring. it must also verify that the token passes regularly. according to the token ring standard [802.5], a station cannot retain the token to transmit data frames for a duration longer than the token holding time (tht) (slightly less than 10 milliseconds). on a network containing n stations, the monitor must receive the token at least every n × t ht seconds. if the monitor does not receive a token during such a period, it cuts the ring for some time and then reinitialises the ring and sends a token. several other anomalies may occur in a token ring network. for example, a station could capture a token and be powered off before having resent the token. another station could have captured the token, sent its data frame and be powered off before receiving all of its data frame. in this case, the bit string corresponding to the end of a frame would remain in the ring without being removed by its sender. several techniques are deﬁned in [802.5] to allow the monitor to handle all these problems. if unfortunately, the monitor fails, another station will be elected to become the new monitor.
in this section, we review the key characteristics of several datalink layer technologies. we discuss in more detail the technologies that are widely used today. a detailed survey of all datalink layer technologies would be outside the scope of this book.
many point-to-point datalink layers 2 have been developed, starting in the 1960s [mcfadyen1976]. in this section, we focus on the protocols that are often used to transport ip packets between hosts or routers that are directly connected by a point-to-point link. this link can be a dedicated physical cable, a leased line through the telephone network or a dial-up connection with modems on the two communicating hosts.
the ﬁrst problem faced by a token ring network is that as the token represents the authorization to transmit, it must continuously travel on the ring when no data frame is being transmitted. let us assume that a token has been produced and sent on the ring by one station. in token ring networks, the token is a 24 bits frame whose structure is shown below.
the token is composed of three ﬁelds. first, the starting delimiter is the marker that indicates the beginning of a frame. the ﬁrst token ring networks used manchester coding and the starting delimiter contained both symbols representing 0 and symbols that do not represent bits. the last ﬁeld is the ending delimiter which marks the end of the token. the access control ﬁeld is present in all frames, and contains several ﬂags. the most important is the token bit that is set in token frames and reset in other frames. let us consider the ﬁve station network depicted in ﬁgure a token ring network above and assume that station s1 sends a token. if we neglect the propagation delay on the inter-station links, as each station introduces a one bit delay, the ﬁrst bit of the frame would return to s1 while it sends the ﬁfth bit of the token. if station s1 is powered off at that time, only the ﬁrst ﬁve bits of the token will travel on the ring. to avoid this problem, there is a special station called the monitor on each token ring. to ensure that the token can travel forever on the ring, this monitor inserts a delay that is equal to at least 24 bit transmission times. if station s3 was the monitor in ﬁgure a token ring network, s1 would have been able to transmit the entire token before receiving the ﬁrst bit of the token from its upstream neighbour. now that we have explained how the token can be forwarded on the ring, let us analyse how a station can capture a token to transmit a data frame. for this, we need some information about the format of the data frames. an 802.5 data frame begins with the starting delimiter followed by the access control ﬁeld whose token bit is reset, a frame control ﬁeld that allows for the deﬁnition of several types of frames, destination and source address, a payload, a crc, the ending delimiter and a frame status ﬁeld. the format of the token ring data frames is illustrated below.
to capture a token, a station must operate in listen mode. in this mode, the station receives bits from its upstream neighbour. if the bits correspond to a data frame, they must be forwarded to the downstream neighbour. if they correspond to a token, the station can capture it and transmit its data frame. both the data frame and the token are encoded as a bit string beginning with the starting delimiter followed by the access control ﬁeld. when the station receives the ﬁrst bit of a starting delimiter, it cannot know whether this is a data frame or a token and
the ﬁrst problem faced by a token ring network is that as the token represents the authorization to transmit, it must continuously travel on the ring when no data frame is being transmitted. let us assume that a token has been produced and sent on the ring by one station. in token ring networks, the token is a 24 bits frame whose structure is shown below.
the token is composed of three ﬁelds. first, the starting delimiter is the marker that indicates the beginning of a frame. the ﬁrst token ring networks used manchester coding and the starting delimiter contained both symbols representing 0 and symbols that do not represent bits. the last ﬁeld is the ending delimiter which marks the end of the token. the access control ﬁeld is present in all frames, and contains several ﬂags. the most important is the token bit that is set in token frames and reset in other frames. let us consider the ﬁve station network depicted in ﬁgure a token ring network above and assume that station s1 sends a token. if we neglect the propagation delay on the inter-station links, as each station introduces a one bit delay, the ﬁrst bit of the frame would return to s1 while it sends the ﬁfth bit of the token. if station s1 is powered off at that time, only the ﬁrst ﬁve bits of the token will travel on the ring. to avoid this problem, there is a special station called the monitor on each token ring. to ensure that the token can travel forever on the ring, this monitor inserts a delay that is equal to at least 24 bit transmission times. if station s3 was the monitor in ﬁgure a token ring network, s1 would have been able to transmit the entire token before receiving the ﬁrst bit of the token from its upstream neighbour. now that we have explained how the token can be forwarded on the ring, let us analyse how a station can capture a token to transmit a data frame. for this, we need some information about the format of the data frames. an 802.5 data frame begins with the starting delimiter followed by the access control ﬁeld whose token bit is reset, a frame control ﬁeld that allows for the deﬁnition of several types of frames, destination and source address, a payload, a crc, the ending delimiter and a frame status ﬁeld. the format of the token ring data frames is illustrated below.
to capture a token, a station must operate in listen mode. in this mode, the station receives bits from its upstream neighbour. if the bits correspond to a data frame, they must be forwarded to the downstream neighbour. if they correspond to a token, the station can capture it and transmit its data frame. both the data frame and the token are encoded as a bit string beginning with the starting delimiter followed by the access control ﬁeld. when the station receives the ﬁrst bit of a starting delimiter, it cannot know whether this is a data frame or a token and
the ﬁrst problem faced by a token ring network is that as the token represents the authorization to transmit, it must continuously travel on the ring when no data frame is being transmitted. let us assume that a token has been produced and sent on the ring by one station. in token ring networks, the token is a 24 bits frame whose structure is shown below.
the token is composed of three ﬁelds. first, the starting delimiter is the marker that indicates the beginning of a frame. the ﬁrst token ring networks used manchester coding and the starting delimiter contained both symbols representing 0 and symbols that do not represent bits. the last ﬁeld is the ending delimiter which marks the end of the token. the access control ﬁeld is present in all frames, and contains several ﬂags. the most important is the token bit that is set in token frames and reset in other frames. let us consider the ﬁve station network depicted in ﬁgure a token ring network above and assume that station s1 sends a token. if we neglect the propagation delay on the inter-station links, as each station introduces a one bit delay, the ﬁrst bit of the frame would return to s1 while it sends the ﬁfth bit of the token. if station s1 is powered off at that time, only the ﬁrst ﬁve bits of the token will travel on the ring. to avoid this problem, there is a special station called the monitor on each token ring. to ensure that the token can travel forever on the ring, this monitor inserts a delay that is equal to at least 24 bit transmission times. if station s3 was the monitor in ﬁgure a token ring network, s1 would have been able to transmit the entire token before receiving the ﬁrst bit of the token from its upstream neighbour. now that we have explained how the token can be forwarded on the ring, let us analyse how a station can capture a token to transmit a data frame. for this, we need some information about the format of the data frames. an 802.5 data frame begins with the starting delimiter followed by the access control ﬁeld whose token bit is reset, a frame control ﬁeld that allows for the deﬁnition of several types of frames, destination and source address, a payload, a crc, the ending delimiter and a frame status ﬁeld. the format of the token ring data frames is illustrated below.
to capture a token, a station must operate in listen mode. in this mode, the station receives bits from its upstream neighbour. if the bits correspond to a data frame, they must be forwarded to the downstream neighbour. if they correspond to a token, the station can capture it and transmit its data frame. both the data frame and the token are encoded as a bit string beginning with the starting delimiter followed by the access control ﬁeld. when the station receives the ﬁrst bit of a starting delimiter, it cannot know whether this is a data frame or a token and
another very useful debugging tool is traceroute(8). the traceroute man page describes this tool as “print the route packets take to network host”. traceroute uses the ttl exceeded icmp messages to discover the intermediate routers on the path towards a destination. the principle behind traceroute is very simple. when a router receives an ip packet whose ttl is set to 1 it decrements the ttl and is forced to return to the sending host a ttl exceeded icmp message containing the header and the ﬁrst bytes of the discarded ip packet. to discover all routers on a network path, a simple solution is to ﬁrst send a packet whose ttl is set to 1, then a packet whose ttl is set to 2, etc. a sample traceroute output is shown below.
cshalles3.sri.ucl.ac.be (192.168.251.230) cthalles.sri.ucl.ac.be (192.168.251.229) ctpythagore.sri.ucl.ac.be (130.104.254.230) fe.m20.access.lln.belnet.net (193.191.11.9) 10ge.cr2.brueve.belnet.net (193.191.16.22) 212.3.237.13 (212.3.237.13) 5.347 ms ae-11-11.car1.brussels1.level3.net (4.69.136.249) ae-6-6.ebr1.london1.level3.net (4.69.136.246) ae-100-100.ebr2.london1.level3.net (4.69.141.166)
ae-41-41.ebr1.newyork1.level3.net (4.69.137.66) ae-43-43.ebr1.newyork1.level3.net (4.69.137.74) ae-42-42.ebr1.newyork1.level3.net (4.69.137.70) ae-2-2.ebr1.newark1.level3.net (4.69.132.98) ae-14-51.car4.newark1.level3.net (4.68.99.8) ex1-tg2-0.eqnwnj.sbcglobal.net (151.164.89.249) 151.164.95.190 (151.164.95.190) ded-p10-0.pltn13.sbcglobal.net (151.164.191.243) ams-1152322.cust-rtr.swbell.net (75.61.192.10) mail.ietf.org (64.170.98.32) 158.427 ms
the above traceroute(8) output shows a 17 hops path between a host at uclouvain and one of the main ietf servers. for each hop, traceroute provides the ipv4 address of the router that sent the icmp message and the measured round-trip-time between the source and this router. traceroute sends three probes with each ttl value. in some cases, such as at the 10th hop above, the icmp messages may be received from different addresses. this is usually because different packets from the same source have followed different paths 11 in the network. another important utilisation of icmp messages is to discover the maximum mtu that can be used to reach a destination without fragmentation. as explained earlier, when an ipv4 router receives a packet that is larger than the mtu of the outgoing link, it must fragment the packet. unfortunately, fragmentation is a complex operation and routers cannot perform it at line rate [km1995]. furthermore, when a tcp segment is transported in an ip packet that is fragmented in the network, the loss of a single fragment forces tcp to retransmit the entire segment (and thus all the fragments). if tcp was able to send only packets that do not require fragmentation in the network, it could retransmit only the information that was lost in the network. in addition, ip reassembly causes several challenges at high speed as discussed in rfc 4963. using ip fragmentation to allow udp applications to exchange large messages raises several security issues [kps2003]. icmp, combined with the don’t fragment (df) ipv4 ﬂag, is used by tcp implementations to discover the largest mtu size that is allowed to reach a destination host without causing network fragmentation. this is the path mtu discovery mechanism deﬁned in rfc 1191. a tcp implementation that includes path mtu discovery (most do) requests the ipv4 layer to send all segments inside ipv4 packets having the df ﬂag set. this prohibits intermediate routers from fragmenting these packets. if a router needs to forward an unfragmentable packet over a link with a smaller mtu, it returns a fragmentation needed icmp message to the source, indicating the mtu of its outgoing link. this icmp message contains in the mtu of the router’s outgoing link in its data ﬁeld. upon reception of this icmp message, the source tcp implementation adjusts its maximum segment size (mss) so that the packets containing the segments that it sends can be forwarded by this router without requiring fragmentation.
• 2 : packet too big. the router that was to send the icmpv6 message received an ipv6 packet that is larger than the mtu of the outgoing link. the icmpv6 message contains the mtu of this link in bytes. this allows the sending host to implement path mtu discovery rfc 1981
• 3 : time exceeded. this error message can be sent either by a router or by a host. a router would set code to 0 to report the reception of a packet whose hop limit reached 0. a host would set code to 1 to report that it was unable to reassemble received ipv6 fragments.
• 4 : parameter problem. this icmpv6 message is used to report either the reception of an ipv6 packet with an erroneous header ﬁeld (type 0) or an unknown next header or ip option (types 1 and 2). in this case, the message body contains the erroneous ipv6 packet and the ﬁrst 32 bits of the message body contain a pointer to the error.
two types of informational icmpv6 messages are deﬁned in rfc 4443 : echo request and echo reply, which are used to test the reachability of a destination by using ping6(8). icmpv6 also allows the discovery of the path between a source and a destination by using traceroute6(8). the output below shows a traceroute between a host at uclouvain and one of the main ietf servers. note that this ipv6 path is different than the ipv4 path that was described earlier although the two traceroutes were performed at the same time.
2001:6a8:3080:2::1 13.821 ms 2001:6a8:3000:8000::1 0.651 ms 10ge.cr2.bruvil.belnet.net 3.402 ms 10ge.cr2.brueve.belnet.net 3.668 ms 10ge.cr2.brueve.belnet.net belnet.rt1.ams.nl.geant2.net 10.598 ms so-7-0-0.rt2.cop.dk.geant2.net kbn-ipv6-b1.ipv6.telia.net 21.078 ms s-ipv6-b1-link.ipv6.telia.net 31.312 ms s-ipv6-b1-link.ipv6.telia.net 61.986 ms
note: rate limitation of icmp messages high-end hardware based routers use special purpose chips on their interfaces to forward ipv6 packets at line rate. these chips are optimised to process correct ip packets. they are not able to create icmp messages at line rate. when such a chip receives an ip packet that triggers an icmp message, it interrupts the main cpu of the router and the software running on this cpu processes the packet. this cpu is much slower than the hardware acceleration found on the interfaces [gill2004]. it would be overloaded if it had to process ip packets at line rate and generate one icmp message for each received packet. to protect this cpu, high-end routers limit the rate at which the hardware can interrupt the main cpu and thus the rate at which icmp messages can be generated. this implies that not all erroneous ip packets cause the transmission of an icmp message. the risk of overloading the main cpu of the router is also the reason why using hop-by-hop ipv6 options, including the router alter option is discouraged 20.
a ﬁrst solution to support such a lan with a link-state routing protocol would be to consider that a lan is equivalent to a full-mesh of point-to-point links as if each router can directly reach any other router on the lan. however, this approach has two important drawbacks :
2. remote routers, when looking at the topology distributed by ospf, consider that there is a full-mesh of links between all the lan routers. such a full-mesh implies a lot of redundancy in case of failure, while in practice the entire lan may completely fail. in case of a failure of the entire lan, all routers need to detect the failures and ﬂood link state packets before the lan is completely removed from the ospf topology by remote routers.
to better represent lans and reduce the number of ospf packets that are exchanged, ospf handles lan differently. when ospf routers boot on a lan, they elect 24 one of them as the designated router (dr) rfc 2328. the dr router represents the local area network, and advertises the lan’s subnet (138.48.4.0/24 in the example above). furthermore, lan routers only exchange hello packets with the dr. thanks to the utilisation of a dr, the topology of the lan appears as a set of point-to-point links connected to the dr as shown in the ﬁgure below.
note: how to quickly detect a link failure ? network operators expect an ospf network to be able to quickly recover from link or router failures [vpd2004]. in an ospf network, the recovery after a failure is performed in three steps [ffeb2005] :
• the routers that are adjacent to the failure detect it quickly. the default solution is to rely on the regular exchange of hello packets. however, the interval between successive hellos is often set to 10 seconds... setting the hello timer down to a few milliseconds is difﬁcult as hello packets are created and processed by the main cpu of the routers and these routers cannot easily generate and process a hello packet every millisecond on each of their interfaces. a better solution is to use a dedicated failure detection protocol such as the bidirectional forwarding detection (bfd) protocol deﬁned in [kw2009] that can be implemented directly on the router interfaces. another solution to be able to detect the failure is to instrument the physical and the datalink layer so that they can interrupt the router when a link fails. unfortunately, such a solution cannot be used on all types of physical and datalink layers.
as explained earlier, the internet is composed of more than 30,000 different networks 25 called domains. each domain is composed of a group of routers and hosts that are managed by the same organisation. example domains include belnet, sprint, level3, geant, abilene, cisco or google ...
the corresponding tcb. after having sent the last ack segment, a tcp connection enters the time_wait and remains in this state for 2 ∗ m sl seconds. during this period, the tcb of the connection is maintained. this ensures that the tcp entity that sent the last ack maintains enough state to be able to retransmit this segment if this ack segment is lost and the remote host retransmits its last fin segment or another one. the delay of 2 ∗ m sl seconds ensures that any duplicate segments on the connection would be handled correctly without causing the transmission of an rst segment. without the time_wait state and the 2 ∗ m sl seconds delay, the connection release would not be graceful when the last ack segment is lost.
note: time_wait on busy tcp servers the 2 ∗ m sl seconds delay in the time_wait state is an important operational problem on servers having thousands of simultaneously opened tcp connections [fty99]. consider for example a busy web server that processes 10.000 tcp connections every second. if each of these connections remain in the time_wait state for 4 minutes, this implies that the server would have to maintain more than 2 million tcbs at any time. for this reason, some tcp implementations prefer to perform an abrupt connection release by sending a rst segment to close the connection [aw05] and immediately discard the corresponding tcb. however, if the rst segment is lost, the remote host continues to maintain a tcb for a connection no longer exists. this optimisation reduces the number of tcbs maintained by the host sending the rst segment but at the potential cost of increased processing on the remote host when the rst segment is lost.
the original tcp data transfer mechanisms were deﬁned in rfc 793. based on the experience of using tcp on the growing global internet, this part of the tcp speciﬁcation has been updated and improved several times, always while preserving the backward compatibility with older tcp implementations. in this section, we review the main data transfer mechanisms used by tcp. tcp is a window-based transport protocol that provides a bi-directional byte stream service. this has several implications on the ﬁelds of the tcp header and the mechanisms used by tcp. the three ﬁelds of the tcp header are :
• acknowledgement number. tcp uses cumulative positive acknowledgements. each tcp segment contains the sequence number of the next byte that the sender of the acknowledgement expects to receive from the remote host. in theory, the acknowledgement number is only valid if the ack ﬂag of the tcp header is set. in practice almost all 15 tcp segments have their ack ﬂag set.
note: the transmission control block for each established tcp connection, a tcp implementation must maintain a transmission control block (tcb). a tcb contains all the information required to send and receive segments on this connection rfc 793. this includes 16 :
• the local ip address • the remote ip address • the local tcp port number • the remote tcp port number • the current state of the tcp fsm • the maximum segment size (mss)
15 in practice, only the syn segment do not have their ack ﬂag set. 16 a complete tcp implementation contains additional information in its tcb, notably to support the urgent pointer. however, this part of
second, as the network layer is imperfect, the cr or ca segment can be lost, delayed, or suffer from transmission errors. to deal with these problems, the control segments must be protected by using a crc or checksum to detect transmission errors. furthermore, since the ca segment acknowledges the reception of the cr segment, the cr segment can be protected by using a retransmission timer. unfortunately, this scheme is not sufﬁcient to ensure the reliability of the transport service. consider for example a short-lived transport connection where a single, but important transfer (e.g. money transfer from a bank account) is sent. such a short-lived connection starts with a cr segment acknowledged by a ca segment, then the data segment is sent, acknowledged and the connection terminates. unfortunately, as the network layer service is unreliable, delays combined to retransmissions may lead to the situation depicted in the ﬁgure below, where a delayed cr and data segments from a former connection are accepted by the receiving entity as valid segments, and the corresponding data is delivered to the user. duplicating sdus is not acceptable, and the transport protocol must solve this problem.
to avoid these duplicates, transport protocols require the network layer to bound the maximum segment lifetime (msl). the organisation of the network must guarantee that no segment remains in the network for longer than msl seconds. on today’s internet, msl is expected to be 2 minutes. to avoid duplicate transport connections, transport protocol entities must be able to safely distinguish between a duplicate cr segment and a new cr segment, without forcing each transport entity to remember all the transport connections that it has established in the past. a classical solution to avoid remembering the previous transport connections to detect duplicates is to use a clock inside each transport entity. this transport clock has the following characteristics :
• the transport clock is implemented as a k bits counter and its clock cycle is such that 2k × cycle >> m sl. furthermore, the transport clock counter is incremented every clock cycle and after each connection establishment. this clock is illustrated in the ﬁgure below.
it should be noted that transport clocks do not need and usually are not synchronised to the real-time clock. precisely synchronising real-time clocks is an interesting problem, but it is outside the scope of this document. see [mills2006] for a detailed discussion on synchronising the real-time clock.
contains information about its origin and its destination, and usually passes through several intermediate devices called routers on its way from its origin to its destination.
most realisations of the network layer, including the internet, do not provide a reliable service. however, many applications need to exchange information reliably and so using the network layer service directly would be very difﬁcult for them. ensuring the reliable delivery of the data produced by applications is the task of the transport layer. transport layer entities exchange segments. a segment is a ﬁnite sequence of bytes that are transported inside one or more packets. a transport layer entity issues segments (or sometimes part of segments) as data.request to the underlying network layer entity. there are different types of transport layers. the most widely used transport layers on the internet are tcp ,that provides a reliable connection-oriented bytestream transport service, and udp ,that provides an unreliable connection-less transport service.
the upper layer of our architecture is the application layer. this layer includes all the mechanisms and data structures that are necessary for the applications. we will use application data unit (adu) to indicate the data exchanged between two entities of the application layer.
in contrast with osi, the tcp/ip community did not spend a lot of effort deﬁning a detailed reference model; in fact, the goals of the internet architecture were only documented after tcp/ip had been deployed [clark88]. rfc 1122 , which deﬁnes the requirements for internet hosts, mentions four different layers. starting from the top, these are :
• an application layer • a transport layer • an internet layer which is equivalent to the network layer of our reference model • a link layer which combines the functionalities of the physical and datalink layers of our ﬁve-layer reference
physical layerdatalinknetworkphysical layerdatalinknetworkphysical layerdatalinknetworkpacketspacketsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportsegmentsphysical layerdatalinknetworkphysical layerdatalinknetworktransportphysical layerdatalinknetworktransportaduapplicationapplicationsaylor url: http://www.saylor.org/courses/cs402/the saylor foundation
note: static or dynamic link metrics ? as link state packets are ﬂooded regularly, routers are able to measure the quality (e.g. delay or load) of their links and adjust the metric of each link according to its current quality. such dynamic adjustments were included in the arpanet routing protocol [mrr1979] . however, experience showed that it was difﬁcult to tune the dynamic adjustments and ensure that no forwarding loops occur in the network [kz1989]. today’s link state routing protocols use metrics that are manually conﬁgured on the routers and are only changed by the network operators or network management tools [frt2002].
when a link fails, the two routers attached to the link detect the failure by the lack of hello messages received in the last k × n seconds. once a router has detected a local link failure, it generates and ﬂoods a new lsp that no longer contains the failed link and the new lsp replaces the previous lsp in the network. as the two routers attached to a link do not detect this failure exactly at the same time, some links may be announced in only one direction. this is illustrated in the ﬁgure below. router e has detected the failures of link e-b and ﬂooded a new lsp, but router b has not yet detected the failure.
when a link is reported in the lsp of only one of the attached routers, routers consider the link as having failed and they remove it from the directed graph that they compute from their lsdb. this is called the two-way connectivity check. this check allows link failures to be ﬂooded quickly as a single lsp is sufﬁcient to announce such bad news. however, when a link comes up, it can only be used once the two attached routers have sent their lsps. the two-way connectivity check also allows for dealing with router failures. when a router fails, all its links fail by deﬁnition. unfortunately, it does not, of course, send a new lsp to announce its failure. the two-way connectivity check ensures that the failed router is removed from the graph. when a router has failed, its lsp must be removed from the lsdb of all routers 1. this can be done by using the age ﬁeld that is included in each lsp. the age ﬁeld is used to bound the maximum lifetime of a link state packet in the network. when a router generates a lsp, it sets its lifetime (usually measured in seconds) in the age ﬁeld. all routers regularly decrement the age of the lsps in their lsdb and a lsp is discarded once its age reaches 0. thanks to the age ﬁeld, the lsp from a failed router does not remain in the lsdbs forever. to compute its routing table, each router computes the spanning tree rooted at itself by using dijkstra’s shortest path algorithm [dijkstra1959]. the routing table can be derived automatically from the spanning as shown in the ﬁgure below.
the internet protocol (ip) is the network layer protocol of the tcp/ip protocol suite. ip allows the applications running above the transport layer (udp/tcp) to use a wide range of heterogeneous datalink layers. ip was
1 it should be noted that link state routing assumes that all routers in the network have enough memory to store the entire lsdb. the routers that do not have enough memory to store the entire lsdb cannot participate in link state routing. some link state routing protocols allow routers to report that they do not have enough memory and must be removed from the graph by the other routers in the network.
does not have a matching connection attempt and replies by sending a reject. unfortunately, this segment never reaches the remote entity. instead, the remote entity receives a retransmission of an older ca segment that contains the same sequence number as the ﬁrst cr segment. this ca segment cannot be accepted by the remote entity as a conﬁrmation of the transport connection as its acknowledgement number cannot have the same value as the sequence number of the ﬁrst ca segment.
when we discussed the connection-oriented service, we mentioned that there are two types of connection releases : abrupt release and graceful release. the ﬁrst solution to release a transport connection is to deﬁne a new control segment (e.g. the dr segment) and consider the connection to be released once this segment has been sent or received. this is illustrated in the ﬁgure below.
as the entity that sends the dr segment cannot know whether the other entity has already sent all its data on the connection, sdus can be lost during such an abrupt connection release. the second method to release a transport connection is to release independently the two directions of data transfer. once a user of the transport service has sent all its sdus, it performs a disconnect.req for its direction of data transfer. the transport entity sends a control segment to request the release of the connection after the delivery of all previous sdus to the remote user. this is usually done by placing in the dr the next sequence number and by delivering the disconnect.ind only after all previous data.ind. the remote entity conﬁrms the reception of the dr segment and the release of the corresponding direction of data transfer by returning an acknowledgement. this is illustrated in the ﬁgure below.
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
• the privileged port numbers (1 < port < 1024 ) • the ephemeral port numbers ( ofﬁcially 8 49152 <= port <= 65535 ) • the registered port numbers (ofﬁcially 1024 <= port < 49152)
in most unix variants, only processes having system administrator privileges can be bound to port numbers smaller than 1024. well-known servers such as dns, ntp or rpc use privileged port numbers. when a client needs to use udp, it usually does not require a speciﬁc port number. in this case, the udp implementation will allocate the ﬁrst available port number in the ephemeral range. the range of registered port numbers should be used by servers. in theory, developers of network servers should register their port number ofﬁcially through iana, but few developers do this.
• a pseudo header containing the source ip address, the destination ip address and a 32 bits bit ﬁeld containing the most signiﬁcant byte set to 0, the second set to 17 and the length of the udp segment in the lower two bytes
this pseudo-header allows the receiver to detect errors affecting the ip source or destination addresses placed in the ip layer below. this is a violation of the layering principle that dates from the time when udp and ip were elements of a single protocol. it should be noted that if the checksum algorithm computes value ‘0x0000’, then value ‘0xffff’ is transmitted. a udp segment whose checksum is set to ‘0x0000’ is a segment for which the transmitter did not compute a checksum upon transmission. some nfs servers chose to disable udp checksums for performance reasons, but this caused problems that were difﬁcult to diagnose. in practice, there are rarely good reasons to disable udp checksums. a detailed discussion of the implementation of the internet checksum may be found in rfc 1071
several types of applications rely on udp. as a rule of thumb, udp is used for applications where delay must be minimised or losses can be recovered by the application itself. a ﬁrst class of the udp-based applications are applications where the client sends a short request and expects a quick and short answer. the dns is an example of
the user datagram protocol (udp) is deﬁned in rfc 768. it provides an unreliable connectionless transport service on top of the unreliable network layer connectionless service. the main characteristics of the udp service are :
• the udp service cannot deliver sdus that are larger than 65507 bytes 7 • the udp service does not guarantee the delivery of sdus (losses and desquencing can occur) • the udp service will not deliver a corrupted sdu to the destination
compared to the connectionless network layer service, the main advantage of the udp service is that it allows several applications running on a host to exchange sdus with several other applications running on remote hosts. let us consider two hosts, e.g. a client and a server. the network layer service allows the client to send information to the server, but if an application running on the client wants to contact a particular application running on the server, then an additional addressing mechanism is required other than the ip address that identiﬁes a host, in order to differentiate the application running on a host. this additional addressing is provided by port numbers. when a server using udp is enabled on a host, this server registers a port number. this port number will be used by the clients to contact the server process via udp. the ﬁgure below shows a typical usage of the udp port numbers. the client process uses port number 1234 while the server process uses port number 5678. when the client sends a request, it is identiﬁed as originating from port number 1234 on the client host and destined to port number 5678 on the server host. when the server process replies to this request, the server’s udp implementation will send the reply as originating from port 5678 on the server host and destined to port 1234 on the client host. udp uses a single segment format shown in the ﬁgure below. the udp header contains four ﬁelds :
as the port numbers are encoded as a 16 bits ﬁeld, there can be up to only 65535 different server processes that are bound to a different udp port at the same time on a given server. in practice, this limit is never reached. however, it is worth noticing that most implementations divide the range of allowed udp port numbers into three different ranges :
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
the drawback of pa addresses is that when a company using a pa address block changes its provider, it needs to change all the addresses that it uses. this can be a nightmare from an operational perspective and many companies are lobbying to obtain pi address blocks even if they are small and connected to a single provider. the typical size of the ipv6 address blocks are :
• /32 for an internet service provider • /48 for a single company • /64 for a single user (e.g. a home user connected via adsl) • /128 in the rare case when it is known that no more than one endhost will be attached
for the companies that want to use ipv6 without being connected to the ipv6 internet, rfc 4193 deﬁnes the unique local unicast (ula) addresses (fc00::/7). these ula addresses play a similar role as the private ipv4 addresses deﬁned in rfc 1918. however, the size of the fc00::/7 address block allows ula to be much more ﬂexible than private ipv4 addresses. furthermore, the ietf has reserved some ipv6 addresses for a special usage. the two most important ones are : • 0:0:0:0:0:0:0:1 (::1 in compact form) is the ipv6 loopback address. this is the address of a logical interface
the last type of unicast ipv6 addresses are the link local unicast addresses. these addresses are part of the fe80::/10 address block and are deﬁned in rfc 4291. each host can compute its own link local address by concatenating the fe80::/64 preﬁx with the 64 bits identiﬁer of its interface. link local addresses can be used when hosts that are attached to the same link (or local area network) need to exchange packets. they are used notably for address discovery and auto-conﬁguration purposes. their usage is restricted to each link and a router cannot forward a packet whose source or destination address is a link local address. link local addresses have also been deﬁned for ipv4 rfc 3927. however, the ipv4 link local addresses are only used when a host cannot obtain a regular ipv4 address, e.g. on an isolated lan.
an important consequence of the ipv6 unicast addressing architecture and the utilisation of link-local addresses is that an ipv6 host has several ipv6 addresses. this implies that an ipv6 stack must be able to handle multiple ipv6 addresses. this was not always the case with ipv4. rfc 4291 deﬁnes a special type of ipv6 anycast address. on a subnetwork having preﬁx p/n, the ipv6 address whose 128-n low-order bits are set to 0 is the anycast address that corresponds to all routers inside this subnetwork. this anycast address can be used by hosts to quickly send a packet to any of the routers inside their own subnetwork. finally, rfc 4291 deﬁnes the structure of the ipv6 multicast addresses 18. this structure is depicted in the ﬁgure below the low order 112 bits of an ipv6 multicast address are the group’s identiﬁer. the high order bits are used as a marker to distinguish multicast addresses from unicast addresses. notably, the 4 bits ﬂag ﬁeld indicates whether the address is temporary or permanent. finally, the scope ﬁeld indicates the boundaries of the forwarding of packets destined to a particular address. a link-local scope indicates that a router should not forward a packet destined to such a multicast address. an organisation local-scope indicates that a packet sent to such a multicast destination address should not leave the organisation. finally the global scope is intended for multicast groups spanning the global internet.
is represented by a plain horizontal arrow, to which the name of the primitive is attached. the dashed lines are used to represent the possible relationship between two (or more) primitives. such a diagram provides information about the ordering of the different primitives, but the distance between two primitives does not represent a precise amount of time. the ﬁgure below provides a representation of the connectionless service as a time-sequence diagram. the user on the left, having address s, issues a data.request primitive containing sdu m that must be delivered by the service provider to destination d. the dashed line between the two primitives indicates that the data.indication primitive that is delivered to the user on the right corresponds to the data.request primitive sent by the user on the left.
there are several possible implementations of the connectionless service, which we will discuss later in this book. before studying these realisations, it is useful to discuss the possible characteristics of the connectionless service. a reliable connectionless service is a service where the service provider guarantees that all sdus submitted in data.requests by a user will eventually be delivered to their destination. such a service would be very useful for users, but guaranteeing perfect delivery is difﬁcult in practice. for this reason, computer networks usually support an unreliable connectionless service. an unreliable connectionless service may suffer from various types of problems compared to a reliable connectionless service. first of all, an unreliable connectionless service does not guarantee the delivery of all sdus. this can be expressed graphically by using the time-sequence diagram below. in practice, an unreliable connectionless service will usually deliver a large fraction of the sdus. however, since the delivery of sdus is not guaranteed, the user must be able to recover from the loss of any sdu. a second imperfection that may affect an unreliable connectionless service is that it may duplicate sdus. some unreliable connectionless service providers may deliver an sdu sent by a user twice or even more. this is illustrated by the time-sequence diagram below. finally, some unreliable connectionless service providers may deliver to a destination a different sdu than the one that was supplied in the data.request. this is illustrated in the ﬁgure below. when a user interacts with a service provider, it must precisely know the limitations of the underlying service to be able to overcome any problem that may arise. this requires a precise deﬁnition of the characteristics of the underlying service. another important characteristic of the connectionless service is whether it preserves the ordering of the sdus sent by one user. from the user’s viewpoint, this is often a desirable characteristic. this is illustrated in the ﬁgure below. however, many connectionless services, and in particular the unreliable services, do not guarantee that they will always preserve the ordering of the sdus sent by each user. this is illustrated in the ﬁgure below.
3. the network layer is conceptually divided into two planes : the data plane and the control plane. the data plane contains the protocols and mechanisms that allow hosts and routers to exchange packets carrying user data. the control plane contains the protocols and mechanisms that enable routers to efﬁciently learn how to forward packets towards their ﬁnal destination.
the independence of the network layer from the underlying datalink layer is a key principle of the network layer. it ensures that the network layer can be used to allow hosts attached to different types of datalink layers to exchange packets through intermediate routers. furthermore, this allows the datalink layers and the network layer to evolve independently from each other. this enables the network layer to be easily adapted to a new datalink layer every time a new datalink layer is invented. there are two types of service that can be provided by the network layer :
connection-oriented services have been popular with technologies such as x.25 and atm or frame-relay, but nowadays most networks use an unreliable connectionless service. this is our main focus in this chapter.
the internal organisation of the network is orthogonal to the service that it provides, but most of the time a datagram organisation is used to provide a connectionless service while a virtual circuit organisation is used in networks that provide a connection-oriented service.
the ﬁrst and most popular organisation of the network layer is the datagram organisation. this organisation is inspired by the organisation of the postal service. each host is identiﬁed by a network layer address. to send information to a remote host, a host creates a packet that contains :
the network layer limits the maximum packet size. thus, the information must have been divided in packets by the transport layer before being passed to the network layer. to understand the datagram organisation, let us consider the ﬁgure below. a network layer address, represented by a letter, has been assigned to each host and router. to send some information to host j, host a creates a packet containing its own address, the destination address and the information to be exchanged. with the datagram organisation, routers use hop-by-hop forwarding. this means that when a router receives a packet that is not destined to itself, it looks up the destination address of the packet in its routing table. a routing table is a data structure that maps each destination address (or set of destination addresses) to the outgoing interface over which a packet destined to this address must be forwarded to reach its ﬁnal destination. the main constraint imposed on the routing tables is that they must allow any host in the network to reach any other host. this implies that each router must know a route towards each destination, but also that the paths composed from the information stored in the routing tables must not contain loops. otherwise, some destinations would be unreachable.
reaches switch4. switch4 compares the priority vector built from this bpdu (i.e. <1,2,9,2>) and notices that it is better than switch4 ‘s bpdu=<1,3,4,2>. thus, port 2 becomes a blocked port on switch4. during the computation of the spanning tree, switches discard all received data frames, as at that time the network topology is not guaranteed to be loop-free. once that topology has been stable for some time, the switches again start to use the mac learning algorithm to forward data frames. only the root and designated ports are used to forward data frames. switches discard all the data frames received on their blocked ports and never forward frames on these ports. switches, ports and links can fail in a switched ethernet network. when a failure occurs, the switches must be able to recompute the spanning tree to recover from the failure. the spanning tree protocol relies on regular transmissions of the bpdus to detect these failures. a bpdu contains two additional ﬁelds : the age of the bpdu and the maximum age. the age contains the amount of time that has passed since the root switch initially originated the bpdu. the root switch sends its bpdu with an age of zero and each switch that computes its own bpdu increments its age by one. the age of the bpdus stored on a switch’s table is also incremented every second. a bpdu expires when its age reaches the maximum age. when the network is stable, this does not happen as bpdu s are regularly sent by the root switch and downstream switches. however, if the root fails or the network becomes partitioned, bpdu will expire and switches will recompute their own bpdu and restart the spanning tree protocol. once a topology change has been detected, the forwarding of the data frames stops as the topology is not guaranteed to be loop-free. additional details about the reaction to failures may be found in [802.1d]
another important advantage of ethernet switches is the ability to create virtual local area networks (vlans). a virtual lan can be deﬁned as a set of ports attached to one or more ethernet switches. a switch can support several vlans and it runs one mac learning algorithm for each virtual lan. when a switch receives a frame with an unknown or a multicast destination, it forwards it over all the ports that belong to the same virtual lan but not over the ports that belong to other virtual lans. similarly, when a switch learns a source address on a port, it associates it to the virtual lan of this port and uses this information only when forwarding frames on this virtual lan. the ﬁgure below illustrates a switched ethernet network with three virtual lans. vlan2 and vlan3 only require a local conﬁguration of switch s1. host c can exchange frames with host d, but not with hosts that are outside of its vlan. vlan1 is more complex as there are ports of this vlan on several switches. to support such vlans, local conﬁguration is not sufﬁcient anymore. when a switch receives a frame from another switch, it must be able to determine the vlan in which the frame originated to use the correct mac table to forward the frame. this is done by assigning an identiﬁer to each virtual lan and placing this identiﬁer inside the headers of the frames that are exchanged between switches.
ieee deﬁned in the [802.1q] standard a special header to encode the vlan identiﬁers. this 32 bit header includes a 20 bit vlan ﬁeld that contains the vlan identiﬁer of each frame. the format of the [802.1q] header is described below. the [802.1q] header is inserted immediately after the source mac address in the ethernet frame (i.e. before the ethertype ﬁeld). the maximum frame size is increased by 4 bytes. it is encoded in 32 bits and contains four
reaches switch4. switch4 compares the priority vector built from this bpdu (i.e. <1,2,9,2>) and notices that it is better than switch4 ‘s bpdu=<1,3,4,2>. thus, port 2 becomes a blocked port on switch4. during the computation of the spanning tree, switches discard all received data frames, as at that time the network topology is not guaranteed to be loop-free. once that topology has been stable for some time, the switches again start to use the mac learning algorithm to forward data frames. only the root and designated ports are used to forward data frames. switches discard all the data frames received on their blocked ports and never forward frames on these ports. switches, ports and links can fail in a switched ethernet network. when a failure occurs, the switches must be able to recompute the spanning tree to recover from the failure. the spanning tree protocol relies on regular transmissions of the bpdus to detect these failures. a bpdu contains two additional ﬁelds : the age of the bpdu and the maximum age. the age contains the amount of time that has passed since the root switch initially originated the bpdu. the root switch sends its bpdu with an age of zero and each switch that computes its own bpdu increments its age by one. the age of the bpdus stored on a switch’s table is also incremented every second. a bpdu expires when its age reaches the maximum age. when the network is stable, this does not happen as bpdu s are regularly sent by the root switch and downstream switches. however, if the root fails or the network becomes partitioned, bpdu will expire and switches will recompute their own bpdu and restart the spanning tree protocol. once a topology change has been detected, the forwarding of the data frames stops as the topology is not guaranteed to be loop-free. additional details about the reaction to failures may be found in [802.1d]
another important advantage of ethernet switches is the ability to create virtual local area networks (vlans). a virtual lan can be deﬁned as a set of ports attached to one or more ethernet switches. a switch can support several vlans and it runs one mac learning algorithm for each virtual lan. when a switch receives a frame with an unknown or a multicast destination, it forwards it over all the ports that belong to the same virtual lan but not over the ports that belong to other virtual lans. similarly, when a switch learns a source address on a port, it associates it to the virtual lan of this port and uses this information only when forwarding frames on this virtual lan. the ﬁgure below illustrates a switched ethernet network with three virtual lans. vlan2 and vlan3 only require a local conﬁguration of switch s1. host c can exchange frames with host d, but not with hosts that are outside of its vlan. vlan1 is more complex as there are ports of this vlan on several switches. to support such vlans, local conﬁguration is not sufﬁcient anymore. when a switch receives a frame from another switch, it must be able to determine the vlan in which the frame originated to use the correct mac table to forward the frame. this is done by assigning an identiﬁer to each virtual lan and placing this identiﬁer inside the headers of the frames that are exchanged between switches.
ieee deﬁned in the [802.1q] standard a special header to encode the vlan identiﬁers. this 32 bit header includes a 20 bit vlan ﬁeld that contains the vlan identiﬁer of each frame. the format of the [802.1q] header is described below. the [802.1q] header is inserted immediately after the source mac address in the ethernet frame (i.e. before the ethertype ﬁeld). the maximum frame size is increased by 4 bytes. it is encoded in 32 bits and contains four
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
these four basic physical organisations of local area networks are shown graphically in the ﬁgure below. we will ﬁrst focus on one physical organisation at a time.
the common problem among all of these network organisations is how to efﬁciently share the access to the local area network. if two devices send a frame at the same time, the two electrical, optical or radio signals that correspond to these frames will appear at the same time on the transmission medium and a receiver will not be able to decode either frame. such simultaneous transmissions are called collisions. a collision may involve frames transmitted by two or more devices attached to the local area network. collisions are the main cause of errors in wired local area networks. all local area network technologies rely on a medium access control algorithm to regulate the transmissions to either minimise or avoid collisions. there are two broad families of medium access control algorithms :
1. deterministic or pessimistic mac algorithms. these algorithms assume that collisions are a very severe problem and that they must be completely avoided. these algorithms ensure that at any time, at most one device is allowed to send a frame on the lan. this is usually achieved by using a distributed protocol which elects one device that is allowed to transmit at each time. a deterministic mac algorithm ensures that no collision will happen, but there is some overhead in regulating the transmission of all the devices attached to the lan.
2. stochastic or optimistic mac algorithms. these algorithms assume that collisions are part of the normal operation of a local area network. they aim to minimise the number of collisions, but they do not try to avoid all collisions. stochastic algorithms are usually easier to implement than deterministic ones.
we ﬁrst discuss a simple deterministic mac algorithm and then we describe several important optimistic algorithms, before coming back to a distributed and deterministic mac algorithm.
a ﬁrst solution to share the available resources among all the devices attached to one local area network is to deﬁne, a priori, the distribution of the transmission resources among the different devices. if n devices need to share the transmission capacities of a lan operating at b mbps, each device could be allocated a bandwidth of b n mbps. limited resources need to be shared in other environments than local area networks. since the ﬁrst radio transmissions by marconi more than one century ago, many applications that exchange information through radio signals have been developed. each radio signal is an electromagnetic wave whose power is centered around a given frequency. the radio spectrum corresponds to frequencies ranging between roughly 3 khz and 300 ghz. frequency allocation plans negotiated among governments reserve most frequency ranges for speciﬁc applications such as broadcast radio, broadcast television, mobile communications, aeronautical radio navigation, amateur radio, satellite, etc. each frequency range is then subdivided into channels and each channel can be reserved for a given application, e.g. a radio broadcaster in a given region. frequency division multiplexing (fdm) is a static allocation scheme in which a frequency is allocated to each device attached to the shared medium. as each device uses a different transmission frequency, collisions cannot
these four basic physical organisations of local area networks are shown graphically in the ﬁgure below. we will ﬁrst focus on one physical organisation at a time.
the common problem among all of these network organisations is how to efﬁciently share the access to the local area network. if two devices send a frame at the same time, the two electrical, optical or radio signals that correspond to these frames will appear at the same time on the transmission medium and a receiver will not be able to decode either frame. such simultaneous transmissions are called collisions. a collision may involve frames transmitted by two or more devices attached to the local area network. collisions are the main cause of errors in wired local area networks. all local area network technologies rely on a medium access control algorithm to regulate the transmissions to either minimise or avoid collisions. there are two broad families of medium access control algorithms :
1. deterministic or pessimistic mac algorithms. these algorithms assume that collisions are a very severe problem and that they must be completely avoided. these algorithms ensure that at any time, at most one device is allowed to send a frame on the lan. this is usually achieved by using a distributed protocol which elects one device that is allowed to transmit at each time. a deterministic mac algorithm ensures that no collision will happen, but there is some overhead in regulating the transmission of all the devices attached to the lan.
2. stochastic or optimistic mac algorithms. these algorithms assume that collisions are part of the normal operation of a local area network. they aim to minimise the number of collisions, but they do not try to avoid all collisions. stochastic algorithms are usually easier to implement than deterministic ones.
we ﬁrst discuss a simple deterministic mac algorithm and then we describe several important optimistic algorithms, before coming back to a distributed and deterministic mac algorithm.
a ﬁrst solution to share the available resources among all the devices attached to one local area network is to deﬁne, a priori, the distribution of the transmission resources among the different devices. if n devices need to share the transmission capacities of a lan operating at b mbps, each device could be allocated a bandwidth of b n mbps. limited resources need to be shared in other environments than local area networks. since the ﬁrst radio transmissions by marconi more than one century ago, many applications that exchange information through radio signals have been developed. each radio signal is an electromagnetic wave whose power is centered around a given frequency. the radio spectrum corresponds to frequencies ranging between roughly 3 khz and 300 ghz. frequency allocation plans negotiated among governments reserve most frequency ranges for speciﬁc applications such as broadcast radio, broadcast television, mobile communications, aeronautical radio navigation, amateur radio, satellite, etc. each frequency range is then subdivided into channels and each channel can be reserved for a given application, e.g. a radio broadcaster in a given region. frequency division multiplexing (fdm) is a static allocation scheme in which a frequency is allocated to each device attached to the shared medium. as each device uses a different transmission frequency, collisions cannot
ﬁelds. the tag protocol identiﬁer is set to 0x8100 to allow the receiver to detect the presence of this additional header. the priority code point (pcp) is a three bit ﬁeld that is used to support different transmission priorities for the frame. value 0 is the lowest priority and value 7 the highest. frames with a higher priority can expect to be forwarded earlier than frames having a lower priority. the c bit is used for compatibility between ethernet and token ring networks. the last 12 bits of the 802.1q header contain the vlan identiﬁer. value 0 indicates that the frame does not belong to any vlan while value 0xfff is reserved. this implies that 4094 different vlan identiﬁers can be used in an ethernet network.
the radio spectrum is a limited resource that must be shared by everyone. during most of the twentieth century, governments and international organisations have regulated most of the radio spectrum. this regulation controls the utilisation of the radio spectrum, in order to ensure that there are no interferences between different users. a company that wants to use a frequency range in a given region must apply for a license from the regulator. most regulators charge a fee for the utilisation of the radio spectrum and some governments have encouraged competition among companies bidding for the same frequency to increase the license fees. in the 1970s, after the ﬁrst experiments with alohanet, interest in wireless networks grew. many experiments were done on and outside the arpanet. one of these experiments was the ﬁrst mobile phone , which was developed and tested in 1973. this experimental mobile phone was the starting point for the ﬁrst generation analog mobile phones. given the growing demand for mobile phones, it was clear that the analog mobile phone technology was not sufﬁcient to support a large number of users. to support more users and new services, researchers in several countries worked on the development of digital mobile telephones. in 1987, several european countries decided to develop the standards for a common cellular telephone system across europe : the global system for mobile communications (gsm). since then, the standards have evolved and more than three billion users are connected to gsm networks today. while most of the frequency ranges of the radio spectrum are reserved for speciﬁc applications and require a special licence, there are a few exceptions. these exceptions are known as the industrial, scientiﬁc and medical (ism) radio bands. these bands can be used for industrial, scientiﬁc and medical applications without requiring a licence from the regulator. for example, some radio-controlled models use the 27 mhz ism band and some cordless telephones operate in the 915 mhz ism. in 1985, the 2.400-2.500 ghz band was added to the list of ism bands. this frequency range corresponds to the frequencies that are emitted by microwave ovens. sharing this band with licensed applications would have likely caused interferences, given the large number of microwave ovens that are used. despite the risk of interferences with microwave ovens, the opening of the 2.400-2.500 ghz allowed the networking industry to develop several wireless network techniques to allow computers to exchange data without using cables. in this section, we discuss in more detail the most popular one, i.e. the wifi [802.11] family of wireless networks. other wireless networking techniques such as bluetooth or hiperlan use the same frequency range. today, wifi is a very popular wireless networking technology. there are more than several hundreds of millions of wifi devices. the development of this technology started in the late 1980s with the wavelan proprietary wireless network. wavelan operated at 2 mbps and used different frequency bands in different regions of the world. in the early 1990s, the ieee created the 802.11 working group to standardise a family of wireless network technologies. this working group was very proliﬁc and produced several wireless networking standards that use different frequency ranges and different physical layers. the table below provides a summary of the main 802.11 standards.
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
tcp/ip refers to the tcp and ip protocols telnet the telnet protocol is deﬁned in rfc 854 tld a top-level domain name. there are two types of tlds. the cctld are the tld that correspond to a two
tls transport layer security, deﬁned in rfc 5246 is a cryptographic protocol that is used to provide communication security for internet applications. this protocol is used on top of the transport service but a detailed description is outside the scope of this book.
unicast a transmission mode where an information is sent from one source to one recipient vnc a networked application that allows to remotely access a computer’s graphical user interface. see
wan wide area network x.25 a wide area networking technology using virtual circuits that was deployed by telecom operators. x11 the xwindow system and the associated protocols are deﬁned in [sg1990] xml the extensible markup language (xml) is a ﬂexible text format derived from sgml. it was originally designed for the electronic publishing industry but is now used by a wide variety of applications that need to exchange structured data. the xml speciﬁcations are maintained by several working groups of the w3c
